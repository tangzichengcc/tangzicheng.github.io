{
    "version": "https://jsonfeed.org/version/1",
    "title": "唐仔橙 • All posts by \"虚拟化\" category",
    "description": "喜欢探索世界,在读研究生,计算机爱好者的成长记录",
    "home_page_url": "https://tangzichengcc.github.io",
    "items": [
        {
            "id": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "url": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "title": "虚拟化入门-3-内存虚拟化代码分析",
            "date_published": "2023-09-19T10:19:06.000Z",
            "content_html": "<h1 id=\"一、保护模式Guest的寻址\"><a href=\"#一、保护模式Guest的寻址\" class=\"headerlink\" title=\"一、保护模式Guest的寻址\"></a>一、保护模式Guest的寻址</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>​\t\t为每个guest进程分别制作一张表，记录着GVA到HPA的映射关系。guest模式下的cr3寄存器不再指向内部GVA到GPA映射的表，<strong>而是指向这张新的表。</strong>当MMU收到GVA时，通过遍历这张新的表，将GVA翻译成HPA。</p>\n<p>​\t\t\t因为guest自身页表不能完成GVA到HPA的多层地址映射，<strong>因此每当guest设置cr3寄存器时，KVM都需要截获这个操作，将cr3替换为影子页表</strong>，因此每次设置cr3时都需要触发虚拟机退出，陷入KVM模块。（无疑会造成很大的资源消耗，有EPT之后就不用了）</p>\n<p>​\t\t两个关键点：</p>\n<ol>\n<li>KVM需要构建GVA映射到HPA的页表，<strong>这个页表需要根据guest内部页表的信息更新</strong>，实际地址映射时生效的是这张页表，会将guest内部的页表给隐藏起来，所以它叫影子页表</li>\n<li>保护模式的guest有自己的页表，而且不只有一个页表，<strong>每个任务都会有自己的页表，随着任务的切换而更换页表</strong>，所以，KVM也需要准备多个影子页表，每个guest任务对应一个。 <strong>并且在guest内部任务切换时，kvm需要捕获这个切换，切换对应的影子页表。</strong></li>\n</ol>\n<p>​\t\t建立映射时，需要经过三次转换：</p>\n<ul>\n<li>第一次是guest使用自身的页表完成GVA到GPA的转换</li>\n<li>第二次是KVM根据内存条信息完成GPA到HVA的转换</li>\n<li>第三次是host利用内核的内存管理机制完成HVA到HPA的转换</li>\n</ul>\n<p>​\t\t影子页表构建好后，在映射建立完成后，GVA到HPA经过一次映射即可。</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20230917150408144.png\" alt=\"image-20230917150408144\" style=\"zoom: 80%;\">\n\n<h2 id=\"影子页表的建立-x2F-缺页异常处理\"><a href=\"#影子页表的建立-x2F-缺页异常处理\" class=\"headerlink\" title=\"影子页表的建立 &#x2F; 缺页异常处理\"></a>影子页表的建立 &#x2F; 缺页异常处理</h2><p>​\t\t保护模式guest发生缺页异常时，控制cr2寄存器中存储的是GVA，而只有guest知道GVA到GPA的映射，所以，缺页异常处理函数首先<strong>需要遍历guest的页表，取出对应的GPA。</strong></p>\n<p>​\t\t如果没有建立GVA到GPA的映射，则KVM向guest注入<strong>缺页异常</strong>，guest进行正常的缺页异常处理，完成GVA到GPA的映射。建立好GVA到GPA的映射后，然后再继续建立GVA到HPA的映射。</p>\n<p>​\t\t刚开始时，影子页表是空的，所以开始时任何内存访问操作都会引起缺页异常，导致vm exit 进入handle_exception_nmi (不可屏蔽中断异常处理)</p>\n<p>​\t\thandle_exception_nmi从这里进入异常处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_exception_nmi</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_run</span> *<span class=\"title\">kvm_run</span> =</span> vcpu-&gt;run;</span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_page_fault(intr_info)) &#123;</span><br><span class=\"line\">\t\tcr2 = vmx_get_exit_qual(vcpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (enable_ept &amp;&amp; !vcpu-&gt;arch.apf.host_apf_flags) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * EPT will cause page fault only if we need to</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * detect illegal GPAs.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tWARN_ON_ONCE(!allow_smaller_maxphyaddr);</span><br><span class=\"line\">\t\t\tkvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_handle_page_fault(vcpu, error_code, cr2, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t调用链如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- kvm_handle_page_fault</span><br><span class=\"line\">    - kvm_mmu_page_fault</span><br><span class=\"line\">    \t- kvm_mmu_do_page_fault</span><br><span class=\"line\">    \t\t- </span><br></pre></td></tr></table></figure>\n\n<p>​\t\t到了这里之后, 如果没开启ept，会进入else，<font color=\"red\">猜测这里的page_fault是FNAME(page_fault)，这样就连起来了</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_do_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\tu32 err, <span class=\"type\">bool</span> prefetch, <span class=\"type\">int</span> *emulation_type)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ENABLED(CONFIG_RETPOLINE) &amp;&amp; fault.is_tdp)</span><br><span class=\"line\">\t\tr = kvm_tdp_page_fault(vcpu, &amp;fault);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu-&gt;arch.mmu-&gt;page_fault(vcpu, &amp;fault);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GVA-GPA-映射\"><a href=\"#GVA-GPA-映射\" class=\"headerlink\" title=\"GVA-GPA 映射\"></a>GVA-GPA 映射</h3><p>kvm\\mmu\\paging_tmpl.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(page_fault)</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">guest_walker</span> <span class=\"title\">walker</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpgprintk(<span class=\"string\">&quot;%s: addr %lx err %x\\n&quot;</span>, __func__, fault-&gt;addr, fault-&gt;error_code);</span><br><span class=\"line\">\tWARN_ON_ONCE(fault-&gt;is_tdp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Look up the guest pte for the faulting address.</span></span><br><span class=\"line\"><span class=\"comment\">\t * If PFEC.RSVD is set, this is a shadow page fault.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The bit needs to be cleared before walking guest page tables.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tr = FNAME(walk_addr)(&amp;walker, vcpu, fault-&gt;addr,</span><br><span class=\"line\">\t\t\t     fault-&gt;error_code &amp; ~PFERR_RSVD_MASK);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The page is not mapped by the guest.  Let the guest handle it.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!r) &#123;</span><br><span class=\"line\">\t\tpgprintk(<span class=\"string\">&quot;%s: guest page fault\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!fault-&gt;prefetch)</span><br><span class=\"line\">\t\t\tkvm_inject_emulated_page_fault(vcpu, &amp;walker.fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault-&gt;gfn = walker.gfn;</span><br><span class=\"line\">\tfault-&gt;max_level = walker.level;</span><br><span class=\"line\">\tfault-&gt;slot = kvm_vcpu_gfn_to_memslot(vcpu, fault-&gt;gfn);<span class=\"comment\">//获取内存条信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (page_fault_handle_page_track(vcpu, fault)) &#123;</span><br><span class=\"line\">\t\tshadow_page_table_clear_flood(vcpu, fault-&gt;addr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_EMULATE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = mmu_topup_memory_caches(vcpu, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = kvm_faultin_pfn(vcpu, fault, walker.pte_access);<span class=\"comment\">//关键函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r != RET_PF_CONTINUE)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t在硬件MMU中，Table walk单元负责遍历页表，这里函数walk_addr就相当于硬件MMu中Table walk，负责遍历guest页表。 <strong>异常处理函数首先调用这个函数遍历guess页表，尝试取出GPA</strong>，见14行代码，遍历完后，把具体信息保存在walker中。</p>\n<p>​\t\t感觉写的注释非常精髓</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch a guest pte for a guest virtual address, or for an L2&#x27;s GPA.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(walk_addr_generic)</span><span class=\"params\">(<span class=\"keyword\">struct</span> guest_walker *walker,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_mmu *mmu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"type\">gpa_t</span> addr, u64 access)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t\t如果返回0，说明没有建立映射，进行guest的缺页处理，注入异常，guest去建立GVA到GPA的映射。见20行。</p>\n<p>​\t\t进入到kvm_inject_emulated_page_fault</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">kvm_inject_emulated_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"keyword\">struct</span> x86_exception *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu</span> *<span class=\"title\">fault_mmu</span>;</span></span><br><span class=\"line\">\tWARN_ON_ONCE(fault-&gt;<span class=\"built_in\">vector</span> != PF_VECTOR);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault_mmu = fault-&gt;nested_page_fault ? vcpu-&gt;arch.mmu :</span><br><span class=\"line\">\t\t\t\t\t       vcpu-&gt;arch.walk_mmu;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invalidate the TLB entry for the faulting address, if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">\t * else the access will fault indefinitely (and to emulate hardware).</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((fault-&gt;error_code &amp; PFERR_PRESENT_MASK) &amp;&amp;</span><br><span class=\"line\">\t    !(fault-&gt;error_code &amp; PFERR_RSVD_MASK))</span><br><span class=\"line\">\t\tkvm_mmu_invalidate_addr(vcpu, fault_mmu, fault-&gt;address,</span><br><span class=\"line\">\t\t\t\t\tKVM_MMU_ROOT_CURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault_mmu-&gt;inject_page_fault(vcpu, fault);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t会调用 inject_page_fault, 对应的函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">kvm_inject_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> x86_exception *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t++vcpu-&gt;stat.pf_guest;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Async #PF in L2 is always forwarded to L1 as a VM-Exit regardless of</span></span><br><span class=\"line\"><span class=\"comment\">\t * whether or not L1 wants to intercept &quot;regular&quot; #PF.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_guest_mode(vcpu) &amp;&amp; fault-&gt;async_page_fault)</span><br><span class=\"line\">\t\tkvm_queue_exception_vmexit(vcpu, PF_VECTOR,</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"literal\">true</span>, fault-&gt;error_code,</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"literal\">true</span>, fault-&gt;address);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault-&gt;error_code,</span><br><span class=\"line\">\t\t\t\t\tfault-&gt;address);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GPA-HPA-映射\"><a href=\"#GPA-HPA-映射\" class=\"headerlink\" title=\"GPA-HPA 映射\"></a>GPA-HPA 映射</h3><p>​\t\t建立映射后往后走，来到下一个重要函数</p>\n<p>​\t\t<strong>kvm_faultin_pfn这个函数用来处理虚拟地址映射到宿主机的物理地址</strong></p>\n<p>mmu.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_faultin_pfn</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault-&gt;mmu_seq = vcpu-&gt;kvm-&gt;mmu_invalidate_seq;</span><br><span class=\"line\">\tsmp_rmb();</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = __kvm_faultin_pfn(vcpu, fault);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret != RET_PF_CONTINUE)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(is_error_pfn(fault-&gt;pfn)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_handle_error_pfn(vcpu, fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(!fault-&gt;slot))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_handle_noslot_fault(vcpu, fault, access);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RET_PF_CONTINUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t这其中主要调用__kvm_faultin_pfn完成实际映射工作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __kvm_faultin_pfn(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span> =</span> fault-&gt;slot;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> async;</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">\tasync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tfault-&gt;pfn = __gfn_to_pfn_memslot(slot, fault-&gt;gfn, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, &amp;async,</span><br><span class=\"line\">\t\t\t\t\t  fault-&gt;write, &amp;fault-&gt;map_writable,</span><br><span class=\"line\">\t\t\t\t\t  &amp;fault-&gt;hva);</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t而这里，最关键的是__gfn_to_pfn_memslot，通过这个函数拿到pfn</p>\n<h3 id=\"影子页表填充\"><a href=\"#影子页表填充\" class=\"headerlink\" title=\"影子页表填充\"></a>影子页表填充</h3><p>​\t\t映射和填充是两回事? </p>\n<p>for_each_shadow_entry用来迭代不同页表级别</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(fetch)</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"keyword\">struct</span> guest_walker *gw)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    \tfor_each_shadow_entry(vcpu, fault-&gt;addr, it) &#123; <span class=\"comment\">//应该是用来查找对应级别的页表目录</span></span><br><span class=\"line\">\t\t<span class=\"type\">gfn_t</span> table_gfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tclear_sp_write_flooding_count(it.sptep);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (it.level == gw-&gt;level)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttable_gfn = gw-&gt;table_gfn[it.level - <span class=\"number\">2</span>]; <span class=\"comment\">//获取当前页表级别的表项对应的页表页的GFN</span></span><br><span class=\"line\">\t\taccess = gw-&gt;pt_access[it.level - <span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tsp = kvm_mmu_get_child_sp(vcpu, it.sptep, table_gfn,</span><br><span class=\"line\">\t\t\t\t\t  <span class=\"literal\">false</span>, access); <span class=\"comment\">//尝试获取或创建当前页表级别的影子页表页，false表示不创建新的，仅尝试获取已存在的</span></span><br><span class=\"line\"><span class=\"comment\">//it.sptep 表示当前的SPTE</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp != ERR_PTR(-EEXIST)) &#123; <span class=\"comment\">// 成功获取或创建</span></span><br><span class=\"line\">\t\t.............</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Verify that the gpte in the page we&#x27;ve just write</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * protected is still there.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (FNAME(gpte_changed)(vcpu, gw, it.level - <span class=\"number\">1</span>))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_gpte_changed;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp != ERR_PTR(-EEXIST))</span><br><span class=\"line\">\t\t\tlink_shadow_page(vcpu, it.sptep, sp);<span class=\"comment\">//将影子页表与SPTE进行链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fault-&gt;write &amp;&amp; table_gfn == fault-&gt;gfn)</span><br><span class=\"line\">\t\t\tfault-&gt;write_fault_to_shadow_pgtable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">           .....</span><br><span class=\"line\">        ret = mmu_set_spte(vcpu, fault-&gt;slot, it.sptep, gw-&gt;pte_access,</span><br><span class=\"line\">\t\t\t   base_gfn, fault-&gt;pfn, fault); <span class=\"comment\">//设置/更新PTE</span></span><br><span class=\"line\">          .....</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_get_child_sp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_child_sp</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t u64 *sptep, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t <span class=\"type\">bool</span> direct, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_shadow_present_pte(*sptep) &amp;&amp; !is_large_pte(*sptep))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERR_PTR(-EEXIST); <span class=\"comment\">// 检查是否存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trole = kvm_mmu_child_role(sptep, direct, access); <span class=\"comment\">//新的页表的属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_mmu_get_shadow_page(vcpu, gfn, role);<span class=\"comment\">//查找/创建新的影子页表页</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_get_shadow_page来创建&#x2F;查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_shadow_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"keyword\">union</span> kvm_mmu_page_role role)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shadow_page_caches</span> <span class=\"title\">caches</span> =</span> &#123;</span><br><span class=\"line\">\t\t.page_header_cache = &amp;vcpu-&gt;arch.mmu_page_header_cache,</span><br><span class=\"line\">\t\t.shadow_page_cache = &amp;vcpu-&gt;arch.mmu_shadow_page_cache,</span><br><span class=\"line\">\t\t.shadowed_info_cache = &amp;vcpu-&gt;arch.mmu_shadowed_info_cache,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __kvm_mmu_get_shadow_page(vcpu-&gt;kvm, vcpu, &amp;caches, gfn, role);<span class=\"comment\">//gfn表示需要映射的guest页的地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t__kvm_mmu_get_shadow_page 最终的查找&#x2F;创建影子页表页</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Note, @vcpu may be NULL if @role.direct is true; see kvm_mmu_find_shadow_page. */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *__<span class=\"title\">kvm_mmu_get_shadow_page</span>(<span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"keyword\">struct</span> <span class=\"title\">kvm_vcpu</span> *<span class=\"title\">vcpu</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"keyword\">struct</span> <span class=\"title\">shadow_page_caches</span> *<span class=\"title\">caches</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"title\">gfn_t</span> <span class=\"title\">gfn</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"title\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_head</span> *<span class=\"title\">sp_list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> created = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp_list = &amp;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = kvm_mmu_find_shadow_page(kvm, vcpu, gfn, sp_list, role);<span class=\"comment\">//从哈希表中查找指定gfn和role的影子页表页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sp) &#123; <span class=\"comment\">// 没有找到，进行创建</span></span><br><span class=\"line\">\t\tcreated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tsp = kvm_mmu_alloc_shadow_page(kvm, caches, gfn, sp_list, role);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttrace_kvm_mmu_get_page(sp, created);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t\t遍历到最后一级页表，相应的表项不存在，就需要位GPA申请物理页面、填充页表项了</p>\n<p>set_pte寻找空闲的物理页，填充页表项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_set_spte</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_memory_slot *slot,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tu64 *sptep, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> pte_access, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">kvm_pfn_t</span> pfn, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span> =</span> sptep_to_sp(sptep);</span><br><span class=\"line\">\t<span class=\"type\">int</span> level = sp-&gt;role.level;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_shadow_present_pte(*sptep)) </span><br><span class=\"line\"></span><br><span class=\"line\">\t......</span><br><span class=\"line\"></span><br><span class=\"line\">\twrprot = make_spte(vcpu, sp, slot, pte_access, gfn, pfn, *sptep, prefetch,</span><br><span class=\"line\">\t\t\t   <span class=\"literal\">true</span>, host_writable, &amp;spte);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tmake_spte 生成新的页表项</p>\n<h2 id=\"建立好之后的寻址\"><a href=\"#建立好之后的寻址\" class=\"headerlink\" title=\"建立好之后的寻址\"></a>建立好之后的寻址</h2><p>​\t\t每次访问cr3都会触发异常</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_cr</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> exit_qualification, val;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cr;</span><br><span class=\"line\">\t<span class=\"type\">int</span> reg;</span><br><span class=\"line\">\t<span class=\"type\">int</span> err;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\texit_qualification = vmx_get_exit_qual(vcpu);  <span class=\"comment\">//读取字段</span></span><br><span class=\"line\">\tcr = exit_qualification &amp; <span class=\"number\">15</span>; <span class=\"comment\">//提取字段的 0-3位，判断访问的那个控制寄存器</span></span><br><span class=\"line\">\treg = (exit_qualification &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">15</span>;<span class=\"comment\">//提取8-11位，判断guest试图加载到cr3的页表地址存储在哪个寄存器</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> ((exit_qualification &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">3</span>) &#123;<span class=\"comment\">//提取4、5位 判断时写还是读控制寄存器 0表示写</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">/* mov to cr */</span></span><br><span class=\"line\">\t\tval = kvm_register_read(vcpu, reg);</span><br><span class=\"line\">\t\ttrace_kvm_cr_write(cr, val);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (cr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\terr = handle_set_cr0(vcpu, val);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_complete_insn_gp(vcpu, err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\terr = kvm_set_cr3(vcpu, val);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_complete_insn_gp(vcpu, err);</span><br><span class=\"line\">..........</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t不知道kvm_register_read读取的cr3是否存储着影子页表的地址，是的话逻辑就比较简单了，设置cr3为影子页表的地址，然后就拿到了地址映射，进行后续内存操作？？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_set_cr3</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> cr3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\">\tvcpu-&gt;arch.cr3 = cr3;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t</p>\n<h1 id=\"二、EPT\"><a href=\"#二、EPT\" class=\"headerlink\" title=\"二、EPT\"></a>二、EPT</h1><p>​\t\t简而言之：<strong>MMU完成GVA到GPA的映射（kvm不捕获异常了，guest自己处理），EPT完成GPA到HPA的映射</strong>. 引入了EPT violation异常处理EPT的缺页</p>\n<p>​\t\t具体而言：当Guest内部发生缺页异常时，CPU不再切换到Host模式了，而是由Guest自身的缺页异常处理函数处理。当地址从GVA翻译到GPA后，<strong>GPA在硬件内部从MMU流转到了EPT。</strong>如果EPT页表中存在GPA到HPA的映射，则EPA最终获取了GPA对应的HPA，将HPA送上地址总线。如果EPT中尚未建立GPA到HPA的映射，<strong>则CPU抛出EPT异常，CPU从Guest模式切换到Host模式</strong>，KVM中的EPT异常处理函数负责寻找空闲物理页面，建立EPT表中GPA到HPA的映射。</p>\n<p>​\t\tVMX在VMCS中定义了一个字段 Extended-Page-Table Pointer，KVM可以将EPT页表的位置写入这个字段，这样当CPU进入Guest模式时，就可以从这个字段读取EPT页表的位置。</p>\n<h2 id=\"EPT页表的设置\"><a href=\"#EPT页表的设置\" class=\"headerlink\" title=\"EPT页表的设置\"></a>EPT页表的设置</h2><p>vmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_load_mmu_pgd</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">hpa_t</span> root_hpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t     <span class=\"type\">int</span> root_level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> update_guest_cr3 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> guest_cr3;</span><br><span class=\"line\">\tu64 eptp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (enable_ept) &#123;</span><br><span class=\"line\">\t\teptp = construct_eptp(vcpu, root_hpa, root_level);</span><br><span class=\"line\">\t\tvmcs_write64(EPT_POINTER, eptp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thv_track_root_tdp(vcpu, root_hpa);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!enable_unrestricted_guest &amp;&amp; !is_paging(vcpu))</span><br><span class=\"line\">\t\t\tguest_cr3 = to_kvm_vmx(kvm)-&gt;ept_identity_map_addr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_register_is_dirty(vcpu, VCPU_EXREG_CR3))</span><br><span class=\"line\">\t\t\tguest_cr3 = vcpu-&gt;arch.cr3;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">/* vmcs.GUEST_CR3 is already up-to-date. */</span></span><br><span class=\"line\">\t\t\tupdate_guest_cr3 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tvmx_ept_load_pdptrs(vcpu);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tguest_cr3 = root_hpa | kvm_get_active_pcid(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (update_guest_cr3)</span><br><span class=\"line\">\t\tvmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t通过construct_eptp构建ept，然后vmcs_write64写入vmcs，这里是将root_hpa作为了EPT的根页面，第18行，设置变量guest_cr3指向guest自己的页表，最后27行，把cr3的值写入VMCS字段，这样切入guest后，guest模式下的CPU的cr3寄存器就指向了自己的页表。</p>\n<p>​\t\t</p>\n<h2 id=\"EPT页表的构建-x2F-缺页异常处理-（GPA-HPA）\"><a href=\"#EPT页表的构建-x2F-缺页异常处理-（GPA-HPA）\" class=\"headerlink\" title=\"EPT页表的构建 &#x2F; 缺页异常处理 （GPA-HPA）\"></a>EPT页表的构建 &#x2F; 缺页异常处理 （GPA-HPA）</h2><p>​\t\tCPU需要查询EPT表来进行GPA-HPA的转换，初始情况下，guest cr3指向的地址的页表项都是空的，CPU触发EPT violation ，虚拟机产生退出，并且退出原因为<strong>EXIT_REASON_EPT_VIOLATION</strong>，会调用<strong>handle_ept_violation</strong>处理函数</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20230917114957653.png\" alt=\"image-20230917114957653\" style=\"zoom: 50%;\">\n\n\n\n<p>​\t\tvmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> exit_qualification;</span><br><span class=\"line\">\t<span class=\"type\">gpa_t</span> gpa;</span><br><span class=\"line\">\tu64 error_code;</span><br><span class=\"line\"></span><br><span class=\"line\">\texit_qualification = vmx_get_exit_qual(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(to_vmx(vcpu)-&gt;idt_vectoring_info &amp; VECTORING_INFO_VALID_MASK) &amp;&amp;</span><br><span class=\"line\">\t\t\tenable_vnmi &amp;&amp;</span><br><span class=\"line\">\t\t\t(exit_qualification &amp; INTR_INFO_UNBLOCK_NMI))</span><br><span class=\"line\">\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);<span class=\"comment\">// vm exit前会将引发异常的GPA保存到VMCS的该字段，这里进行读取</span></span><br><span class=\"line\">.......</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t经过一系列检查和设置后进入kvm_mmu_page_fault处理函数，这里就检查了mmio这种错误，如果不是的话，会进入下一个处理函数kvm_mmu_do_page_fault</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> noinline <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = RET_PF_INVALID;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(error_code &amp; PFERR_RSVD_MASK)) &#123;</span><br><span class=\"line\">\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == RET_PF_EMULATE)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> emulate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_INVALID) &#123;</span><br><span class=\"line\">\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t  lower_32_bits(error_code), <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t\t  &amp;emulation_type);</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(kvm_mmu_page_fault);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_do_page_fault</p>\n<p>mmu_internal.h   这里会进入kvm_tdp_page_fault(上面的影子页表就进入else了)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_do_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\tu32 err, <span class=\"type\">bool</span> prefetch, <span class=\"type\">int</span> *emulation_type)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (IS_ENABLED(CONFIG_RETPOLINE) &amp;&amp; fault.is_tdp)</span><br><span class=\"line\">\t\tr = kvm_tdp_page_fault(vcpu, &amp;fault);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu-&gt;arch.mmu-&gt;page_fault(vcpu, &amp;fault);</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_tdp_page_fault, 目前还不是很了解tdp，但走这两条路都能到最后的地址映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_X86_64</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tdp_mmu_enabled)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_tdp_mmu_page_fault(vcpu, fault);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> direct_page_fault(vcpu, fault);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_tdp_mmu_page_fault中的kvm_faultin_pfn是GPA到HPA的重要函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_tdp_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">..</span><br><span class=\"line\">\tr = kvm_faultin_pfn(vcpu, fault, ACC_ALL);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tdirect_page_fault的最后会走到direct_map函数，direct_map是EPT页表构建过程中的关键函数, 建立映射，感觉一些主体逻辑和 FNAME(fetch)有点像</p>\n<h1 id=\"三、TLB缓存\"><a href=\"#三、TLB缓存\" class=\"headerlink\" title=\"三、TLB缓存\"></a>三、TLB缓存</h1><p>​\t\tEPT：CPU使用TLB（Translation Lookaside Buffer）缓存线性虚拟地址到物理地址的映射，地址转换时CPU先根据GPA先查找TLB，如果未找到映射的HPA，将根据页表中的映射填充TLB，再进行地址转换。</p>\n<p>​\t\t影子页表方案：不同Guest的vCPU切换执行时需要刷新TLB，严重影响了内存访问效率。因此，Intel引入了VPID（Virtual-Processor Identifier）技术在硬件上为TLB增加一个标志，每个TLB表项与一个VPID关联，唯一对应一个vCPU，当vCPU切换时可根据VPID找到并保留已有的TLB表项，减少TLB刷新。</p>\n<h2 id=\"VPID\"><a href=\"#VPID\" class=\"headerlink\" title=\"VPID\"></a>VPID</h2><p>​\t\tVPID是一种硬件级的对TLB资源管理的优化。通过在硬件上为每个TLB项增加一个标志，来标识不同的虚拟处理器地址空间，从而区分开VMM以及不同虚拟机的不同处理器的TLB。避免了每次切换都使得TLB全部失效。</p>\n<p>​\t\tVT-x 通过在VMCS中增加两个域来支持VPID，一个是VMCS中的enable VPID域，该域决定是否开启VPID功能。第二个是VPID域，用于标识VMCS对应的TLB。VMM本身也需要一个VPID，VT-x规定虚拟处理器标志0被指定用于VMM自身。</p>\n<p>capabilities.h中有一个关于内存两大特性的结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vmx_capability</span> &#123;</span></span><br><span class=\"line\">\tu32 ept;</span><br><span class=\"line\">\tu32 vpid;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t会在hardware_setup函数中设置相关特性是否开启</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">hardware_setup</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||</span><br><span class=\"line\">\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))</span><br><span class=\"line\">\t\tenable_vpid = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t剩下的事好像就没软件什么事了，归硬件去操作</p>\n<h1 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h1><p><a href=\"https://www.cnblogs.com/LoyenWang/p/13943005.html\">https://www.cnblogs.com/LoyenWang/p/13943005.html</a> 不过这个是arm的</p>\n<p><a href=\"https://mp.weixin.qq.com/s/fLSSbtPjx29Gg-IJfgnbZw\">https://mp.weixin.qq.com/s/fLSSbtPjx29Gg-IJfgnbZw</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/108425561\">https://zhuanlan.zhihu.com/p/108425561</a>  TLB原理</p>\n<p><a href=\"http://www.xiongfuli.com/%E8%99%9A%E6%8B%9F%E5%8C%96/2013-06/KVM-Implementation.html\">http://www.xiongfuli.com/%E8%99%9A%E6%8B%9F%E5%8C%96/2013-06/KVM-Implementation.html</a></p>\n<p><a href=\"https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvmzhi-nei-cun-xu-ni531628-kvm-mmu-virtualization.html\">https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvmzhi-nei-cun-xu-ni531628-kvm-mmu-virtualization.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1975756\">https://cloud.tencent.com/developer/article/1975756</a> </p>\n<p><a href=\"https://royhunter.github.io/2014/06/18/KVM-EPT/\">https://royhunter.github.io/2014/06/18/KVM-EPT/</a></p>\n",
            "tags": [
                "KVM"
            ]
        },
        {
            "id": "https://tangzichengcc.github.io/pwn%E5%85%A5%E9%97%A8-39-docker%E5%85%A5%E9%97%A8%E5%8F%8Apwn%E5%87%BA%E9%A2%98%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
            "url": "https://tangzichengcc.github.io/pwn%E5%85%A5%E9%97%A8-39-docker%E5%85%A5%E9%97%A8%E5%8F%8Apwn%E5%87%BA%E9%A2%98%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
            "title": "pwn入门-39-docker入门及pwn出题环境搭建",
            "date_published": "2023-09-16T05:30:16.000Z",
            "content_html": "<h1 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h1><p>入门参考资料:<a href=\"https://www.runoob.com/docker\">https://www.runoob.com/docker</a></p>\n<p><a href=\"https://yeasy.gitbook.io/docker_practice/\">https://yeasy.gitbook.io/docker_practice/</a></p>\n<h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><p>使用官方脚本安装docker</p>\n<p>curl -fsSL <a href=\"https://get.docker.com/\">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p>\n<p>手动安装(不如脚本稳定少出错)</p>\n<p>开启docker </p>\n<p>systemctl enable docker </p>\n<p>systemctl start docker</p>\n<p>测试是否安装成功: docker run –rm hello-world</p>\n<p>hello-world是测试容器, –rm表示退出容器后,自动删除容器</p>\n<h2 id=\"二、使用入门\"><a href=\"#二、使用入门\" class=\"headerlink\" title=\"二、使用入门\"></a>二、使用入门</h2><h3 id=\"1-镜像\"><a href=\"#1-镜像\" class=\"headerlink\" title=\"1.镜像\"></a>1.镜像</h3><ul>\n<li><p>docker images 查看本地镜像</p>\n</li>\n<li><p>docker pull xxxx 拉去镜像, 例如docker pull ubuntu:18.04</p>\n</li>\n</ul>\n<p>​\t\t不给镜像仓库地址的话, 会从 Docker Hub （<code>docker.io</code>）获取镜像, 而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code>命令的输出结果最后一行给出了镜像的完整名称，例如： <code>docker.io/library/ubuntu:18.04</code>。</p>\n<ul>\n<li><p>docker rmi xxxx  删除镜像</p>\n</li>\n<li><p>docker build -t xxxx .  用dockerfile构建镜像</p>\n</li>\n</ul>\n<h3 id=\"2-容器\"><a href=\"#2-容器\" class=\"headerlink\" title=\"2.容器\"></a>2.容器</h3><ul>\n<li><p>docker ps 查看容器 -a查看所有(包括停止的)</p>\n</li>\n<li><p>docker run -it ubuntu:18.04 bash</p>\n</li>\n</ul>\n<p>​\t-it: -i 交互式操作 -t 终端 </p>\n<p>​\tbash 命令,希望有交互式shell,所以用这个,或者&#x2F;bin&#x2F;sh之类的</p>\n<ul>\n<li>docker stop xxx  停止容器</li>\n</ul>\n<h1 id=\"CTF-pwn出题环境搭建\"><a href=\"#CTF-pwn出题环境搭建\" class=\"headerlink\" title=\"CTF-pwn出题环境搭建\"></a>CTF-pwn出题环境搭建</h1><p>​\t\tpwn出题主要用到了 <a href=\"https://github.com/Eadom/ctf_xinetd\">https://github.com/Eadom/ctf_xinetd</a></p>\n<p>环境搭建</p>\n<p><a href=\"https://blog.csdn.net/weixin_53757397/article/details/128489015\">https://blog.csdn.net/weixin_53757397/article/details/128489015</a></p>\n<p><a href=\"https://blog.csdn.net/mylyylmy/article/details/79917776\">https://blog.csdn.net/mylyylmy/article/details/79917776</a></p>\n<p><a href=\"https://nocbtm.github.io/2019/09/25/pwn%E9%A2%98%E7%9A%84%E6%90%AD%E5%BB%BA/\">https://nocbtm.github.io/2019/09/25/pwn题的搭建/</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_53757397/article/details/128489015\">https://blog.csdn.net/weixin_53757397/article/details/128489015</a> 感觉有点啰嗦,不一定需要上传docker仓库</p>\n<p><a href=\"https://blog.csdn.net/weixin_46521144/article/details/120572274\">https://blog.csdn.net/weixin_46521144/article/details/120572274</a> 排错</p>\n<h2 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h2><p>git clone <a href=\"https://github.com/Eadom/ctf_xinetd.git\">https://github.com/Eadom/ctf_xinetd.git</a></p>\n<ol>\n<li>将编译好的libc、flag、题目文件拷贝到bin目录下</li>\n</ol>\n<p>​\t\t如果需要特定的libc</p>\n<p>​\t\t提前patchelf好,把libc文件页拷贝到ctf_xinetd的bin目录下</p>\n<p>​\t\tpatchelf –set-interpreter .&#x2F;2.31-0ubuntu9_amd64&#x2F;ld-linux-x86-64.so.2 .&#x2F;timu<br>​\t\tpatchelf –set-rpath .&#x2F;2.31-0ubuntu9_amd64&#x2F; .&#x2F;timu</p>\n<p>​\t\t用绝对路径不知道为什么不行????</p>\n<ol start=\"2\">\n<li>创建docker-compose.yml文件,这里的3389改成题目要映射的端口(物理机的),9999是docker里面的端口,image名字要和后面创建的docker images名字一样</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &#x27;3&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">    pwn:</span><br><span class=\"line\">        build: ./</span><br><span class=\"line\">        image: pwn1 #这里修改的是images名,将和 docker build -t &quot;pwn1&quot; . 该命令有关</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">            - &quot;3389:9999&quot;</span><br><span class=\"line\">        pids_limit: 1024</span><br><span class=\"line\">        # cpus: 0.5</span><br><span class=\"line\">        restart: unless-stopped</span><br><span class=\"line\">        # privileged: true</span><br></pre></td></tr></table></figure>\n\n<p>Dockerfile</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:<span class=\"number\">22.04</span> 根据情况修改版本</span><br><span class=\"line\">  </span><br><span class=\"line\">RUN cp -R /lib* /home/ctf &amp;&amp;\\  版本高于<span class=\"number\">18.04</span>要删除这一句??为啥呢??</span><br><span class=\"line\">  \tcp -R /usr/lib* /home/ctf </span><br></pre></td></tr></table></figure>\n\n\n\n<p>ctf.xinetd</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service ctf</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    disable = no</span><br><span class=\"line\">    socket_type = stream</span><br><span class=\"line\">    protocol    = tcp</span><br><span class=\"line\">    wait        = no</span><br><span class=\"line\">    user        = root</span><br><span class=\"line\">    type        = UNLISTED</span><br><span class=\"line\">    port        = <span class=\"number\">9999</span></span><br><span class=\"line\">    bind        = <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">    server      = /usr/sbin/chroot</span><br><span class=\"line\">    <span class=\"meta\"># replace helloworld to your program</span></span><br><span class=\"line\">    server_args = --userspec=<span class=\"number\">1000</span>:<span class=\"number\">1000</span> /home/ctf ./timu   这里timu是题目bin文件名</span><br><span class=\"line\">    banner_fail = /etc/banner_fail</span><br><span class=\"line\">    <span class=\"meta\"># safety options</span></span><br><span class=\"line\">    per_source\t= <span class=\"number\">10</span> <span class=\"meta\"># the maximum instances of this service per source IP address</span></span><br><span class=\"line\">    rlimit_cpu\t= <span class=\"number\">20</span> <span class=\"meta\"># the maximum number of CPU seconds that the service may use</span></span><br><span class=\"line\">    #rlimit_as  = <span class=\"number\">1024</span>M <span class=\"meta\"># the Address Space resource limit for the service</span></span><br><span class=\"line\">    #access_times = <span class=\"number\">2</span>:<span class=\"number\">00</span><span class=\"number\">-9</span>:<span class=\"number\">00</span> <span class=\"number\">12</span>:<span class=\"number\">00</span><span class=\"number\">-24</span>:<span class=\"number\">00</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>制作镜像</li>\n</ol>\n<p>​\t\t建立容器,pwn1名字就是镜像的名字</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t <span class=\"string\">&quot;pwn1&quot;</span> .</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.创建运行容器</p>\n<p>​\t\tdocker run -d -p 0.0.0.0:3389:9999 pwn1 运行容器,这里就部署好了,可以进行打了,3389是暴露出来的端口</p>\n<p>​\t\tdocker exec -it 16a224caf905 &#x2F;bin&#x2F;bash  和容器进行交互,(这个是退出后再次进入,和run时候-it不一样)</p>\n<p>文件拷贝 <a href=\"https://blog.csdn.net/sunhuaqiang1/article/details/88354410\">https://blog.csdn.net/sunhuaqiang1/article/details/88354410</a></p>\n<p>docker cp &#x2F;root&#x2F;chuti&#x2F;uaf&#x2F;timu pwncp:&#x2F;home&#x2F;ctf&#x2F;timu</p>\n<p><a href=\"https://blog.csdn.net/yue7603835/article/details/122456650\">https://blog.csdn.net/yue7603835/article/details/122456650</a></p>\n",
            "tags": [
                "PWN入门",
                "docker"
            ]
        },
        {
            "id": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/",
            "url": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/",
            "title": "虚拟化入门-2-KVM源码分析之上下文切换的执行流-内核4.4版本",
            "date_published": "2023-08-03T12:44:52.000Z",
            "content_html": "<p>​\t\t这里应该有两部分,一部分是,host如何进入guest,进入的时候保存了什么,加载了什么,怎么进行的切换,第二部分是guest在运行的时候,什么情况下会进行退出,切换到host,这个时候又需要保存什么,恢复什么</p>\n<p>​\t\t关于指令的运行, 我理解的如果不是敏感指令,在CPU转为guest状态后,就在物理CPU上执行虚拟机的指令,此时像内存,页表,各种寄存器等也都切换成虚拟机的了,所以就相当于一台真正的机器在运行,不会受到什么影响,只是当遇到敏感指令时,就需要vmexit退出进行特殊处理了</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/image-20230730190236168.png\" alt=\"image-20230730190236168\" style=\"zoom: 67%;\">\n\n<h1 id=\"host进入guest-开始运行虚拟机指令\"><a href=\"#host进入guest-开始运行虚拟机指令\" class=\"headerlink\" title=\"host进入guest | 开始运行虚拟机指令\"></a>host进入guest | 开始运行虚拟机指令</h1><p>​\t\tQEMU中VCPU线程函数为qemu_kvm_cpu_thread_fn（cpus.c）,该函数内部有一个循环，执行虚拟机代码,先用cpu_can_run判断是否可以运行,可以的话,进入VCPU执行的核心函数kvm_cpu_exec</p>\n<h3 id=\"VCPU执行的核心函数-kvm-cpu-exec\"><a href=\"#VCPU执行的核心函数-kvm-cpu-exec\" class=\"headerlink\" title=\"VCPU执行的核心函数  kvm_cpu_exec\"></a>VCPU执行的核心函数  kvm_cpu_exec</h3><p>​\t\t核心是一个 do while循环，会用kvm_vcpu_ioctl(cpu,KVM_RUN,0)使CPU运行起来, 如果遇到VM Exit,需要qemu处理的话,会返回到这里,让QEMU进行处理.</p>\n<p>​\t\tioctl(KVM_RUN)是KVM进行处理的,它对应的处理函数是kvm_arch_vcpu_ioctl_run,该函数主要调用vcpu_run</p>\n<p>kvm&#x2F;x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_run *kvm_run)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\">\tr = vcpu_run(vcpu);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vcpu-run\"><a href=\"#vcpu-run\" class=\"headerlink\" title=\"vcpu_run\"></a>vcpu_run</h3><p>kvm&#x2F;x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">................</span><br><span class=\"line\">\t\tkvm_check_async_pf_completion(vcpu);</span><br><span class=\"line\">........</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\tvcpu_run的函数的主体结构也是一个循环，首先调用kvm_vcpu_running判断当前CPU是否可运行</p>\n<p>​\t\t如果判断是可运行的，<strong>则会调用vcpu_enter_guest来进入虚拟机</strong></p>\n<h3 id=\"vcpu-enter-guest\"><a href=\"#vcpu-enter-guest\" class=\"headerlink\" title=\"vcpu_enter_guest\"></a>vcpu_enter_guest</h3><p>kvm&#x2F;x86.c</p>\n<p>​\t\t在最开始会对vcpu-&gt;requests上的请求进行处理，这些请求可能来自多个地方，比如在处理VM Exit时，KVM在运行时需要修改虚拟机状态时等，这些请求都在即将进入guest的时候进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_int_win =</span><br><span class=\"line\">\t\tdm_request_for_irq_injection(vcpu) &amp;&amp;</span><br><span class=\"line\">\t\tkvm_cpu_accept_dm_intr(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_immediate_exit = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;requests) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))</span><br><span class=\"line\">\t\t\tkvm_mmu_unload(vcpu);</span><br><span class=\"line\">\t.............</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t接下来会处理虚拟终端相关请求，然后调用kvm_mmu_reload,与内存设置相关</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) &#123;</span><br><span class=\"line\">\t\tkvm_apic_accept_events(vcpu);</span><br><span class=\"line\">............</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = kvm_mmu_reload(vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t然后设置禁止抢占，之后调用回调函数prepare_guest_switch,<strong>vmx对应的函数是vmx_save_host_state</strong>, 从名称就可以推测,是准备要进入guest了,此时需要保存host的状态.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preempt_disable();</span><br><span class=\"line\"></span><br><span class=\"line\">kvm_x86_ops-&gt;prepare_guest_switch(vcpu);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"vmx-save-host-state-保存host的信息\"><a href=\"#vmx-save-host-state-保存host的信息\" class=\"headerlink\" title=\"vmx_save_host_state(保存host的信息)\"></a>vmx_save_host_state(保存host的信息)</h4><p>​\t\t能够看到这个函数里面有很多savesegment和vmcs_write的操作,用来保存host的状态信息。 </p>\n<h4 id=\"vmx-vcpu-run-进入guest模式\"><a href=\"#vmx-vcpu-run-进入guest模式\" class=\"headerlink\" title=\"vmx_vcpu_run(进入guest模式)\"></a>vmx_vcpu_run(进入guest模式)</h4><p>​\t\t紧接着的函数是vmx的run回调，对应的函数时vmx_vcpu_run</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kvm_x86_ops-&gt;run(vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t该函数首先根据VCPU的状态写一些VMCS的值，<strong>然后执行汇编ASM_VMX_VMLAUNCH将CPU置于guest模式，<font color=\"red\">这个时候CPU就开始执行虚拟机的代码</font></strong></p>\n<p>vmx.c\t\t\t</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;</span><br><span class=\"line\">\t<span class=\"keyword\">asm</span>(</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Store host registers */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;push %%&quot;</span> _ASM_DX <span class=\"string\">&quot;; push %%&quot;</span> _ASM_BP <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Enter guest mode */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jne 1f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t__ex(ASM_VMX_VMLAUNCH) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jmp 2f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1: &quot;</span> __ex(ASM_VMX_VMRESUME) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"guest进入host-回到宿主机进行处理\"><a href=\"#guest进入host-回到宿主机进行处理\" class=\"headerlink\" title=\"guest进入host | 回到宿主机进行处理\"></a>guest进入host | 回到宿主机进行处理</h1><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/image-20230802014945208.png\" alt=\"image-20230802014945208\" style=\"zoom:50%;\">\n\n<h3 id=\"VM-exit-退出\"><a href=\"#VM-exit-退出\" class=\"headerlink\" title=\"VM exit 退出\"></a>VM exit 退出</h3><p>​\t\t在kvm的vmx_vcpu_run函数里面执行了ASM_VMX_VMLAUNCH,将CPU置于guest模式,开始运行虚拟机的代码,<font color=\"red\">当后面遇到敏感指令的时候,CPU产生VMExit,此时KVM接管CPU,就会跳到下一行代码,jmp 2f,也就是跳到标号2的地方,看注释很明显,保存guest的寄存器,恢复host的,要进行切换( 不过目前也不完全是这样,</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;</span><br><span class=\"line\">\t<span class=\"keyword\">asm</span>(</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Store host registers */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;push %%&quot;</span> _ASM_DX <span class=\"string\">&quot;; push %%&quot;</span> _ASM_BP <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">\t......</span><br><span class=\"line\"><span class=\"comment\">/* Enter guest mode */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jne 1f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t__ex(ASM_VMX_VMLAUNCH) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jmp 2f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1: &quot;</span> __ex(ASM_VMX_VMRESUME) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;2: &quot;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Save guest registers, load host registers, keep flags */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mov %0, %c[wordsize](%%&quot;</span> _ASM_SP <span class=\"string\">&quot;) \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pop %0 \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;setbe %c[fail](%0)\\n\\t&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t调用vmcs_read32读取虚拟机退出的原因，保存在vcpu_vmx结构体的exit_reason成员中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;exit_reason = vmcs_read32(VM_EXIT_REASON);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    vmx_complete_atomic_exit(vmx);</span><br><span class=\"line\">\tvmx_recover_nmi_blocking(vmx);</span><br><span class=\"line\">\tvmx_complete_interrupts(vmx);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t最后调用3个函数对本次退出进行预处理</p>\n<h3 id=\"回到vcpu-enter-guest进行退出的详细处理\"><a href=\"#回到vcpu-enter-guest进行退出的详细处理\" class=\"headerlink\" title=\"回到vcpu_enter_guest进行退出的详细处理\"></a>回到vcpu_enter_guest进行退出的详细处理</h3><p>​\t\t当vmx_vcpu_run运行结束,回到vcpu_enter_guest函数,</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">\tkvm_x86_ops-&gt;run(vcpu); <span class=\"comment\">//vmx_vcpu_run</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">\t<span class=\"comment\">/* Interrupt is enabled by handle_external_intr() */</span></span><br><span class=\"line\">\tkvm_x86_ops-&gt;handle_external_intr(vcpu);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t虚拟机退出之后会调用vmx实现的handle_external_intr回调来处理外部中断，并调用handle_exit回调来处理各种退出事件</p>\n<h3 id=\"vmx-handle-external-intr\"><a href=\"#vmx-handle-external-intr\" class=\"headerlink\" title=\"vmx_handle_external_intr\"></a>vmx_handle_external_intr</h3><p>​\t\thandle_external_intr 对应vmx_handle_external_intr</p>\n<p>​\t\t读取中断信息，判断是否是有效的中断，如果是，读取中断号vector，然后得到宿主机中对应IDT的中断门描述符，最后一段汇编用来执行处理函数，vmx_handle_external_intr会开启中断</p>\n<p>​\t\t<strong>也就是说，CPU在guest模式运行时，中断是关闭的，运行着虚拟机代码的CPU不会接收到外部中断，但是外部中断会导致CPU退出guest模式，进入VMX root模式</strong></p>\n<p>vmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_handle_external_intr</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If external interrupt exists, IF bit is set in rflags/eflags on the</span></span><br><span class=\"line\"><span class=\"comment\">\t * interrupt stack frame, and interrupt will be enabled on a return</span></span><br><span class=\"line\"><span class=\"comment\">\t * from interrupt handler.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((exit_intr_info &amp; (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))</span><br><span class=\"line\">\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"built_in\">vector</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> entry;</span><br><span class=\"line\">\t\tgate_desc *desc;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_X86_64</span></span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> tmp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span> =  exit_intr_info &amp; INTR_INFO_VECTOR_MASK;</span><br><span class=\"line\">\t\tdesc = (gate_desc *)vmx-&gt;host_idt_base + <span class=\"built_in\">vector</span>;</span><br><span class=\"line\">\t\tentry = gate_offset(*desc);</span><br><span class=\"line\">\t\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">#ifdef CONFIG_X86_64</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;mov %%&quot;</span> _ASM_SP <span class=\"string\">&quot;, %[sp]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;and $0xfffffffffffffff0, %%&quot;</span> _ASM_SP <span class=\"string\">&quot;\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;push $%c[ss]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;push %[sp]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">#endif</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;pushf\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;orl $0x200, (%%&quot;</span> _ASM_SP <span class=\"string\">&quot;)\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t__ASM_SIZE(push) <span class=\"string\">&quot; $%c[cs]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\tCALL_NOSPEC</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t:</span></span><br><span class=\"line\"><span class=\"params\">#ifdef CONFIG_X86_64</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[sp]<span class=\"string\">&quot;=&amp;r&quot;</span>(tmp)</span></span><br><span class=\"line\"><span class=\"params\">#endif</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t:</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tTHUNK_TARGET(entry),</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[ss]<span class=\"string\">&quot;i&quot;</span>(__KERNEL_DS),</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[cs]<span class=\"string\">&quot;i&quot;</span>(__KERNEL_CS)</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t)</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tlocal_irq_enable();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t如果不是呢？？？？调用local_irq_enable();</p>\n<p>​\t\t</p>\n<h3 id=\"vm-handle-exit\"><a href=\"#vm-handle-exit\" class=\"headerlink\" title=\"vm_handle_exit\"></a>vm_handle_exit</h3><p>​\t\t执行完vmx_handle_external_intr后继续执行vcpu_enter_guest(x86.c)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">\tkvm_x86_ops-&gt;run(vcpu); <span class=\"comment\">//vmx_vcpu_run</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">\t<span class=\"comment\">/* Interrupt is enabled by handle_external_intr() */</span></span><br><span class=\"line\">\tkvm_x86_ops-&gt;handle_external_intr(vcpu);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t从上面可知，外部中断的处理时在handle_exit之前进行的，所以在后面handle_exit中处理外部中断的时候就没什么太多要做的了。</p>\n<p>​\t\thandle_exit 对应 vmx_handle_exit 函数，它是退出事件总的分发处理函数，<strong>在对一些特殊情况进行判断之后根据突出原因调用了kvm_vmx_exit_handlers中定义的相应的分发函数</strong></p>\n<p>​\tvmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\">\tu32 exit_reason = vmx-&gt;exit_reason;</span><br><span class=\"line\">\tu32 vectoring_info = vmx-&gt;idt_vectoring_info;</span><br><span class=\"line\">...................</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tWARN_ONCE(<span class=\"number\">1</span>, <span class=\"string\">&quot;vmx: unexpected exit reason 0x%x\\n&quot;</span>, exit_reason);</span><br><span class=\"line\">\t\tkvm_queue_exception(vcpu, UD_VECTOR);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t可以看到一个关键的地方, 传入退出的原因，然后进行选择处理函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_vmx_exit_handlers中的EXIT_REASON_XXXX宏定义了退出的原因，对应的handle_xxx则定义了相应的处理函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"title function_\">int</span> <span class=\"params\">(*<span class=\"type\">const</span> kvm_vmx_exit_handlers[])</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span> = &#123;</span><br><span class=\"line\">\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,</span><br><span class=\"line\">\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,</span><br><span class=\"line\">\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,</span><br><span class=\"line\">\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">\t[EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">\t[EXIT_REASON_DR_ACCESS]               = handle_dr,</span><br><span class=\"line\">\t[EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">\t[EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">\t[EXIT_REASON_INVD]\t\t      = handle_invd,</span><br><span class=\"line\">\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,</span><br><span class=\"line\">\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">\t[EXIT_REASON_VMCALL]                  = handle_vmcall,</span><br><span class=\"line\">\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,</span><br><span class=\"line\">\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">\t[EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">\t[EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">\t[EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">\t[EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\">\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,</span><br><span class=\"line\">\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,</span><br><span class=\"line\">\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,</span><br><span class=\"line\">\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,</span><br><span class=\"line\">\t[EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">\t[EXIT_REASON_INVVPID]                 = handle_invvpid,</span><br><span class=\"line\">\t[EXIT_REASON_XSAVES]                  = handle_xsaves,</span><br><span class=\"line\">\t[EXIT_REASON_XRSTORS]                 = handle_xrstors,</span><br><span class=\"line\">\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,</span><br><span class=\"line\">\t[EXIT_REASON_PCOMMIT]                 = handle_pcommit,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t对应的处理函数怎么找呢？？？ 在哪里呢？ 搜了一下，搜的几个都还是在这个vmx.c文件里</p>\n<p>​\t\t有的退出事件KVM能够自己处理，这个时候就直接处理然后返回，准备下一轮的VCPU运行，如果KVM无法处理，则需要将事件分发到QEMU进行处理</p>\n<h3 id=\"自己处理的例子：-handle-cpuid\"><a href=\"#自己处理的例子：-handle-cpuid\" class=\"headerlink\" title=\"自己处理的例子： handle_cpuid\"></a>自己处理的例子： handle_cpuid</h3><p>​\t\t看代码,它的原理是查询之前QEMU的设置,然后直接返回,只需要通过KVM就可以完成. <strong>返回1,这个值也作为vcpu_enter_guest的返回值, 为1表示不需要让虚拟机回到QEMU</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_cpuid</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tkvm_emulate_cpuid(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要返回QEMU处理的例子-handle-io\"><a href=\"#需要返回QEMU处理的例子-handle-io\" class=\"headerlink\" title=\"需要返回QEMU处理的例子  handle_io\"></a>需要返回QEMU处理的例子  handle_io</h3><p>​\t\t对该函数进行一路追踪,能看到最后返回了0,所以需要返回QEMU进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_io</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_fast_pio_out(vcpu, size, port);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t返回退出的代码如下, r&#x3D;&#x3D;0的话会进入break,导致该函数退出 for循环,进而使得ioctl返回用户态</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t也就是返回到了kvm_arch_vcpu_ioctl_run,再进行返回,就到了QEMU里面了.</p>\n<p>​\t\t在QEMU里面处理完之后再次通过host进入guest的流程,</p>\n",
            "tags": [
                "KVM"
            ]
        },
        {
            "id": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/",
            "url": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/",
            "title": "虚拟化入门-1-CPU虚拟化",
            "date_published": "2023-08-03T12:43:32.000Z",
            "content_html": "<p>​\t\t研究组的方向是虚拟化…研一一直在学pwn(都还没入门..惭愧). 刚回所里,有师兄带一下,学一下虚拟化, 接触了一点感觉还不错,挺有意思的, 主要是 操作系统层面的东西. 或许后面可以作为主要方向来做.</p>\n<p>​\t\t下面的内容都是来自《系统虚拟化：原理与实现》,作为虚拟化的概念入门还是不错的感觉</p>\n<p>​\t\t主要是了解了虚拟化基础的概念之后,学习intel的 VT虚拟化技术</p>\n<h1 id=\"第三章-虚拟化概述\"><a href=\"#第三章-虚拟化概述\" class=\"headerlink\" title=\"第三章 虚拟化概述\"></a>第三章 虚拟化概述</h1><p>虚拟机的三个典型特征：同质、高效、资源受控。</p>\n<p>​\t\t大多数计算机体系结构都有两个及以上的特权级，用来分隔系统软件和应用软件。系统中有一些操作和管理关键系统资源的指令被定位特权指令，只有在最高特权级上能够正确执行。如果在非最高特权级上运行，特权指令会引发一个异常，处理器会陷入最高特权级，交由系统软件来处理。</p>\n<p>​\t\t在虚拟化世界中，有一类指令成为敏感指令，简而言之是操作特权资源的指令。<strong>所有的特权指令都是敏感指令，但不是所有的敏感指令都是特权指令。</strong></p>\n<p>​\t\t判断一个结构是否可以虚拟化，核心在于对敏感指令的支持，如果在某些结构上所有敏感指令都是特权指令，则它是可虚拟化的结构，否则，如果它无法支持在所有的敏感指令上触发异常，则不是一个可虚拟化的机构，称其存在<strong>“虚拟化漏洞”</strong></p>\n<p>​\t\t通过陷入再模拟指令的执行来实现虚拟机的方法是前提条件的：所有的敏感指令都必须是特权指令。如果不满足的话就会有遗漏，<strong>此时需要想办法来填补或者避免这些遗漏。</strong></p>\n<h2 id=\"3-2-处理器虚拟化\"><a href=\"#3-2-处理器虚拟化\" class=\"headerlink\" title=\"3.2 处理器虚拟化\"></a>3.2 处理器虚拟化</h2><p>​\t\t<font color=\"red\">处理器虚拟化是VMM中最核心的部分</font>，因为访问内存或者I&#x2F;O的指令本身就是敏感指令，所以内存虚拟化与I&#x2F;O虚拟化都依赖于处理器虚拟化的正确实现。</p>\n<h3 id=\"指令的模拟\"><a href=\"#指令的模拟\" class=\"headerlink\" title=\"指令的模拟\"></a>指令的模拟</h3><p>​\t\t因为特权级的存在，敏感指令需要陷入到VMM中通过软件的方式进行模拟。</p>\n<p>​\t\t<strong>三个概念：虚拟寄存器、上下文和虚拟处理器</strong></p>\n<p>​\t\t当客户机操作系统试图访问关键资源的时候，该请求并不会真正发生在物理寄存器上。相反，VMM会通过准确模拟物理处理器的行为，而将其访问定位到VMM为其设计与物理寄存器对应的“虚拟”的寄存器上。（对VMM来说，这样的虚拟寄存器往往是在内存中。）</p>\n<p>​\t\t一个案例，不论是对CR0的修改还是访问，都会经过处理器抛出异常，由VMM操作对应的虚拟CR0。</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721165154567.png\" alt=\"image-20230721165154567\"></p>\n<p>​\t\t在没有虚拟化的环境中，os直接负责物理处理器管理，负责进程间的调度和切换。在VMM接管物理处理器后，客户机操作系统没有管理物理处理器的权利，可以说此时它已经运行在VMM为之设计的虚拟处理器之上，<strong>客户机管理虚拟处理器</strong>，并在虚拟处理器上负责该虚拟机内进程间调度和切换。</p>\n<p>​\t\t<strong>而VMM管理物理处理器，负责虚拟处理器的调度和切换，以保证在给定时间内，每个虚拟处理器上的当前进程可以在物理处理器上运行一段时间。</strong><font color=\"red\">但是，不管是何种调度，必然要涉及到保留现场，这个现场就是上下文状态。</font></p>\n<p>​\t\t相比进程等上下文，虚拟处理器上下文会更加复杂，因为客户机操作系统本身包含许多敏感指令，会试图访问和修改物理处理器上定义的所有寄存器，但这种访问会和修改会被VMM重定位到虚拟处理器上。所以，对于虚拟处理器，其上下文包括了更多的系统寄存器.当VMM在决定切换虚拟处理器的时候，为了让虚拟机看起来好像从未被中断过一样，VMM需要考虑保存和回复的上下文也更加复杂。</p>\n<p>​\t\t从VMM的角度来说，<strong>虚拟处理器是其需要模拟完成的一组功能集合</strong>，<strong>虚拟处理器的功能可以由物理处理器和VMM共同完成。</strong>对于非敏感指令，物理处理器直接解码处理其请求，并将相关的效果直接反应到物理寄存器上，而对于敏感指令，VMM负责陷入再模拟，从程序角度来说就是一组数据结构和相关处理代码的集合。数据结构用于存储虚拟寄存器的内容，<font color=\"red\">而相关处理代码负责按照物理处理器的行为将效果反映到虚拟寄存器上。</font></p>\n<p>​\t\t上面的概念可以说明，在处理器虚拟化中，不论是定义虚拟寄存器和虚拟处理器还是利用上下文进行虚拟处理器调度切换，其宗旨都是让虚拟机里执行的敏感指令陷入下来以后，能被VMM模拟，而不要直接作用于真实硬件上。</p>\n<p>​\t\t模拟的前提是陷入，需要了解怎么进行陷入，需要陷入的时候，是怎么通知VMM的。概括地说，VMM陷入是利用了处理器的保护机制，利用中断和异常来完成，有以下几种方式：</p>\n<ul>\n<li>1.基于处理器保护机制触发的异常，例如敏感指令的执行。</li>\n<li>2.虚拟机主动触发异常，即通常所说的陷阱</li>\n<li>异步中断，包括处理器内部的中断源和外部的设备中断源</li>\n</ul>\n<h2 id=\"VMM的功能和组成\"><a href=\"#VMM的功能和组成\" class=\"headerlink\" title=\"VMM的功能和组成\"></a>VMM的功能和组成</h2><p>​\t\tVMM的主要功能事基于物理资源创建相应的虚拟资源，组成虚拟机，为客户机操作系统提供虚拟的平台。所以，可以推测，VMM基本上可以分为两部分：虚拟环境的管理和物理资源的管理。</p>\n<h3 id=\"虚拟环境的管理\"><a href=\"#虚拟环境的管理\" class=\"headerlink\" title=\"虚拟环境的管理\"></a>虚拟环境的管理</h3><h3 id=\"物理资源的管理\"><a href=\"#物理资源的管理\" class=\"headerlink\" title=\"物理资源的管理\"></a>物理资源的管理</h3><h3 id=\"其他模块\"><a href=\"#其他模块\" class=\"headerlink\" title=\"其他模块\"></a>其他模块</h3><h2 id=\"VMM分类\"><a href=\"#VMM分类\" class=\"headerlink\" title=\"VMM分类\"></a>VMM分类</h2><h3 id=\"按虚拟平台分类\"><a href=\"#按虚拟平台分类\" class=\"headerlink\" title=\"按虚拟平台分类\"></a>按虚拟平台分类</h3><h4 id=\"完全虚拟化\"><a href=\"#完全虚拟化\" class=\"headerlink\" title=\"完全虚拟化\"></a>完全虚拟化</h4><p>​\t\t虚拟出来的平台和现实平台是一样的，客户机操作系统不用做任何修改就可以运行。重点是VMM要能够正确处理所有可能的指令。</p>\n<p>​\t\t在实现方式上，以x86为例，经历了两个阶段：软件辅助的完全虚拟化和硬件辅助的完全虚拟化</p>\n<h5 id=\"软件辅助的完全虚拟化\"><a href=\"#软件辅助的完全虚拟化\" class=\"headerlink\" title=\"软件辅助的完全虚拟化\"></a>软件辅助的完全虚拟化</h5><p>​\t\t早期因为一开始肯定没想要要弄这个，所以硬件上也不会专门适配，所以完全虚拟化需要通过软件来实现。一个典型的做法是优先级压缩和二进制代码翻译相结合。</p>\n<p>​\t\t优先级压缩来处理的话，有部分指令不能触发异常，因此不能截获做处理。而二进制代码翻译就是为了解决这部分指令，它的思想是，通过扫描并修改客户机的二进制代码，将这些指令转换成支持虚拟化的指令。</p>\n<p>​\t\t虽然这种方式能够实现完全虚拟化，但是这种类似于打补丁的方式很难在架构上保证其完整性，于是后期，x86厂商就在硬件上加入了对虚拟化的支持。</p>\n<h5 id=\"硬件辅助的完全虚拟化\"><a href=\"#硬件辅助的完全虚拟化\" class=\"headerlink\" title=\"硬件辅助的完全虚拟化\"></a>硬件辅助的完全虚拟化</h5><p>​\t\t很符合计算机的抽象层次的逻辑，当这一层事情比较难解决的时候，就给它再抽象出一层来。Intel的VT-x技术是这一方向的代表，它在处理器上引入了一个新的执行模式用于运行虚拟机。当虚拟机运行在这个特殊模式中时，任何特权操作都会被处理器拦截并报告给VMM。</p>\n<p>​\t\t</p>\n<h4 id=\"类虚拟化\"><a href=\"#类虚拟化\" class=\"headerlink\" title=\"类虚拟化\"></a>类虚拟化</h4><p>​\t\t在源代码级别（操作系统内核的代码）修改指令以回避虚拟化漏洞的方式来使VMM能够对物理资源实现虚拟化。</p>\n<h3 id=\"按VMM实现结构分类\"><a href=\"#按VMM实现结构分类\" class=\"headerlink\" title=\"按VMM实现结构分类\"></a>按VMM实现结构分类</h3><p>Hypervisor模型、宿主模型、混合模型</p>\n<h1 id=\"第五章-硬件辅助虚拟化\"><a href=\"#第五章-硬件辅助虚拟化\" class=\"headerlink\" title=\"第五章 硬件辅助虚拟化\"></a>第五章 硬件辅助虚拟化</h1><p>​\t\t硬件辅助虚拟化，即<strong>在CPU、芯片组及I&#x2F;O设备等硬件中加入专门针对虚拟化的支持</strong>，使得系统软件可以更加容易、高效地实现虚拟化功能。本章以intel VT为例。</p>\n<p>​\t\tintel vt分别在CPU、内存、IO虚拟化方面提供了不同的技术，分别对应VT-x、EPT、VT-d。</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230720210602697.png\" alt=\"image-20230720210602697\"></p>\n<h2 id=\"CPU虚拟化的硬件支持\"><a href=\"#CPU虚拟化的硬件支持\" class=\"headerlink\" title=\"CPU虚拟化的硬件支持\"></a>CPU虚拟化的硬件支持</h2><p>​\t\t引入了两种操作模式，统称为VMX模式，<strong>每种模式都有0~3的特权级</strong>。</p>\n<ul>\n<li>根操作模式（VMX Root Operation）：VMM运行所处的模式</li>\n<li>非根操作模式（VMX Non-Root Operation）：客户机运行所处的模式</li>\n</ul>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230720211200688.png\" alt=\"image-20230720211200688\"></p>\n<p>​\t\t非根模式下所有敏感指令的行为都会被重新定义，使得他们能不经过虚拟化就能直接运行或者通过“陷入再模拟”的方式来处理，在根模式下，所有指令的行为和传统IA32一样，因此所有软件都能够正常运行。</p>\n<p>​\t\t非根模式下敏感指令引起的“陷入”被称为VM-Exit。这会导致CPU自动从非根模式切换到根模式。相应的，VM-Entry，该操作由VMM发起，通常是调度某个客户机运行，此时CPU从根模式切换到非根模式。</p>\n<p>​\t\t为了更好地支持CPU虚拟化，VT-x引入了<strong>VMCS（virtual-Machine Control Structure 。虚拟机控制结构）</strong>，VMCS保存虚拟CPU需要的相关状态，例如CPU在两种模式下的特权寄存器的值。VMCS主要供CPU使用，<strong>CPU在发生VM-Exit和VM-Entry时都会自动查询和更新VMCS</strong>。VMM可以通过指令来配置VMCS，进而影响CPU的行为。</p>\n<p>​\t\tVT-x还引入了一组新的指令，包括VMLAUCH&#x2F;VMRESUME用于发起VM-Entry，VMREAD&#x2F;VMWRITE用于配置VMCS等</p>\n<p>这里有点没看懂。。。</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230729191616281.png\" alt=\"image-20230729191616281\"></p>\n<h3 id=\"VMCS\"><a href=\"#VMCS\" class=\"headerlink\" title=\"VMCS\"></a>VMCS</h3><p>​\t\t与虚拟寄存器的概念类似，可以看作是虚拟寄存器概念在硬件上的应用。<strong>VMCS是保存在内存中的数据结构，包含了虚拟CPU的相关寄存器的内容和虚拟CPU相关的控制信息，每个VMCS对应一个虚拟CPU。</strong>（换句话说，个人理解的是，物理CPU和虚拟CPU之间的一个媒介，用于保存和恢复切换时的上下文</p>\n<p>​\t\tVMCS在使用时需要和物理CPU绑定。VMCS与物理CPU是一对一绑定的关系。但在不同时刻可以绑定到不同的物理CPU。这种绑定关系的变化称为VMCS的迁移。</p>\n<p>​\t\tVT-x提供了两条指令用于VMCS的绑定与解除绑定</p>\n<ul>\n<li><p>VMPRTLD&lt;VMCS地址&gt;： 将指定的VMCS与执行该指令的物理CPU绑定</p>\n</li>\n<li><p>VMCLEAR：将执行该指令的物理CPU与它的VMCS解除绑定。该指令会<strong>将物理CPU缓存中的VMCS结构同步到内存中去</strong>，从而保证VMCS与新的物理CPU绑定时，内存中的值是最新的。</p>\n</li>\n</ul>\n<p>​\t\tVMCS格式如下：</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230729192240761.png\" alt=\"image-20230729192240761\"></p>\n<p>​\t\t主要信息放在数据域里面，VT-x提供两条指令用于访问VMCS</p>\n<ul>\n<li><p>VMREAD&lt;索引&gt;： 读VMCS中索引指定的域</p>\n</li>\n<li><p>VMWRITE&lt;索引&gt;&lt;数据&gt;：写VMCS中索引指定的域</p>\n<p>VMCS数据域包括六大类信息</p>\n<p>客户机状态域</p>\n<p>宿主机状态域</p>\n<p>VM-Entry控制域</p>\n<p>VM-Execution控制域</p>\n<p>VM-Exit控制域</p>\n<p>VM-Exit信息域</p>\n</li>\n</ul>\n<h3 id=\"VMX操作模式\"><a href=\"#VMX操作模式\" class=\"headerlink\" title=\"VMX操作模式\"></a>VMX操作模式</h3><p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230729192709720.png\" alt=\"image-20230729192709720\"></p>\n<h3 id=\"VM-Entry\"><a href=\"#VM-Entry\" class=\"headerlink\" title=\"VM-Entry\"></a>VM-Entry</h3><p>​\t\t在发起之前，VMM会设置好VMCS相关域的内容，例如客户机状态域、宿主机状态域等，然后执行VM-Entry指令。</p>\n<p>​\t\tVT-x为VM-Entry提供了两条指令</p>\n<ul>\n<li><p>VMLAUNCH: 用于刚执行过VMCLEAER的VMCS的第一次VM-Entry</p>\n</li>\n<li><p>VMRESUME：用于执行过VMLAUNCH的VMCS的后续VM-Entry</p>\n<p>在VM-Entry进入时，会有很多不同的特性和选择，或者说具体行为，由VM-Entry控制域来规定</p>\n</li>\n</ul>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230729193126650.png\" alt=\"image-20230729193126650\"></p>\n<p>​\t\t注入的事件最终是用客户机自己的IDT里面指定的处理函数来处理的，这样在客户机虚拟CPU看来，这些事件就和没有虚拟化的环境里面对应的事件没有任何区别</p>\n<h4 id=\"VM-Entry的过程\"><a href=\"#VM-Entry的过程\" class=\"headerlink\" title=\"VM-Entry的过程\"></a>VM-Entry的过程</h4><ul>\n<li>执行基本的检查来确保VM-Entry能开始</li>\n<li>对VMCS中的宿主机状态域的有效性进行检查，以确保下一次VM-Exit时可以正确地从客户机环境切换到VMM环境</li>\n<li>检查VMCS中客户机状态域的有效性，根据客户机状态域来装载处理器的状态</li>\n<li>根据VMCS中VM-Entry MSR-load区域装载MSR寄存器</li>\n<li>根据VMCS中VM-Entry事件注入控制的配置，可能需要注入事件到客户机</li>\n</ul>\n<p>​\t\t如果1-4步的检查没有全部通过，CPU会报告VM-Entry失败，这通常意味着VMCS中某些字段的设置有错误。如果全部通过了，处理器就会把执行环境从VMM切换到客户机环境，开始执行客户机指令。</p>\n<h3 id=\"VM-Exit\"><a href=\"#VM-Exit\" class=\"headerlink\" title=\"VM-Exit\"></a>VM-Exit</h3><p>​\t\t指CPU从非根模式切换到根模式，客户机切换到VMM的操作。因为的原因有很多，例如在非根模式下执行了敏感指令、发生了中断等。<strong>处理VM-Exit事件是VMM模拟指令、虚拟特权资源的一大任务。</strong></p>\n<h4 id=\"具体过程\"><a href=\"#具体过程\" class=\"headerlink\" title=\"具体过程\"></a>具体过程</h4><ul>\n<li>CPU首先将此次VM-Exit的原因信息记录到VMCS相应的信息域中，VM-Entry interruption-information字段的有效位（bit31）被清零。</li>\n<li>CPU状态被保存到VMCS客户机状态域。根据设置也可能将客户机的MSR保存到VM-Exit MSR-store区域</li>\n<li>根据VMCS中宿主机状态域和VM-Exit控制域中的设计，将宿主机状态加载到CPU相应寄存器。CPU也可能根据VM-Exit MSR-store区域来加载VMM的MSR。</li>\n</ul>\n<h2 id=\"CPU虚拟化的实现\"><a href=\"#CPU虚拟化的实现\" class=\"headerlink\" title=\"CPU虚拟化的实现\"></a>CPU虚拟化的实现</h2><p>硬件虚拟化用VCPU描述符来描述虚拟CPU，类似os中的进程描述符，其本质是一个结构体，</p>\n<p>结构如下：</p>\n<p>​\t\t当VMM创建客户机时，首先要为客户机创建VCPU，<strong>整个客户机的运行实际上可以看作是VMM调度不同的VCPU运行。</strong></p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721101848575.png\" alt=\"image-20230721101848575\"></p>\n<p>VMCS的创建与初始化</p>\n<h3 id=\"VCPU的运行\"><a href=\"#VCPU的运行\" class=\"headerlink\" title=\"VCPU的运行\"></a>VCPU的运行</h3><h4 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h4><p>​\t\tVCPU的上下文分为两部分，所以切换也分为由硬件自动切换（VMCS部分）和VMM软件切换（非VMCS部分）</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721103646397.png\" alt=\"image-20230721103646397\"></p>\n<p>​\t\t具体切换步骤：</p>\n<p>1.VMM保存自己的上下文，主要是保存VMCS不保存的寄存器，即宿主机状态域以外的部分</p>\n<p>2.VMM将保存在VCPU中的由软件切换的上下文加载到物理CPU中</p>\n<p>3.VMM执行VMRESUME&#x2F;VMLAUNCH指令，触发VM-Entry，此时CPU自动将VCPU上下文中VMCS部分加载到物理CPU，CPU切换到非根模式。</p>\n<p>​\t\t惰性保存&#x2F;恢复： 这个方法是对上下文切换进行的优化，因为上下文切换带来的开销比较大。它的思想是</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721104434314.png\" alt=\"image-20230721104434314\"></p>\n<h4 id=\"VCPU的硬件优化\"><a href=\"#VCPU的硬件优化\" class=\"headerlink\" title=\"VCPU的硬件优化\"></a>VCPU的硬件优化</h4><p>​\t\t优化的目的是尽可能少地在客户机和VMM之间切换，从而减少上下文切换的开销。Intel VT-x提供两种优化方法。</p>\n<h3 id=\"VCPU的退出\"><a href=\"#VCPU的退出\" class=\"headerlink\" title=\"VCPU的退出\"></a>VCPU的退出</h3><p>​\t\t推出的原因可能是执行了特权指令、发生了物理中断等，在VT-x中表现为发生VM-Exit。<strong>对VCPU退出的处理是VMM进行CPU虚拟化的核心，例如模拟各种特权指令。</strong></p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721111530744.png\" alt=\"image-20230721111530744\"></p>\n<p>​\t\t退出的原因大体上有三类：</p>\n<p>1.访问了特权资源，对CR和MSR寄存器的访问都属于这一类</p>\n<p><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-1-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/image-20230721111811167.png\" alt=\"image-20230721111811167\"></p>\n<p>2.客户机执行的指令引发了异常，例如缺页错误</p>\n<p>3.发生了中断。</p>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a></h3>",
            "tags": []
        }
    ]
}