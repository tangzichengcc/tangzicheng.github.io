{
    "version": "https://jsonfeed.org/version/1",
    "title": "唐仔橙 • All posts by \"kvm\" tag",
    "description": "喜欢探索世界,在读研究生,计算机爱好者的成长记录",
    "home_page_url": "https://tangzichengcc.github.io",
    "items": [
        {
            "id": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "url": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "title": "虚拟化入门-3-内存虚拟化代码分析",
            "date_published": "2023-09-19T10:19:06.000Z",
            "content_html": "<h1 id=\"一、保护模式Guest的寻址\"><a href=\"#一、保护模式Guest的寻址\" class=\"headerlink\" title=\"一、保护模式Guest的寻址\"></a>一、保护模式Guest的寻址</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>​\t\t为每个guest进程分别制作一张表，记录着GVA到HPA的映射关系。guest模式下的cr3寄存器不再指向内部GVA到GPA映射的表，<strong>而是指向这张新的表。</strong>当MMU收到GVA时，通过遍历这张新的表，将GVA翻译成HPA。</p>\n<p>​\t\t\t因为guest自身页表不能完成GVA到HPA的多层地址映射，<strong>因此每当guest设置cr3寄存器时，KVM都需要截获这个操作，将cr3替换为影子页表</strong>，因此每次设置cr3时都需要触发虚拟机退出，陷入KVM模块。（无疑会造成很大的资源消耗，有EPT之后就不用了）</p>\n<p>​\t\t两个关键点：</p>\n<ol>\n<li>KVM需要构建GVA映射到HPA的页表，<strong>这个页表需要根据guest内部页表的信息更新</strong>，实际地址映射时生效的是这张页表，会将guest内部的页表给隐藏起来，所以它叫影子页表</li>\n<li>保护模式的guest有自己的页表，而且不只有一个页表，<strong>每个任务都会有自己的页表，随着任务的切换而更换页表</strong>，所以，KVM也需要准备多个影子页表，每个guest任务对应一个。 <strong>并且在guest内部任务切换时，kvm需要捕获这个切换，切换对应的影子页表。</strong></li>\n</ol>\n<p>​\t\t建立映射时，需要经过三次转换：</p>\n<ul>\n<li>第一次是guest使用自身的页表完成GVA到GPA的转换</li>\n<li>第二次是KVM根据内存条信息完成GPA到HVA的转换</li>\n<li>第三次是host利用内核的内存管理机制完成HVA到HPA的转换</li>\n</ul>\n<p>​\t\t影子页表构建好后，在映射建立完成后，GVA到HPA经过一次映射即可。</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20230917150408144.png\" alt=\"image-20230917150408144\" style=\"zoom: 80%;\">\n\n<h2 id=\"影子页表的建立-x2F-缺页异常处理\"><a href=\"#影子页表的建立-x2F-缺页异常处理\" class=\"headerlink\" title=\"影子页表的建立 &#x2F; 缺页异常处理\"></a>影子页表的建立 &#x2F; 缺页异常处理</h2><p>​\t\t保护模式guest发生缺页异常时，控制cr2寄存器中存储的是GVA，而只有guest知道GVA到GPA的映射，所以，缺页异常处理函数首先<strong>需要遍历guest的页表，取出对应的GPA。</strong></p>\n<p>​\t\t如果没有建立GVA到GPA的映射，则KVM向guest注入<strong>缺页异常</strong>，guest进行正常的缺页异常处理，完成GVA到GPA的映射。建立好GVA到GPA的映射后，然后再继续建立GVA到HPA的映射。</p>\n<p>​\t\t刚开始时，影子页表是空的，所以开始时任何内存访问操作都会引起缺页异常，导致vm exit 进入handle_exception_nmi (不可屏蔽中断异常处理)</p>\n<p>​\t\thandle_exception_nmi从这里进入异常处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_exception_nmi</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_run</span> *<span class=\"title\">kvm_run</span> =</span> vcpu-&gt;run;</span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_page_fault(intr_info)) &#123;</span><br><span class=\"line\">\t\tcr2 = vmx_get_exit_qual(vcpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (enable_ept &amp;&amp; !vcpu-&gt;arch.apf.host_apf_flags) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * EPT will cause page fault only if we need to</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * detect illegal GPAs.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tWARN_ON_ONCE(!allow_smaller_maxphyaddr);</span><br><span class=\"line\">\t\t\tkvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_handle_page_fault(vcpu, error_code, cr2, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t调用链如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- kvm_handle_page_fault</span><br><span class=\"line\">    - kvm_mmu_page_fault</span><br><span class=\"line\">    \t- kvm_mmu_do_page_fault</span><br><span class=\"line\">    \t\t- </span><br></pre></td></tr></table></figure>\n\n<p>​\t\t到了这里之后, 如果没开启ept，会进入else，<font color=\"red\">猜测这里的page_fault是FNAME(page_fault)，这样就连起来了</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_do_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\tu32 err, <span class=\"type\">bool</span> prefetch, <span class=\"type\">int</span> *emulation_type)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_ENABLED(CONFIG_RETPOLINE) &amp;&amp; fault.is_tdp)</span><br><span class=\"line\">\t\tr = kvm_tdp_page_fault(vcpu, &amp;fault);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu-&gt;arch.mmu-&gt;page_fault(vcpu, &amp;fault);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GVA-GPA-映射\"><a href=\"#GVA-GPA-映射\" class=\"headerlink\" title=\"GVA-GPA 映射\"></a>GVA-GPA 映射</h3><p>kvm\\mmu\\paging_tmpl.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(page_fault)</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">guest_walker</span> <span class=\"title\">walker</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpgprintk(<span class=\"string\">&quot;%s: addr %lx err %x\\n&quot;</span>, __func__, fault-&gt;addr, fault-&gt;error_code);</span><br><span class=\"line\">\tWARN_ON_ONCE(fault-&gt;is_tdp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Look up the guest pte for the faulting address.</span></span><br><span class=\"line\"><span class=\"comment\">\t * If PFEC.RSVD is set, this is a shadow page fault.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The bit needs to be cleared before walking guest page tables.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tr = FNAME(walk_addr)(&amp;walker, vcpu, fault-&gt;addr,</span><br><span class=\"line\">\t\t\t     fault-&gt;error_code &amp; ~PFERR_RSVD_MASK);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * The page is not mapped by the guest.  Let the guest handle it.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!r) &#123;</span><br><span class=\"line\">\t\tpgprintk(<span class=\"string\">&quot;%s: guest page fault\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!fault-&gt;prefetch)</span><br><span class=\"line\">\t\t\tkvm_inject_emulated_page_fault(vcpu, &amp;walker.fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault-&gt;gfn = walker.gfn;</span><br><span class=\"line\">\tfault-&gt;max_level = walker.level;</span><br><span class=\"line\">\tfault-&gt;slot = kvm_vcpu_gfn_to_memslot(vcpu, fault-&gt;gfn);<span class=\"comment\">//获取内存条信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (page_fault_handle_page_track(vcpu, fault)) &#123;</span><br><span class=\"line\">\t\tshadow_page_table_clear_flood(vcpu, fault-&gt;addr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_EMULATE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = mmu_topup_memory_caches(vcpu, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = kvm_faultin_pfn(vcpu, fault, walker.pte_access);<span class=\"comment\">//关键函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r != RET_PF_CONTINUE)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t在硬件MMU中，Table walk单元负责遍历页表，这里函数walk_addr就相当于硬件MMu中Table walk，负责遍历guest页表。 <strong>异常处理函数首先调用这个函数遍历guess页表，尝试取出GPA</strong>，见14行代码，遍历完后，把具体信息保存在walker中。</p>\n<p>​\t\t感觉写的注释非常精髓</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch a guest pte for a guest virtual address, or for an L2&#x27;s GPA.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(walk_addr_generic)</span><span class=\"params\">(<span class=\"keyword\">struct</span> guest_walker *walker,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_mmu *mmu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"type\">gpa_t</span> addr, u64 access)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t\t如果返回0，说明没有建立映射，进行guest的缺页处理，注入异常，guest去建立GVA到GPA的映射。见20行。</p>\n<p>​\t\t进入到kvm_inject_emulated_page_fault</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">kvm_inject_emulated_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"keyword\">struct</span> x86_exception *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu</span> *<span class=\"title\">fault_mmu</span>;</span></span><br><span class=\"line\">\tWARN_ON_ONCE(fault-&gt;<span class=\"built_in\">vector</span> != PF_VECTOR);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault_mmu = fault-&gt;nested_page_fault ? vcpu-&gt;arch.mmu :</span><br><span class=\"line\">\t\t\t\t\t       vcpu-&gt;arch.walk_mmu;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invalidate the TLB entry for the faulting address, if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">\t * else the access will fault indefinitely (and to emulate hardware).</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((fault-&gt;error_code &amp; PFERR_PRESENT_MASK) &amp;&amp;</span><br><span class=\"line\">\t    !(fault-&gt;error_code &amp; PFERR_RSVD_MASK))</span><br><span class=\"line\">\t\tkvm_mmu_invalidate_addr(vcpu, fault_mmu, fault-&gt;address,</span><br><span class=\"line\">\t\t\t\t\tKVM_MMU_ROOT_CURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault_mmu-&gt;inject_page_fault(vcpu, fault);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t会调用 inject_page_fault, 对应的函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">kvm_inject_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> x86_exception *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t++vcpu-&gt;stat.pf_guest;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Async #PF in L2 is always forwarded to L1 as a VM-Exit regardless of</span></span><br><span class=\"line\"><span class=\"comment\">\t * whether or not L1 wants to intercept &quot;regular&quot; #PF.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_guest_mode(vcpu) &amp;&amp; fault-&gt;async_page_fault)</span><br><span class=\"line\">\t\tkvm_queue_exception_vmexit(vcpu, PF_VECTOR,</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"literal\">true</span>, fault-&gt;error_code,</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"literal\">true</span>, fault-&gt;address);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault-&gt;error_code,</span><br><span class=\"line\">\t\t\t\t\tfault-&gt;address);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GPA-HPA-映射\"><a href=\"#GPA-HPA-映射\" class=\"headerlink\" title=\"GPA-HPA 映射\"></a>GPA-HPA 映射</h3><p>​\t\t建立映射后往后走，来到下一个重要函数</p>\n<p>​\t\t<strong>kvm_faultin_pfn这个函数用来处理虚拟地址映射到宿主机的物理地址</strong></p>\n<p>mmu.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_faultin_pfn</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfault-&gt;mmu_seq = vcpu-&gt;kvm-&gt;mmu_invalidate_seq;</span><br><span class=\"line\">\tsmp_rmb();</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = __kvm_faultin_pfn(vcpu, fault);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret != RET_PF_CONTINUE)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(is_error_pfn(fault-&gt;pfn)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_handle_error_pfn(vcpu, fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(!fault-&gt;slot))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_handle_noslot_fault(vcpu, fault, access);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RET_PF_CONTINUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t这其中主要调用__kvm_faultin_pfn完成实际映射工作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __kvm_faultin_pfn(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span> =</span> fault-&gt;slot;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> async;</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">\tasync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tfault-&gt;pfn = __gfn_to_pfn_memslot(slot, fault-&gt;gfn, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, &amp;async,</span><br><span class=\"line\">\t\t\t\t\t  fault-&gt;write, &amp;fault-&gt;map_writable,</span><br><span class=\"line\">\t\t\t\t\t  &amp;fault-&gt;hva);</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t而这里，最关键的是__gfn_to_pfn_memslot，通过这个函数拿到pfn</p>\n<h3 id=\"影子页表填充\"><a href=\"#影子页表填充\" class=\"headerlink\" title=\"影子页表填充\"></a>影子页表填充</h3><p>​\t\t映射和填充是两回事? </p>\n<p>for_each_shadow_entry用来迭代不同页表级别</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">FNAME</span><span class=\"params\">(fetch)</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"keyword\">struct</span> guest_walker *gw)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    \tfor_each_shadow_entry(vcpu, fault-&gt;addr, it) &#123; <span class=\"comment\">//应该是用来查找对应级别的页表目录</span></span><br><span class=\"line\">\t\t<span class=\"type\">gfn_t</span> table_gfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tclear_sp_write_flooding_count(it.sptep);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (it.level == gw-&gt;level)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttable_gfn = gw-&gt;table_gfn[it.level - <span class=\"number\">2</span>]; <span class=\"comment\">//获取当前页表级别的表项对应的页表页的GFN</span></span><br><span class=\"line\">\t\taccess = gw-&gt;pt_access[it.level - <span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tsp = kvm_mmu_get_child_sp(vcpu, it.sptep, table_gfn,</span><br><span class=\"line\">\t\t\t\t\t  <span class=\"literal\">false</span>, access); <span class=\"comment\">//尝试获取或创建当前页表级别的影子页表页，false表示不创建新的，仅尝试获取已存在的</span></span><br><span class=\"line\"><span class=\"comment\">//it.sptep 表示当前的SPTE</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp != ERR_PTR(-EEXIST)) &#123; <span class=\"comment\">// 成功获取或创建</span></span><br><span class=\"line\">\t\t.............</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * Verify that the gpte in the page we&#x27;ve just write</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * protected is still there.</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (FNAME(gpte_changed)(vcpu, gw, it.level - <span class=\"number\">1</span>))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out_gpte_changed;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp != ERR_PTR(-EEXIST))</span><br><span class=\"line\">\t\t\tlink_shadow_page(vcpu, it.sptep, sp);<span class=\"comment\">//将影子页表与SPTE进行链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fault-&gt;write &amp;&amp; table_gfn == fault-&gt;gfn)</span><br><span class=\"line\">\t\t\tfault-&gt;write_fault_to_shadow_pgtable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">           .....</span><br><span class=\"line\">        ret = mmu_set_spte(vcpu, fault-&gt;slot, it.sptep, gw-&gt;pte_access,</span><br><span class=\"line\">\t\t\t   base_gfn, fault-&gt;pfn, fault); <span class=\"comment\">//设置/更新PTE</span></span><br><span class=\"line\">          .....</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_get_child_sp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_child_sp</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t u64 *sptep, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t <span class=\"type\">bool</span> direct, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_shadow_present_pte(*sptep) &amp;&amp; !is_large_pte(*sptep))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERR_PTR(-EEXIST); <span class=\"comment\">// 检查是否存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trole = kvm_mmu_child_role(sptep, direct, access); <span class=\"comment\">//新的页表的属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_mmu_get_shadow_page(vcpu, gfn, role);<span class=\"comment\">//查找/创建新的影子页表页</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_get_shadow_page来创建&#x2F;查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_shadow_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"keyword\">union</span> kvm_mmu_page_role role)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shadow_page_caches</span> <span class=\"title\">caches</span> =</span> &#123;</span><br><span class=\"line\">\t\t.page_header_cache = &amp;vcpu-&gt;arch.mmu_page_header_cache,</span><br><span class=\"line\">\t\t.shadow_page_cache = &amp;vcpu-&gt;arch.mmu_shadow_page_cache,</span><br><span class=\"line\">\t\t.shadowed_info_cache = &amp;vcpu-&gt;arch.mmu_shadowed_info_cache,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> __kvm_mmu_get_shadow_page(vcpu-&gt;kvm, vcpu, &amp;caches, gfn, role);<span class=\"comment\">//gfn表示需要映射的guest页的地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t__kvm_mmu_get_shadow_page 最终的查找&#x2F;创建影子页表页</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Note, @vcpu may be NULL if @role.direct is true; see kvm_mmu_find_shadow_page. */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *__<span class=\"title\">kvm_mmu_get_shadow_page</span>(<span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"keyword\">struct</span> <span class=\"title\">kvm_vcpu</span> *<span class=\"title\">vcpu</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"keyword\">struct</span> <span class=\"title\">shadow_page_caches</span> *<span class=\"title\">caches</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"title\">gfn_t</span> <span class=\"title\">gfn</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t      <span class=\"title\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_head</span> *<span class=\"title\">sp_list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> created = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp_list = &amp;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = kvm_mmu_find_shadow_page(kvm, vcpu, gfn, sp_list, role);<span class=\"comment\">//从哈希表中查找指定gfn和role的影子页表页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sp) &#123; <span class=\"comment\">// 没有找到，进行创建</span></span><br><span class=\"line\">\t\tcreated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tsp = kvm_mmu_alloc_shadow_page(kvm, caches, gfn, sp_list, role);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttrace_kvm_mmu_get_page(sp, created);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t\t遍历到最后一级页表，相应的表项不存在，就需要位GPA申请物理页面、填充页表项了</p>\n<p>set_pte寻找空闲的物理页，填充页表项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_set_spte</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_memory_slot *slot,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tu64 *sptep, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> pte_access, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">kvm_pfn_t</span> pfn, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span> =</span> sptep_to_sp(sptep);</span><br><span class=\"line\">\t<span class=\"type\">int</span> level = sp-&gt;role.level;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_shadow_present_pte(*sptep)) </span><br><span class=\"line\"></span><br><span class=\"line\">\t......</span><br><span class=\"line\"></span><br><span class=\"line\">\twrprot = make_spte(vcpu, sp, slot, pte_access, gfn, pfn, *sptep, prefetch,</span><br><span class=\"line\">\t\t\t   <span class=\"literal\">true</span>, host_writable, &amp;spte);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tmake_spte 生成新的页表项</p>\n<h2 id=\"建立好之后的寻址\"><a href=\"#建立好之后的寻址\" class=\"headerlink\" title=\"建立好之后的寻址\"></a>建立好之后的寻址</h2><p>​\t\t每次访问cr3都会触发异常</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_cr</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> exit_qualification, val;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cr;</span><br><span class=\"line\">\t<span class=\"type\">int</span> reg;</span><br><span class=\"line\">\t<span class=\"type\">int</span> err;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\texit_qualification = vmx_get_exit_qual(vcpu);  <span class=\"comment\">//读取字段</span></span><br><span class=\"line\">\tcr = exit_qualification &amp; <span class=\"number\">15</span>; <span class=\"comment\">//提取字段的 0-3位，判断访问的那个控制寄存器</span></span><br><span class=\"line\">\treg = (exit_qualification &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">15</span>;<span class=\"comment\">//提取8-11位，判断guest试图加载到cr3的页表地址存储在哪个寄存器</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> ((exit_qualification &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">3</span>) &#123;<span class=\"comment\">//提取4、5位 判断时写还是读控制寄存器 0表示写</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">/* mov to cr */</span></span><br><span class=\"line\">\t\tval = kvm_register_read(vcpu, reg);</span><br><span class=\"line\">\t\ttrace_kvm_cr_write(cr, val);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (cr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\terr = handle_set_cr0(vcpu, val);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_complete_insn_gp(vcpu, err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\terr = kvm_set_cr3(vcpu, val);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> kvm_complete_insn_gp(vcpu, err);</span><br><span class=\"line\">..........</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t不知道kvm_register_read读取的cr3是否存储着影子页表的地址，是的话逻辑就比较简单了，设置cr3为影子页表的地址，然后就拿到了地址映射，进行后续内存操作？？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_set_cr3</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> cr3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\">\tvcpu-&gt;arch.cr3 = cr3;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t</p>\n<h1 id=\"二、EPT\"><a href=\"#二、EPT\" class=\"headerlink\" title=\"二、EPT\"></a>二、EPT</h1><p>​\t\t简而言之：<strong>MMU完成GVA到GPA的映射（kvm不捕获异常了，guest自己处理），EPT完成GPA到HPA的映射</strong>. 引入了EPT violation异常处理EPT的缺页</p>\n<p>​\t\t具体而言：当Guest内部发生缺页异常时，CPU不再切换到Host模式了，而是由Guest自身的缺页异常处理函数处理。当地址从GVA翻译到GPA后，<strong>GPA在硬件内部从MMU流转到了EPT。</strong>如果EPT页表中存在GPA到HPA的映射，则EPA最终获取了GPA对应的HPA，将HPA送上地址总线。如果EPT中尚未建立GPA到HPA的映射，<strong>则CPU抛出EPT异常，CPU从Guest模式切换到Host模式</strong>，KVM中的EPT异常处理函数负责寻找空闲物理页面，建立EPT表中GPA到HPA的映射。</p>\n<p>​\t\tVMX在VMCS中定义了一个字段 Extended-Page-Table Pointer，KVM可以将EPT页表的位置写入这个字段，这样当CPU进入Guest模式时，就可以从这个字段读取EPT页表的位置。</p>\n<h2 id=\"EPT页表的设置\"><a href=\"#EPT页表的设置\" class=\"headerlink\" title=\"EPT页表的设置\"></a>EPT页表的设置</h2><p>vmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_load_mmu_pgd</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">hpa_t</span> root_hpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t     <span class=\"type\">int</span> root_level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> update_guest_cr3 = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> guest_cr3;</span><br><span class=\"line\">\tu64 eptp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (enable_ept) &#123;</span><br><span class=\"line\">\t\teptp = construct_eptp(vcpu, root_hpa, root_level);</span><br><span class=\"line\">\t\tvmcs_write64(EPT_POINTER, eptp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thv_track_root_tdp(vcpu, root_hpa);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!enable_unrestricted_guest &amp;&amp; !is_paging(vcpu))</span><br><span class=\"line\">\t\t\tguest_cr3 = to_kvm_vmx(kvm)-&gt;ept_identity_map_addr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_register_is_dirty(vcpu, VCPU_EXREG_CR3))</span><br><span class=\"line\">\t\t\tguest_cr3 = vcpu-&gt;arch.cr3;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">/* vmcs.GUEST_CR3 is already up-to-date. */</span></span><br><span class=\"line\">\t\t\tupdate_guest_cr3 = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tvmx_ept_load_pdptrs(vcpu);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tguest_cr3 = root_hpa | kvm_get_active_pcid(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (update_guest_cr3)</span><br><span class=\"line\">\t\tvmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t通过construct_eptp构建ept，然后vmcs_write64写入vmcs，这里是将root_hpa作为了EPT的根页面，第18行，设置变量guest_cr3指向guest自己的页表，最后27行，把cr3的值写入VMCS字段，这样切入guest后，guest模式下的CPU的cr3寄存器就指向了自己的页表。</p>\n<p>​\t\t</p>\n<h2 id=\"EPT页表的构建-x2F-缺页异常处理-（GPA-HPA）\"><a href=\"#EPT页表的构建-x2F-缺页异常处理-（GPA-HPA）\" class=\"headerlink\" title=\"EPT页表的构建 &#x2F; 缺页异常处理 （GPA-HPA）\"></a>EPT页表的构建 &#x2F; 缺页异常处理 （GPA-HPA）</h2><p>​\t\tCPU需要查询EPT表来进行GPA-HPA的转换，初始情况下，guest cr3指向的地址的页表项都是空的，CPU触发EPT violation ，虚拟机产生退出，并且退出原因为<strong>EXIT_REASON_EPT_VIOLATION</strong>，会调用<strong>handle_ept_violation</strong>处理函数</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-3-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20230917114957653.png\" alt=\"image-20230917114957653\" style=\"zoom: 50%;\">\n\n\n\n<p>​\t\tvmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> exit_qualification;</span><br><span class=\"line\">\t<span class=\"type\">gpa_t</span> gpa;</span><br><span class=\"line\">\tu64 error_code;</span><br><span class=\"line\"></span><br><span class=\"line\">\texit_qualification = vmx_get_exit_qual(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!(to_vmx(vcpu)-&gt;idt_vectoring_info &amp; VECTORING_INFO_VALID_MASK) &amp;&amp;</span><br><span class=\"line\">\t\t\tenable_vnmi &amp;&amp;</span><br><span class=\"line\">\t\t\t(exit_qualification &amp; INTR_INFO_UNBLOCK_NMI))</span><br><span class=\"line\">\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);<span class=\"comment\">// vm exit前会将引发异常的GPA保存到VMCS的该字段，这里进行读取</span></span><br><span class=\"line\">.......</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t经过一系列检查和设置后进入kvm_mmu_page_fault处理函数，这里就检查了mmio这种错误，如果不是的话，会进入下一个处理函数kvm_mmu_do_page_fault</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> noinline <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = RET_PF_INVALID;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(error_code &amp; PFERR_RSVD_MASK)) &#123;</span><br><span class=\"line\">\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == RET_PF_EMULATE)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> emulate;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_INVALID) &#123;</span><br><span class=\"line\">\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t  lower_32_bits(error_code), <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t\t  &amp;emulation_type);</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(kvm_mmu_page_fault);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_mmu_do_page_fault</p>\n<p>mmu_internal.h   这里会进入kvm_tdp_page_fault(上面的影子页表就进入else了)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_do_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\tu32 err, <span class=\"type\">bool</span> prefetch, <span class=\"type\">int</span> *emulation_type)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (IS_ENABLED(CONFIG_RETPOLINE) &amp;&amp; fault.is_tdp)</span><br><span class=\"line\">\t\tr = kvm_tdp_page_fault(vcpu, &amp;fault);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu-&gt;arch.mmu-&gt;page_fault(vcpu, &amp;fault);</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_tdp_page_fault, 目前还不是很了解tdp，但走这两条路都能到最后的地址映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_X86_64</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tdp_mmu_enabled)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_tdp_mmu_page_fault(vcpu, fault);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> direct_page_fault(vcpu, fault);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_tdp_mmu_page_fault中的kvm_faultin_pfn是GPA到HPA的重要函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">kvm_tdp_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">..</span><br><span class=\"line\">\tr = kvm_faultin_pfn(vcpu, fault, ACC_ALL);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tdirect_page_fault的最后会走到direct_map函数，direct_map是EPT页表构建过程中的关键函数, 建立映射，感觉一些主体逻辑和 FNAME(fetch)有点像</p>\n<h1 id=\"三、TLB缓存\"><a href=\"#三、TLB缓存\" class=\"headerlink\" title=\"三、TLB缓存\"></a>三、TLB缓存</h1><p>​\t\tEPT：CPU使用TLB（Translation Lookaside Buffer）缓存线性虚拟地址到物理地址的映射，地址转换时CPU先根据GPA先查找TLB，如果未找到映射的HPA，将根据页表中的映射填充TLB，再进行地址转换。</p>\n<p>​\t\t影子页表方案：不同Guest的vCPU切换执行时需要刷新TLB，严重影响了内存访问效率。因此，Intel引入了VPID（Virtual-Processor Identifier）技术在硬件上为TLB增加一个标志，每个TLB表项与一个VPID关联，唯一对应一个vCPU，当vCPU切换时可根据VPID找到并保留已有的TLB表项，减少TLB刷新。</p>\n<h2 id=\"VPID\"><a href=\"#VPID\" class=\"headerlink\" title=\"VPID\"></a>VPID</h2><p>​\t\tVPID是一种硬件级的对TLB资源管理的优化。通过在硬件上为每个TLB项增加一个标志，来标识不同的虚拟处理器地址空间，从而区分开VMM以及不同虚拟机的不同处理器的TLB。避免了每次切换都使得TLB全部失效。</p>\n<p>​\t\tVT-x 通过在VMCS中增加两个域来支持VPID，一个是VMCS中的enable VPID域，该域决定是否开启VPID功能。第二个是VPID域，用于标识VMCS对应的TLB。VMM本身也需要一个VPID，VT-x规定虚拟处理器标志0被指定用于VMM自身。</p>\n<p>capabilities.h中有一个关于内存两大特性的结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vmx_capability</span> &#123;</span></span><br><span class=\"line\">\tu32 ept;</span><br><span class=\"line\">\tu32 vpid;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t会在hardware_setup函数中设置相关特性是否开启</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">hardware_setup</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||</span><br><span class=\"line\">\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))</span><br><span class=\"line\">\t\tenable_vpid = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t剩下的事好像就没软件什么事了，归硬件去操作</p>\n<h1 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h1><p><a href=\"https://www.cnblogs.com/LoyenWang/p/13943005.html\">https://www.cnblogs.com/LoyenWang/p/13943005.html</a> 不过这个是arm的</p>\n<p><a href=\"https://mp.weixin.qq.com/s/fLSSbtPjx29Gg-IJfgnbZw\">https://mp.weixin.qq.com/s/fLSSbtPjx29Gg-IJfgnbZw</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/108425561\">https://zhuanlan.zhihu.com/p/108425561</a>  TLB原理</p>\n<p><a href=\"http://www.xiongfuli.com/%E8%99%9A%E6%8B%9F%E5%8C%96/2013-06/KVM-Implementation.html\">http://www.xiongfuli.com/%E8%99%9A%E6%8B%9F%E5%8C%96/2013-06/KVM-Implementation.html</a></p>\n<p><a href=\"https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvmzhi-nei-cun-xu-ni531628-kvm-mmu-virtualization.html\">https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvmzhi-nei-cun-xu-ni531628-kvm-mmu-virtualization.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1975756\">https://cloud.tencent.com/developer/article/1975756</a> </p>\n<p><a href=\"https://royhunter.github.io/2014/06/18/KVM-EPT/\">https://royhunter.github.io/2014/06/18/KVM-EPT/</a></p>\n",
            "tags": [
                "KVM"
            ]
        },
        {
            "id": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/",
            "url": "https://tangzichengcc.github.io/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/",
            "title": "虚拟化入门-2-KVM源码分析之上下文切换的执行流-内核4.4版本",
            "date_published": "2023-08-03T12:44:52.000Z",
            "content_html": "<p>​\t\t这里应该有两部分,一部分是,host如何进入guest,进入的时候保存了什么,加载了什么,怎么进行的切换,第二部分是guest在运行的时候,什么情况下会进行退出,切换到host,这个时候又需要保存什么,恢复什么</p>\n<p>​\t\t关于指令的运行, 我理解的如果不是敏感指令,在CPU转为guest状态后,就在物理CPU上执行虚拟机的指令,此时像内存,页表,各种寄存器等也都切换成虚拟机的了,所以就相当于一台真正的机器在运行,不会受到什么影响,只是当遇到敏感指令时,就需要vmexit退出进行特殊处理了</p>\n<img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/image-20230730190236168.png\" alt=\"image-20230730190236168\" style=\"zoom: 67%;\">\n\n<h1 id=\"host进入guest-开始运行虚拟机指令\"><a href=\"#host进入guest-开始运行虚拟机指令\" class=\"headerlink\" title=\"host进入guest | 开始运行虚拟机指令\"></a>host进入guest | 开始运行虚拟机指令</h1><p>​\t\tQEMU中VCPU线程函数为qemu_kvm_cpu_thread_fn（cpus.c）,该函数内部有一个循环，执行虚拟机代码,先用cpu_can_run判断是否可以运行,可以的话,进入VCPU执行的核心函数kvm_cpu_exec</p>\n<h3 id=\"VCPU执行的核心函数-kvm-cpu-exec\"><a href=\"#VCPU执行的核心函数-kvm-cpu-exec\" class=\"headerlink\" title=\"VCPU执行的核心函数  kvm_cpu_exec\"></a>VCPU执行的核心函数  kvm_cpu_exec</h3><p>​\t\t核心是一个 do while循环，会用kvm_vcpu_ioctl(cpu,KVM_RUN,0)使CPU运行起来, 如果遇到VM Exit,需要qemu处理的话,会返回到这里,让QEMU进行处理.</p>\n<p>​\t\tioctl(KVM_RUN)是KVM进行处理的,它对应的处理函数是kvm_arch_vcpu_ioctl_run,该函数主要调用vcpu_run</p>\n<p>kvm&#x2F;x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_run *kvm_run)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\">\tr = vcpu_run(vcpu);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vcpu-run\"><a href=\"#vcpu-run\" class=\"headerlink\" title=\"vcpu_run\"></a>vcpu_run</h3><p>kvm&#x2F;x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">................</span><br><span class=\"line\">\t\tkvm_check_async_pf_completion(vcpu);</span><br><span class=\"line\">........</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\tvcpu_run的函数的主体结构也是一个循环，首先调用kvm_vcpu_running判断当前CPU是否可运行</p>\n<p>​\t\t如果判断是可运行的，<strong>则会调用vcpu_enter_guest来进入虚拟机</strong></p>\n<h3 id=\"vcpu-enter-guest\"><a href=\"#vcpu-enter-guest\" class=\"headerlink\" title=\"vcpu_enter_guest\"></a>vcpu_enter_guest</h3><p>kvm&#x2F;x86.c</p>\n<p>​\t\t在最开始会对vcpu-&gt;requests上的请求进行处理，这些请求可能来自多个地方，比如在处理VM Exit时，KVM在运行时需要修改虚拟机状态时等，这些请求都在即将进入guest的时候进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_int_win =</span><br><span class=\"line\">\t\tdm_request_for_irq_injection(vcpu) &amp;&amp;</span><br><span class=\"line\">\t\tkvm_cpu_accept_dm_intr(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> req_immediate_exit = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;requests) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))</span><br><span class=\"line\">\t\t\tkvm_mmu_unload(vcpu);</span><br><span class=\"line\">\t.............</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t接下来会处理虚拟终端相关请求，然后调用kvm_mmu_reload,与内存设置相关</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) &#123;</span><br><span class=\"line\">\t\tkvm_apic_accept_events(vcpu);</span><br><span class=\"line\">............</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = kvm_mmu_reload(vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t然后设置禁止抢占，之后调用回调函数prepare_guest_switch,<strong>vmx对应的函数是vmx_save_host_state</strong>, 从名称就可以推测,是准备要进入guest了,此时需要保存host的状态.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preempt_disable();</span><br><span class=\"line\"></span><br><span class=\"line\">kvm_x86_ops-&gt;prepare_guest_switch(vcpu);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"vmx-save-host-state-保存host的信息\"><a href=\"#vmx-save-host-state-保存host的信息\" class=\"headerlink\" title=\"vmx_save_host_state(保存host的信息)\"></a>vmx_save_host_state(保存host的信息)</h4><p>​\t\t能够看到这个函数里面有很多savesegment和vmcs_write的操作,用来保存host的状态信息。 </p>\n<h4 id=\"vmx-vcpu-run-进入guest模式\"><a href=\"#vmx-vcpu-run-进入guest模式\" class=\"headerlink\" title=\"vmx_vcpu_run(进入guest模式)\"></a>vmx_vcpu_run(进入guest模式)</h4><p>​\t\t紧接着的函数是vmx的run回调，对应的函数时vmx_vcpu_run</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kvm_x86_ops-&gt;run(vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t该函数首先根据VCPU的状态写一些VMCS的值，<strong>然后执行汇编ASM_VMX_VMLAUNCH将CPU置于guest模式，<font color=\"red\">这个时候CPU就开始执行虚拟机的代码</font></strong></p>\n<p>vmx.c\t\t\t</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;</span><br><span class=\"line\">\t<span class=\"keyword\">asm</span>(</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Store host registers */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;push %%&quot;</span> _ASM_DX <span class=\"string\">&quot;; push %%&quot;</span> _ASM_BP <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Enter guest mode */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jne 1f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t__ex(ASM_VMX_VMLAUNCH) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jmp 2f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1: &quot;</span> __ex(ASM_VMX_VMRESUME) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"guest进入host-回到宿主机进行处理\"><a href=\"#guest进入host-回到宿主机进行处理\" class=\"headerlink\" title=\"guest进入host | 回到宿主机进行处理\"></a>guest进入host | 回到宿主机进行处理</h1><img src=\"/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%85%A5%E9%97%A8-2-KVM%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81-%E5%86%85%E6%A0%B84-4%E7%89%88%E6%9C%AC/image-20230802014945208.png\" alt=\"image-20230802014945208\" style=\"zoom:50%;\">\n\n<h3 id=\"VM-exit-退出\"><a href=\"#VM-exit-退出\" class=\"headerlink\" title=\"VM exit 退出\"></a>VM exit 退出</h3><p>​\t\t在kvm的vmx_vcpu_run函数里面执行了ASM_VMX_VMLAUNCH,将CPU置于guest模式,开始运行虚拟机的代码,<font color=\"red\">当后面遇到敏感指令的时候,CPU产生VMExit,此时KVM接管CPU,就会跳到下一行代码,jmp 2f,也就是跳到标号2的地方,看注释很明显,保存guest的寄存器,恢复host的,要进行切换( 不过目前也不完全是这样,</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;</span><br><span class=\"line\">\t<span class=\"keyword\">asm</span>(</span><br><span class=\"line\">\t\t<span class=\"comment\">/* Store host registers */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;push %%&quot;</span> _ASM_DX <span class=\"string\">&quot;; push %%&quot;</span> _ASM_BP <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">\t......</span><br><span class=\"line\"><span class=\"comment\">/* Enter guest mode */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jne 1f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t__ex(ASM_VMX_VMLAUNCH) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jmp 2f \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1: &quot;</span> __ex(ASM_VMX_VMRESUME) <span class=\"string\">&quot;\\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;2: &quot;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Save guest registers, load host registers, keep flags */</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mov %0, %c[wordsize](%%&quot;</span> _ASM_SP <span class=\"string\">&quot;) \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pop %0 \\n\\t&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;setbe %c[fail](%0)\\n\\t&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t调用vmcs_read32读取虚拟机退出的原因，保存在vcpu_vmx结构体的exit_reason成员中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __noclone <span class=\"title function_\">vmx_vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ........</span><br><span class=\"line\">vmx-&gt;exit_reason = vmcs_read32(VM_EXIT_REASON);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    vmx_complete_atomic_exit(vmx);</span><br><span class=\"line\">\tvmx_recover_nmi_blocking(vmx);</span><br><span class=\"line\">\tvmx_complete_interrupts(vmx);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t最后调用3个函数对本次退出进行预处理</p>\n<h3 id=\"回到vcpu-enter-guest进行退出的详细处理\"><a href=\"#回到vcpu-enter-guest进行退出的详细处理\" class=\"headerlink\" title=\"回到vcpu_enter_guest进行退出的详细处理\"></a>回到vcpu_enter_guest进行退出的详细处理</h3><p>​\t\t当vmx_vcpu_run运行结束,回到vcpu_enter_guest函数,</p>\n<p>x86.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">\tkvm_x86_ops-&gt;run(vcpu); <span class=\"comment\">//vmx_vcpu_run</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">\t<span class=\"comment\">/* Interrupt is enabled by handle_external_intr() */</span></span><br><span class=\"line\">\tkvm_x86_ops-&gt;handle_external_intr(vcpu);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t虚拟机退出之后会调用vmx实现的handle_external_intr回调来处理外部中断，并调用handle_exit回调来处理各种退出事件</p>\n<h3 id=\"vmx-handle-external-intr\"><a href=\"#vmx-handle-external-intr\" class=\"headerlink\" title=\"vmx_handle_external_intr\"></a>vmx_handle_external_intr</h3><p>​\t\thandle_external_intr 对应vmx_handle_external_intr</p>\n<p>​\t\t读取中断信息，判断是否是有效的中断，如果是，读取中断号vector，然后得到宿主机中对应IDT的中断门描述符，最后一段汇编用来执行处理函数，vmx_handle_external_intr会开启中断</p>\n<p>​\t\t<strong>也就是说，CPU在guest模式运行时，中断是关闭的，运行着虚拟机代码的CPU不会接收到外部中断，但是外部中断会导致CPU退出guest模式，进入VMX root模式</strong></p>\n<p>vmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_handle_external_intr</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If external interrupt exists, IF bit is set in rflags/eflags on the</span></span><br><span class=\"line\"><span class=\"comment\">\t * interrupt stack frame, and interrupt will be enabled on a return</span></span><br><span class=\"line\"><span class=\"comment\">\t * from interrupt handler.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((exit_intr_info &amp; (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))</span><br><span class=\"line\">\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"built_in\">vector</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> entry;</span><br><span class=\"line\">\t\tgate_desc *desc;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_X86_64</span></span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> tmp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span> =  exit_intr_info &amp; INTR_INFO_VECTOR_MASK;</span><br><span class=\"line\">\t\tdesc = (gate_desc *)vmx-&gt;host_idt_base + <span class=\"built_in\">vector</span>;</span><br><span class=\"line\">\t\tentry = gate_offset(*desc);</span><br><span class=\"line\">\t\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">#ifdef CONFIG_X86_64</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;mov %%&quot;</span> _ASM_SP <span class=\"string\">&quot;, %[sp]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;and $0xfffffffffffffff0, %%&quot;</span> _ASM_SP <span class=\"string\">&quot;\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;push $%c[ss]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;push %[sp]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">#endif</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;pushf\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"string\">&quot;orl $0x200, (%%&quot;</span> _ASM_SP <span class=\"string\">&quot;)\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t__ASM_SIZE(push) <span class=\"string\">&quot; $%c[cs]\\n\\t&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\tCALL_NOSPEC</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t:</span></span><br><span class=\"line\"><span class=\"params\">#ifdef CONFIG_X86_64</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[sp]<span class=\"string\">&quot;=&amp;r&quot;</span>(tmp)</span></span><br><span class=\"line\"><span class=\"params\">#endif</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t:</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tTHUNK_TARGET(entry),</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[ss]<span class=\"string\">&quot;i&quot;</span>(__KERNEL_DS),</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t[cs]<span class=\"string\">&quot;i&quot;</span>(__KERNEL_CS)</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t)</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tlocal_irq_enable();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t如果不是呢？？？？调用local_irq_enable();</p>\n<p>​\t\t</p>\n<h3 id=\"vm-handle-exit\"><a href=\"#vm-handle-exit\" class=\"headerlink\" title=\"vm_handle_exit\"></a>vm_handle_exit</h3><p>​\t\t执行完vmx_handle_external_intr后继续执行vcpu_enter_guest(x86.c)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">\tkvm_x86_ops-&gt;run(vcpu); <span class=\"comment\">//vmx_vcpu_run</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">\t<span class=\"comment\">/* Interrupt is enabled by handle_external_intr() */</span></span><br><span class=\"line\">\tkvm_x86_ops-&gt;handle_external_intr(vcpu);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t从上面可知，外部中断的处理时在handle_exit之前进行的，所以在后面handle_exit中处理外部中断的时候就没什么太多要做的了。</p>\n<p>​\t\thandle_exit 对应 vmx_handle_exit 函数，它是退出事件总的分发处理函数，<strong>在对一些特殊情况进行判断之后根据突出原因调用了kvm_vmx_exit_handlers中定义的相应的分发函数</strong></p>\n<p>​\tvmx.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_vmx</span> *<span class=\"title\">vmx</span> =</span> to_vmx(vcpu);</span><br><span class=\"line\">\tu32 exit_reason = vmx-&gt;exit_reason;</span><br><span class=\"line\">\tu32 vectoring_info = vmx-&gt;idt_vectoring_info;</span><br><span class=\"line\">...................</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tWARN_ONCE(<span class=\"number\">1</span>, <span class=\"string\">&quot;vmx: unexpected exit reason 0x%x\\n&quot;</span>, exit_reason);</span><br><span class=\"line\">\t\tkvm_queue_exception(vcpu, UD_VECTOR);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t可以看到一个关键的地方, 传入退出的原因，然后进行选择处理函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br></pre></td></tr></table></figure>\n\n<p>​\t\tkvm_vmx_exit_handlers中的EXIT_REASON_XXXX宏定义了退出的原因，对应的handle_xxx则定义了相应的处理函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"title function_\">int</span> <span class=\"params\">(*<span class=\"type\">const</span> kvm_vmx_exit_handlers[])</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span> = &#123;</span><br><span class=\"line\">\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception,</span><br><span class=\"line\">\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,</span><br><span class=\"line\">\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,</span><br><span class=\"line\">\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,</span><br><span class=\"line\">\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,</span><br><span class=\"line\">\t[EXIT_REASON_CR_ACCESS]               = handle_cr,</span><br><span class=\"line\">\t[EXIT_REASON_DR_ACCESS]               = handle_dr,</span><br><span class=\"line\">\t[EXIT_REASON_CPUID]                   = handle_cpuid,</span><br><span class=\"line\">\t[EXIT_REASON_MSR_READ]                = handle_rdmsr,</span><br><span class=\"line\">\t[EXIT_REASON_MSR_WRITE]               = handle_wrmsr,</span><br><span class=\"line\">\t[EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,</span><br><span class=\"line\">\t[EXIT_REASON_HLT]                     = handle_halt,</span><br><span class=\"line\">\t[EXIT_REASON_INVD]\t\t      = handle_invd,</span><br><span class=\"line\">\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,</span><br><span class=\"line\">\t[EXIT_REASON_RDPMC]                   = handle_rdpmc,</span><br><span class=\"line\">\t[EXIT_REASON_VMCALL]                  = handle_vmcall,</span><br><span class=\"line\">\t[EXIT_REASON_VMCLEAR]\t              = handle_vmclear,</span><br><span class=\"line\">\t[EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,</span><br><span class=\"line\">\t[EXIT_REASON_VMPTRLD]                 = handle_vmptrld,</span><br><span class=\"line\">\t[EXIT_REASON_VMPTRST]                 = handle_vmptrst,</span><br><span class=\"line\">\t[EXIT_REASON_VMREAD]                  = handle_vmread,</span><br><span class=\"line\">\t[EXIT_REASON_VMRESUME]                = handle_vmresume,</span><br><span class=\"line\">\t[EXIT_REASON_VMWRITE]                 = handle_vmwrite,</span><br><span class=\"line\">\t[EXIT_REASON_VMOFF]                   = handle_vmoff,</span><br><span class=\"line\">\t[EXIT_REASON_VMON]                    = handle_vmon,</span><br><span class=\"line\">\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,</span><br><span class=\"line\">\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,</span><br><span class=\"line\">\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,</span><br><span class=\"line\">\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,</span><br><span class=\"line\">\t[EXIT_REASON_WBINVD]                  = handle_wbinvd,</span><br><span class=\"line\">\t[EXIT_REASON_XSETBV]                  = handle_xsetbv,</span><br><span class=\"line\">\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,</span><br><span class=\"line\">\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,</span><br><span class=\"line\">\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,</span><br><span class=\"line\">\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,</span><br><span class=\"line\">\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,</span><br><span class=\"line\">\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,</span><br><span class=\"line\">\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,</span><br><span class=\"line\">\t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,</span><br><span class=\"line\">\t[EXIT_REASON_INVEPT]                  = handle_invept,</span><br><span class=\"line\">\t[EXIT_REASON_INVVPID]                 = handle_invvpid,</span><br><span class=\"line\">\t[EXIT_REASON_XSAVES]                  = handle_xsaves,</span><br><span class=\"line\">\t[EXIT_REASON_XRSTORS]                 = handle_xrstors,</span><br><span class=\"line\">\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,</span><br><span class=\"line\">\t[EXIT_REASON_PCOMMIT]                 = handle_pcommit,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t对应的处理函数怎么找呢？？？ 在哪里呢？ 搜了一下，搜的几个都还是在这个vmx.c文件里</p>\n<p>​\t\t有的退出事件KVM能够自己处理，这个时候就直接处理然后返回，准备下一轮的VCPU运行，如果KVM无法处理，则需要将事件分发到QEMU进行处理</p>\n<h3 id=\"自己处理的例子：-handle-cpuid\"><a href=\"#自己处理的例子：-handle-cpuid\" class=\"headerlink\" title=\"自己处理的例子： handle_cpuid\"></a>自己处理的例子： handle_cpuid</h3><p>​\t\t看代码,它的原理是查询之前QEMU的设置,然后直接返回,只需要通过KVM就可以完成. <strong>返回1,这个值也作为vcpu_enter_guest的返回值, 为1表示不需要让虚拟机回到QEMU</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_cpuid</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tkvm_emulate_cpuid(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要返回QEMU处理的例子-handle-io\"><a href=\"#需要返回QEMU处理的例子-handle-io\" class=\"headerlink\" title=\"需要返回QEMU处理的例子  handle_io\"></a>需要返回QEMU处理的例子  handle_io</h3><p>​\t\t对该函数进行一路追踪,能看到最后返回了0,所以需要返回QEMU进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_io</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_fast_pio_out(vcpu, size, port);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t返回退出的代码如下, r&#x3D;&#x3D;0的话会进入break,导致该函数退出 for循环,进而使得ioctl返回用户态</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t也就是返回到了kvm_arch_vcpu_ioctl_run,再进行返回,就到了QEMU里面了.</p>\n<p>​\t\t在QEMU里面处理完之后再次通过host进入guest的流程,</p>\n",
            "tags": [
                "KVM"
            ]
        }
    ]
}