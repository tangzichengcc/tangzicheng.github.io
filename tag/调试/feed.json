{
    "version": "https://jsonfeed.org/version/1",
    "title": "唐仔橙 • All posts by \"调试\" tag",
    "description": "喜欢探索世界,在读研究生,计算机爱好者的成长记录",
    "home_page_url": "https://tangzichengcc.github.io",
    "items": [
        {
            "id": "https://tangzichengcc.github.io/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/",
            "url": "https://tangzichengcc.github.io/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/",
            "title": "盛格塾课程-拍案惊奇GDB以战说法1-谁截断了我的指针?",
            "date_published": "2023-10-26T13:54:31.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>​\t之前知道老师是因为《软件调试》这本书，非常厉害，但是因为主要是windows的一直还没读（因为主要学习Linux，不过最近越发感觉不能局限于一个系统），最近看见一个大佬在朋友圈转发这个课，才发现张老师原来是有自己的公司和培训，看了下来太牛了，立马报名了。</p>\n<p>​\t(老师b站也有号, 官网nanocode.cn,) 还有其他很多优秀的课程,看来要好好买一波了..这才是真正有价值的知识付费!!</p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>​\t老师将实际案例中的一个问题抽象出了一个很简单的demo, 用于搜索argv[0]的名字, 其实也就是当前可执行程序的名字,本身看着这个代码是没有什么问题的(不,有问题,没有include parser.c)</p>\n<p>parser.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// parser.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"title function_\">get_name</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* full_path)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span> * sep = <span class=\"built_in\">strrchr</span>(full_path, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (sep == <span class=\"literal\">NULL</span>)? <span class=\"string\">&quot;errname&quot;</span>: sep+<span class=\"number\">1</span>;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>ptrtrap.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>* name = get_name(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Demo of pointer trap by Raymond.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name: %s\\n&quot;</span>, name);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t在编译的时候会给出一个警告</p>\n<p>gcc -g ptrtrap.c parser.c</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@VM-4-8-ubuntu:/home/ubuntu/youlan# gcc -g ptrtrap.c parser.c</span><br><span class=\"line\">ptrtrap.c: In function ‘main’:</span><br><span class=\"line\">ptrtrap.c:5:22: warning: implicit declaration of function ‘get_name’; did you mean ‘rename’? [-Wimplicit-function-declaration]</span><br><span class=\"line\">    5 |         char* name = get_name(argv[0]);</span><br><span class=\"line\">      |                      ^~~~~~~~</span><br><span class=\"line\">      |                      rename</span><br><span class=\"line\">ptrtrap.c:5:22: warning: initialization of ‘char *’ from ‘int’ makes pointer from integer without a cast [-Wint-conversion]</span><br></pre></td></tr></table></figure>\n\n<p>​\t运行的时候会发生段错误</p>\n<p>Program received signal SIGSEGV, Segmentation fault</p>\n<p>段错误，访问了不该访问的</p>\n<p><img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/image-20231024145754493.png\" alt=\"image-20231024145754493\"></p>\n<h1 id=\"调试分析\"><a href=\"#调试分析\" class=\"headerlink\" title=\"调试分析\"></a>调试分析</h1><h2 id=\"回溯粗看\"><a href=\"#回溯粗看\" class=\"headerlink\" title=\"回溯粗看\"></a>回溯粗看</h2><p>​\t朱熹的不远复:“不远复”，出自《易经》“不远之复，以修身也”。和孔子的吾日三省吾身有异曲同工之妙,人要不断反思自己,反省走的路.</p>\n<p>​\tbt命令回溯 调用栈 , <strong>库函数一般都经过很多修改和测试、一般没问题，所以更多的还是自己写的代码的问题</strong></p>\n<p><img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/image-20231024150010518.png\" alt=\"image-20231024150010518\"></p>\n<p>​\t可以减少bt的显示，如 bt -frame-info short-location 不带源代码位置</p>\n<p>​\tframe 3查看自己写的函数里的栈帧的情况, list查看源代码， 这样就能够看到上下文， disass查看汇编</p>\n<p><img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/image-20231024150656532.png\" alt=\"image-20231024150656532\"></p>\n<p>​\t所以能够看到问题是在 call  printf这里，产生了问题, <strong>也就是传入的name有问题</strong></p>\n<p>​\t问: __printf为什么带下划线？</p>\n<p>​\t答: 因为__printf是libc实现的，   _ _通常是编译器的函数 编译器的优化？</p>\n<p>​\tinfo shared查看进程里的库, ld负责把程序从外存搬运到内存, libc负责实现标准库函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; info shared</span><br><span class=\"line\">From                To                  Syms Read   Shared Object Library</span><br><span class=\"line\">0x00007ffff7fc5090  0x00007ffff7fee315  Yes         /lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">0x00007ffff7daf700  0x00007ffff7f41b3d  Yes         /lib/x86_64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数从哪里开始执行？\"><a href=\"#函数从哪里开始执行？\" class=\"headerlink\" title=\"函数从哪里开始执行？\"></a>函数从哪里开始执行？</h4><p>​\telf从哪里开始呢，不是main 是_start(), bt有个选项 -past-main查看main函数之前的,有的默认开启了</p>\n<p>__libc_start_call_main 用来做准备工作？</p>\n<h2 id=\"细看崩溃指令\"><a href=\"#细看崩溃指令\" class=\"headerlink\" title=\"细看崩溃指令\"></a>细看崩溃指令</h2><p>​\t来到崩溃的那一行汇编来看看什么情况,这里指向的含义是 尝试执行这条指令，但是失败了</p>\n<p><img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/image-20231024151819672.png\" alt=\"image-20231024151819672\"></p>\n<p>vpcmpeqb指令</p>\n<p>​\t[rdi]是引用内存, 此时的rdi的值是0xffffffffffffe7db,我们来看一下内存的情况,用info inferiors命令,查看进程,然后从proc里看内存(pwndbg可以直接vmmap)</p>\n<p>​\t从这里看地址就能看出来，是无效地址, 用户空间的大小早超了(所以说每个细节都需要关注)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">info inferiors</span></span><br><span class=\"line\">  Num  Description       Connection           Executable</span><br><span class=\"line\">* 1    process 1269337   1 (native)           /home/ubuntu/youlan/a.out</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">!<span class=\"built_in\">cat</span> /proc/1269337/maps</span></span><br><span class=\"line\">555555554000-555555555000 r--p 00000000 fc:02 822041                     /home/ubuntu/youlan/a.out</span><br><span class=\"line\">555555555000-555555556000 r-xp 00001000 fc:02 822041                     /home/ubuntu/youlan/a.out</span><br><span class=\"line\">555555556000-555555557000 r--p 00002000 fc:02 822041                     /home/ubuntu/youlan/a.out</span><br><span class=\"line\">555555557000-555555558000 r--p 00002000 fc:02 822041                     /home/ubuntu/youlan/a.out</span><br><span class=\"line\">555555558000-555555559000 rw-p 00003000 fc:02 822041                     /home/ubuntu/youlan/a.out</span><br><span class=\"line\">555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]</span><br><span class=\"line\">7ffff7d84000-7ffff7d87000 rw-p 00000000 00:00 0</span><br><span class=\"line\">7ffff7d87000-7ffff7daf000 r--p 00000000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class=\"line\">7ffff7daf000-7ffff7f44000 r-xp 00028000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class=\"line\">7ffff7f44000-7ffff7f9c000 r--p 001bd000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class=\"line\">7ffff7f9c000-7ffff7fa0000 r--p 00214000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class=\"line\">7ffff7fa0000-7ffff7fa2000 rw-p 00218000 fc:02 29791                      /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class=\"line\">7ffff7fa2000-7ffff7faf000 rw-p 00000000 00:00 0</span><br><span class=\"line\">7ffff7fbb000-7ffff7fbd000 rw-p 00000000 00:00 0</span><br><span class=\"line\">7ffff7fbd000-7ffff7fc1000 r--p 00000000 00:00 0                          [vvar]</span><br><span class=\"line\">7ffff7fc1000-7ffff7fc3000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class=\"line\">7ffff7fc3000-7ffff7fc5000 r--p 00000000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class=\"line\">7ffff7fc5000-7ffff7fef000 r-xp 00002000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class=\"line\">7ffff7fef000-7ffff7ffa000 r--p 0002c000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class=\"line\">7ffff7ffb000-7ffff7ffd000 r--p 00037000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class=\"line\">7ffff7ffd000-7ffff7fff000 rw-p 00039000 fc:02 2337                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class=\"line\">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class=\"line\">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"何人传来无效指针\"><a href=\"#何人传来无效指针\" class=\"headerlink\" title=\"何人传来无效指针?\"></a>何人传来无效指针?</h2><p>​\t库函数出问题概率很低，所以找自己写的函数.  我们知道问题出在name变量上</p>\n<p>​\tframe 3 、然后用 p name 、info locals 都能看到是无效的</p>\n<p><img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/Snipaste_2023-10-26_17-16-56.jpg\" alt=\"Snipaste_2023-10-26_17-16-56\"></p>\n<p>​\tinfo frame 看函数的栈帧信息</p>\n<p>​\t既然是name错了 它哪里来的？ <strong>get_name</strong>，</p>\n<h3 id=\"get-name调试\"><a href=\"#get-name调试\" class=\"headerlink\" title=\"get_name调试\"></a>get_name调试</h3><p>​\t设置get_name的断点进行调试</p>\n<p>​\t返回值看rax（通常通用寄存器第一个存返回值），<strong>rax在返回的时候是没问题的，那哪里出问题了。。此时事情就很奇怪了</strong></p>\n<img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/Snipaste_2023-10-26_17-38-09.jpg\" alt=\"Snipaste_2023-10-26_17-38-09\" style=\"zoom:50%;\">\n\n\n\n<p>返回后执行ni, 单步一下,再看值,就错了</p>\n<img src=\"/%E7%9B%9B%E6%A0%BC%E5%A1%BE%E8%AF%BE%E7%A8%8B-%E6%8B%8D%E6%A1%88%E6%83%8A%E5%A5%87GDB%E4%BB%A5%E6%88%98%E8%AF%B4%E6%B3%951-%E8%B0%81%E6%88%AA%E6%96%AD%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%87%E9%92%88/Snipaste_2023-10-26_17-35-28.jpg\" alt=\"Snipaste_2023-10-26_17-35-28\" style=\"zoom:50%;\">\n\n\n\n<h2 id=\"答案揭晓\"><a href=\"#答案揭晓\" class=\"headerlink\" title=\"答案揭晓\"></a>答案揭晓</h2><p>​\t问题就出在这一条指令上,它改变了值的大小</p>\n<p>​\tcdqe: 扩展指令,使用eax的最高位拓展rax高32位的所有位</p>\n<p>​\tx86下和arm不太一样, sxtw这条指令有问题（arm下</p>\n<p>​\t<font color=\"red\">这是编译器故意产生的指令,和没有include这个函数有关系</font>,再深入的..就先放放</p>\n<h1 id=\"问题与知识补充\"><a href=\"#问题与知识补充\" class=\"headerlink\" title=\"问题与知识补充\"></a>问题与知识补充</h1><ol>\n<li>include进来就没问题了</li>\n</ol>\n<p> #include “parser.c”</p>\n<p>但是有个新的warning</p>\n<p>32位下编译没问题</p>\n<p>为什么会有一个nop指令</p>\n<p>nop插桩</p>\n<h3 id=\"如何跑arm系统\"><a href=\"#如何跑arm系统\" class=\"headerlink\" title=\"如何跑arm系统\"></a>如何跑arm系统</h3><p>macbook直接可以</p>\n<p>x86怎么装？：看样子基本上离不开qemu</p>\n<p>云服务器买</p>\n<p><a href=\"https://blog.csdn.net/chenxiangneu/article/details/78955462\">https://blog.csdn.net/chenxiangneu/article/details/78955462</a></p>\n<p>设置符号服务器？</p>\n<h3 id=\"失败了如何再执行？\"><a href=\"#失败了如何再执行？\" class=\"headerlink\" title=\"失败了如何再执行？\"></a>失败了如何再执行？</h3><p>info signal</p>\n<p>info handle</p>\n<p>handle SIGSEGV nopass （不给应用程序</p>\n<p>再跑一遍又会收到这个信号</p>\n<p>smd指令。。。</p>\n<p>用户空间 内核空间大小</p>\n",
            "tags": [
                "调试"
            ]
        }
    ]
}